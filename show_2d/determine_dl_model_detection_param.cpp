///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Deep Learning / Model
// Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
extern void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
    HTuple hv_Mode, HTuple *hv_SampleIndices);
// Chapter: Graphics / Output
// Short Description: Plot tuples representing functions or curves in a coordinate system. 
extern void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
    HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Tuple / Element Order
// Short Description: Sort the elements of a tuple randomly. 
extern void tuple_shuffle (HTuple hv_Tuple, HTuple *hv_Shuffled);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Collect data concerning the shape of the ground truth bounding boxes provided in DLDataset. 
void analyze_dl_dataset_detection (HTuple hv_DLDataset, HTuple hv_InstanceType, HTuple hv_ImageWidthTarget, 
    HTuple hv_ImageHeightTarget, HTuple hv_GenParam, HTuple *hv_Areas, HTuple *hv_AspectRatios, 
    HTuple *hv_Angles, HTuple *hv_MaxOverlap, HTuple *hv_MaxOverlapClassAgnostic);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Perform a k-means clustering on the given parameter values. 
void cluster_dl_detection_param (HTuple hv_Values, HTuple hv_K, HTuple hv_MinRatio, 
    HTuple hv_MinDiff, HTuple hv_IsAngle, HTuple *hv_ClusteredValues);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Cluster the given data Points with the specified initial cluster centers InitialClusterCenters. 
void cluster_kmeans_1d (HTuple hv_Points, HTuple hv_InitialClusterCenters, HTuple hv_MaxIteration, 
    HTuple hv_MinDelta, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_PointClusters, 
    HTuple *hv_ClusterCenters);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Cluster angles with a simplified kmeans algorithm. 
void cluster_kmeans_angles (HTuple hv_Points, HTuple hv_InitialClusterCenters, HTuple hv_MaxIteration, 
    HTuple hv_MinDelta, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_PointClusters, 
    HTuple *hv_ClusterCenters);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_iou_rect1 (HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, HTuple hv_Col2, 
    HTuple *hv_IoU);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_iou_rect2 (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, HTuple hv_Length2, 
    HTuple hv_Phi, HTuple *hv_IoU);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_max_overlap (HTuple hv_BoundingBox, HTuple hv_MaxOverlapDict);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Analyze the provided DLDataset for object detection to find model parameters relevant for anchor generation. 
void determine_dl_model_detection_param (HTuple hv_DLDataset, HTuple hv_ImageWidthTarget, 
    HTuple hv_ImageHeightTarget, HTuple hv_GenParam, HTuple *hv_DLDetectionModelParam);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Generate a histogram out of the input and displays the plot. 
void plot_dl_detection_histogram (HTuple hv_DataCollection, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_WindowHandle);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Remove given ratio of the smallest and largest data points in the data collection DataCollection. 
void remove_dl_data_outliers (HTuple hv_DataCollection, HTuple *hv_DataCollectionReduced);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Calculate the scaled bounding box parameters for a bounding box of type rectangle2. 
void scale_rectangle2_bbox (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, HTuple hv_Length2, 
    HTuple hv_Phi, HTuple hv_FactorHeight, HTuple hv_FactorWidth, HTuple *hv_NewRow, 
    HTuple *hv_NewCol, HTuple *hv_NewLength1, HTuple *hv_NewLength2, HTuple *hv_NewPhi);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Suggest the minimum and maximum level as well as the number of anchor subscales for an object detection model. 
void select_dl_detection_levels (HTuple hv_Areas, HTuple hv_MinLevel, HTuple hv_MaxLevel, 
    HTuple hv_AnchorNumSubscales, HTuple *hv_MinLevelToUse, HTuple *hv_MaxLevelToUse, 
    HTuple *hv_AnchorNumSubscalesToUse);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Compute a percentile of a tuple. 
void tuple_percentile (HTuple hv_Tuple, HTuple hv_Percentile, HTuple *hv_Value);

// Procedures 
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Collect data concerning the shape of the ground truth bounding boxes provided in DLDataset. 
void analyze_dl_dataset_detection (HTuple hv_DLDataset, HTuple hv_InstanceType, HTuple hv_ImageWidthTarget, 
    HTuple hv_ImageHeightTarget, HTuple hv_GenParam, HTuple *hv_Areas, HTuple *hv_AspectRatios, 
    HTuple *hv_Angles, HTuple *hv_MaxOverlap, HTuple *hv_MaxOverlapClassAgnostic)
{

  // Local iconic variables
  HObject  ho_Image, ho_Domain;

  // Local control variables
  HTuple  hv_ImageWidthRaw, hv_ImageHeightRaw, hv_DomainHandling;
  HTuple  hv_DatasetSplit, hv_PreprocessedPath, hv_Preprocessed;
  HTuple  hv_ClassIDsNoOrientation, hv_IgnoreDirection, hv_MaxNumSamples;
  HTuple  hv_ImageSizeConstant, hv_ComputeMaxOverlap, hv_AllocationBlockLength;
  HTuple  hv_InstanceCount, hv_Rows1, hv_Cols1, hv_Rows2;
  HTuple  hv_Cols2, hv_Lengths1, hv_Lengths2, hv_Phis, hv_GenParamName;
  HTuple  hv_GenParamIndex, hv_PreprocessedKey, hv_PreprocessedKeyExists;
  HTuple  hv_FactorWidth, hv_FactorHeight, hv_DLSamples, hv_ImageDir;
  HTuple  hv_SampleIndices, hv_MaxOverlapDict, hv_IterationIndex;
  HTuple  hv_SampleIndex, hv_DLSampleCurrent, hv_KeyFileExists;
  HTuple  hv_FileNameSample, hv_FileNameRelative, hv_Exception;
  HTuple  hv_ImageName, hv_Width, hv_Height, hv_DomainRow1;
  HTuple  hv_DomainColumn1, hv_DomainRow2, hv_DomainColumn2;
  HTuple  hv_WidthDomain, hv_HeightDomain, hv_Row1, hv_Col1;
  HTuple  hv_Row2, hv_Col2, hv_BoxMask, hv_Row, hv_Col, hv_Length1;
  HTuple  hv_Length2, hv_Phi, hv_Label, hv_ClassIDsNoOrientationIndices;
  HTuple  hv_Index, hv_ClassIDsNoOrientationIndicesTmp, hv_DirectionLength1Row;
  HTuple  hv_DirectionLength1Col, hv_DirectionLength2Row;
  HTuple  hv_DirectionLength2Col, hv_Corner1Row, hv_Corner1Col;
  HTuple  hv_Corner2Row, hv_Corner2Col, hv_Pi, hv_PhiMod;
  HTuple  hv_IgnoreMask, hv_SwapMask, hv_SwapMaskInverted;
  HTuple  hv_Length1Tmp, hv_Length2Tmp, hv_PhiMultMask, hv_KeyExists;
  HTuple  hv_BoundingBox, hv_IdxsWithOverlap, hv_Percentile;
  HTuple  hv_RelaxFactor, hv_Heights, hv_Widths, hv___Tmp_Ctrl_Dict_Init_0;
  HTuple  hv___Tmp_Ctrl_Dict_Init_1, hv___Tmp_Ctrl_Dict_Init_2;
  HTuple  hv___Tmp_Ctrl_Dict_Init_3, hv___Tmp_Ctrl_Dict_Init_4;
  HTuple  hv___Tmp_Ctrl_Dict_Init_5, hv___Tmp_Ctrl_Type;

  //This procedure creates various data collections from the given DLDataset
  //for DL Object Detection which are
  //- the areas of the ground truth bounding boxes
  //- the aspect ratios of the ground truth bounding boxes
  //- the orientations of the ground truth bounding boxes for rectangle2 object detection.
  //
  //
  //Default generic parameter values.
  hv_ImageWidthRaw = HTuple();
  hv_ImageHeightRaw = HTuple();
  hv_DomainHandling = "full_domain";
  hv_DatasetSplit = "train";
  hv_PreprocessedPath = "";
  hv_Preprocessed = 0;
  hv_ClassIDsNoOrientation = HTuple();
  hv_IgnoreDirection = 0;
  hv_MaxNumSamples = 1500;
  hv_ImageSizeConstant = 1;
  hv_ComputeMaxOverlap = 1;
  //
  //Output data tuples.
  (*hv_Areas) = HTuple();
  (*hv_AspectRatios) = HTuple();
  (*hv_Angles) = HTuple();
  (*hv_MaxOverlap) = HTuple();
  (*hv_MaxOverlapClassAgnostic) = HTuple();
  //
  //Box parameter tuples are allocated in blocks to speed up the procedure.
  hv_AllocationBlockLength = 1000;
  hv_InstanceCount = 0;
  //
  //Bounding box parameters for rectangle1.
  hv_Rows1 = HTuple(hv_AllocationBlockLength,0.);
  hv_Cols1 = HTuple(hv_AllocationBlockLength,0.);
  hv_Rows2 = HTuple(hv_AllocationBlockLength,0.);
  hv_Cols2 = HTuple(hv_AllocationBlockLength,0.);
  //Bounding box parameters for rectangle2.
  hv_Lengths1 = HTuple(hv_AllocationBlockLength,0.);
  hv_Lengths2 = HTuple(hv_AllocationBlockLength,0.);
  hv_Phis = HTuple(hv_AllocationBlockLength,0.);
  //
  //Read generic parameters and check the provided values.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamName);
    {
    HTuple end_val44 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val44 = 1;
    for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val44, step_val44); hv_GenParamIndex += step_val44)
    {
      if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("raw_width"))))
      {
        hv_ImageWidthRaw = hv_GenParam.TupleGetDictTuple("raw_width");
        if (0 != ((hv_ImageWidthRaw.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (int(hv_ImageWidthRaw<1)))
        {
          throw HException(("Invalid value for parameter 'raw_width': "+hv_ImageWidthRaw)+".");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("raw_height"))))
      {
        hv_ImageHeightRaw = hv_GenParam.TupleGetDictTuple("raw_height");
        if (0 != ((hv_ImageHeightRaw.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (int(hv_ImageHeightRaw<1)))
        {
          throw HException(("Invalid value for parameter 'raw_height': "+hv_ImageHeightRaw)+".");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("domain_handling"))))
      {
        hv_DomainHandling = hv_GenParam.TupleGetDictTuple("domain_handling");
        if (0 != (HTuple(int(hv_DomainHandling!=HTuple("full_domain"))).TupleAnd(int(hv_DomainHandling!=HTuple("crop_domain")))))
        {
          throw HException(("Invalid value for parameter 'domain_handling': "+hv_DomainHandling)+".");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("split"))))
      {
        hv_DatasetSplit = hv_GenParam.TupleGetDictTuple("split");
        if (0 != ((hv_DatasetSplit.TupleIsString()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type string");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("preprocessed_path"))))
      {
        hv_PreprocessedPath = hv_GenParam.TupleGetDictTuple("preprocessed_path");
        if (0 != ((hv_PreprocessedPath.TupleIsString()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type string");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("class_ids_no_orientation"))))
      {
        hv_ClassIDsNoOrientation = hv_GenParam.TupleGetDictTuple("class_ids_no_orientation");
        if (0 != (int(hv_InstanceType!=HTuple("rectangle2"))))
        {
          throw HException((("Parameter '"+HTuple(hv_GenParamName[hv_GenParamIndex]))+"' is only available for ")+"detection type 'rectangle2'");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("ignore_direction"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_0);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
        hv_IgnoreDirection = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1)).TupleTestEqualDictItem("ignore_direction","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0)).TupleTestEqualDictItem("ignore_direction","comp"));
        hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_0 = HTuple::TupleConstant("HNULL");
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("max_num_samples"))))
      {
        hv_MaxNumSamples = hv_GenParam.TupleGetDictTuple("max_num_samples");
        if (0 != ((hv_MaxNumSamples.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (HTuple(int(hv_MaxNumSamples<1)).TupleAnd(int(hv_MaxNumSamples!=-1))))
        {
          throw HException(("Invalid value for parameter 'max_num_samples': "+hv_MaxNumSamples)+". Only -1 or values greater or equal to 1 are allowed.");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("image_size_constant"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_2);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_3);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", "true");
        hv_ImageSizeConstant = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3)).TupleTestEqualDictItem("image_size_constant","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2)).TupleTestEqualDictItem("image_size_constant","comp"));
        hv___Tmp_Ctrl_Dict_Init_3 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_2 = HTuple::TupleConstant("HNULL");
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("compute_max_overlap"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_4);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_4, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_5);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_5, "comp", "true");
        hv_ComputeMaxOverlap = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_5)).TupleTestEqualDictItem("compute_max_overlap","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_4)).TupleTestEqualDictItem("compute_max_overlap","comp"));
        hv___Tmp_Ctrl_Dict_Init_5 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_4 = HTuple::TupleConstant("HNULL");
      }
    }
    }
  }
  //
  //Check whether the DLDataset is already preprocessed.
  hv_PreprocessedKey = "dlsample_dir";
  GetDictParam(hv_DLDataset, "key_exists", hv_PreprocessedKey, &hv_PreprocessedKeyExists);
  if (0 != hv_PreprocessedKeyExists)
  {
    hv_Preprocessed = 1;
    if (0 != (int(hv_PreprocessedPath==HTuple(""))))
    {
      hv_PreprocessedPath = hv_DLDataset.TupleGetDictTuple(hv_PreprocessedKey);
    }
    else
    {
      hv_PreprocessedPath += HTuple("/samples");
    }
  }
  else
  {
    if (0 != (int(hv_PreprocessedPath!=HTuple(""))))
    {
      throw HException(HTuple(HTuple("The given dataset is not preprocessed but a preprocessing path is given. Please either use ")+"a preprocessed dataset as input or remove the specification for 'preprocessed_path' from ")+"the generic parameter dictionary GenParam.");
    }
    else
    {
      //If the DLDataset is not preprocessed, check whether the necessary preprocessing parameters
      //are provided.
      if (0 != (HTuple(int(hv_ImageWidthTarget==HTuple())).TupleOr(int(hv_ImageHeightTarget==HTuple()))))
      {
        throw HException("Please enter values for the target image width and height.");
      }
      else if (0 != (HTuple(int(hv_ImageWidthTarget<1)).TupleOr(int(hv_ImageHeightTarget<1))))
      {
        throw HException("Please enter valid values for the target image width and height.");
      }
      //In case the original images are of the same size (specified by the input
      //parameters), the scaling factors can be calculated here.
      if (0 != (HTuple(int(hv_ImageWidthRaw!=HTuple())).TupleAnd(int(hv_ImageHeightRaw!=HTuple()))))
      {
        hv_FactorWidth = (hv_ImageWidthTarget.TupleReal())/hv_ImageWidthRaw;
        hv_FactorHeight = (hv_ImageHeightTarget.TupleReal())/hv_ImageHeightRaw;
      }
    }
  }
  //
  //Get the samples in the dataset.
  hv_DLSamples = hv_DLDataset.TupleGetDictTuple("samples");
  hv_ImageDir = hv_DLDataset.TupleGetDictTuple("image_dir");
  //
  //Get the relevant sample indices.
  hv_SampleIndices = HTuple::TupleGenSequence(0,(hv_DLSamples.TupleLength())-1,1);
  if (0 != (int(hv_DatasetSplit!=HTuple("all"))))
  {
    find_dl_samples(hv_DLSamples, "split", hv_DatasetSplit, "or", &hv_SampleIndices);
    if (0 != (int((hv_SampleIndices.TupleLength())==0)))
    {
      throw HException(("No samples found for the specified dataset split: "+hv_DatasetSplit)+".");
    }
  }
  //
  //Reduce the number of samples if max_num_samples is specified.
  if (0 != (HTuple(int(hv_MaxNumSamples!=-1)).TupleAnd(int((hv_SampleIndices.TupleLength())>hv_MaxNumSamples))))
  {
    tuple_shuffle(hv_SampleIndices, &hv_SampleIndices);
    hv_SampleIndices = hv_SampleIndices.TupleSelectRange(0,hv_MaxNumSamples-1);
  }
  //
  if (0 != hv_ComputeMaxOverlap)
  {
    //Initialize some variables.
    CreateDict(&hv_MaxOverlapDict);
    SetDictTuple(hv_MaxOverlapDict, "max_overlaps_class_agnostic", HTuple(hv_AllocationBlockLength,-1));
    SetDictTuple(hv_MaxOverlapDict, "max_overlaps", HTuple(hv_AllocationBlockLength,-1));
    SetDictTuple(hv_MaxOverlapDict, "max_overlap", 0.);
    SetDictTuple(hv_MaxOverlapDict, "max_overlap_class_agnostic", 0.);
    SetDictTuple(hv_MaxOverlapDict, "num_max_overlaps", 0);
    SetDictTuple(hv_MaxOverlapDict, "num_max_overlaps_class_agnostic", 0);
  }
  //
  //Iterate over the samples and store information on the ground truth
  //bounding boxes.
  {
  HTuple end_val179 = (hv_SampleIndices.TupleLength())-1;
  HTuple step_val179 = 1;
  for (hv_IterationIndex=0; hv_IterationIndex.Continue(end_val179, step_val179); hv_IterationIndex += step_val179)
  {
    hv_SampleIndex = HTuple(hv_SampleIndices[hv_IterationIndex]);
    hv_DLSampleCurrent = HTuple(hv_DLSamples[hv_SampleIndex]);
    if (0 != hv_Preprocessed)
    {
      //Check whether the file name key of the preprocessed samples is available.
      GetDictParam(hv_DLSampleCurrent, "key_exists", "dlsample_file_name", &hv_KeyFileExists);
      if (0 != hv_KeyFileExists)
      {
        hv_FileNameSample = (hv_PreprocessedPath+"/")+(hv_DLSampleCurrent.TupleGetDictTuple("dlsample_file_name"));
      }
      else
      {
        //If the key does not exist, check if a corresponding file exists.
        hv_FileNameRelative = (hv_DLSampleCurrent.TupleGetDictTuple("image_id"))+"_dlsample.hdict";
        hv_FileNameSample = (hv_PreprocessedPath+"/")+hv_FileNameRelative;
      }
      //Read the dictionary of the preprocessed sample.
      try
      {
        ReadDict(hv_FileNameSample, HTuple(), HTuple(), &hv_DLSampleCurrent);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException((("An error has occurred while reading "+hv_FileNameSample)+HTuple(" , HALCON error # "))+HTuple(hv_Exception[0]));
      }
      //Set the scaling factors to 1 since the samples are already preprocessed.
      hv_FactorWidth = 1.;
      hv_FactorHeight = 1.;
      if (0 != (HTuple(int(hv_ImageWidthTarget==HTuple())).TupleOr(int(hv_ImageHeightTarget==HTuple()))))
      {
        //Set the preprocessed width and height to be used in the output.
        //The GenParam dictionary is recycled for this.
        GetImageSize(hv_DLSampleCurrent.TupleGetDictObject("image"), &hv_ImageWidthTarget, 
            &hv_ImageHeightTarget);
        SetDictTuple(hv_GenParam, "image_width_target", hv_ImageWidthTarget);
        SetDictTuple(hv_GenParam, "image_height_target", hv_ImageHeightTarget);
      }
    }
    else
    {
      //In case the samples are not preprocessed, we need to scale them according
      //to the target image sizes as well as perform domain handling if necessary.
      //The images need to be read in case the raw sizes are not provided or
      //the domain should be cropped.
      if (0 != (HTuple(HTuple(int(hv_ImageWidthRaw==HTuple())).TupleOr(int(hv_ImageHeightRaw==HTuple()))).TupleOr(int(hv_DomainHandling==HTuple("crop_domain")))))
      {
        hv_ImageName = hv_DLSampleCurrent.TupleGetDictTuple("image_file_name");
        try
        {
          ReadImage(&ho_Image, (hv_ImageDir+"/")+hv_ImageName);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          throw HException(((("Error while reading image "+hv_ImageDir)+"/")+hv_ImageName)+".");
        }
      }
      //In case the original images have variable sizes, the image
      //sizes need to be read in order to calculate the scaling factors.
      if (0 != (HTuple(int(hv_ImageWidthRaw==HTuple())).TupleOr(int(hv_ImageHeightRaw==HTuple()))))
      {
        //Read the image.
        GetImageSize(ho_Image, &hv_Width, &hv_Height);
        //Get the object sizes after preprocessing.
        hv_FactorWidth = (hv_ImageWidthTarget.TupleReal())/hv_Width;
        hv_FactorHeight = (hv_ImageHeightTarget.TupleReal())/hv_Height;
        //If we know that each image has the same size we can use the size
        //of the first one for all other images.
        if (0 != hv_ImageSizeConstant)
        {
          hv_ImageWidthRaw = hv_Width;
          hv_ImageHeightRaw = hv_Height;
        }
      }
      //Get the domain borders if the domain should be cropped.
      if (0 != (int(hv_DomainHandling==HTuple("crop_domain"))))
      {
        //Get domain.
        GetDomain(ho_Image, &ho_Domain);
        //Set the size of the raw image to the domain extensions.
        SmallestRectangle1(ho_Domain, &hv_DomainRow1, &hv_DomainColumn1, &hv_DomainRow2, 
            &hv_DomainColumn2);
        //Get the object sizes after preprocessing.
        hv_WidthDomain = (hv_DomainColumn2-hv_DomainColumn1)+1;
        hv_HeightDomain = (hv_DomainRow2-hv_DomainRow1)+1;
        hv_FactorWidth = (hv_ImageWidthTarget.TupleReal())/hv_WidthDomain;
        hv_FactorHeight = (hv_ImageHeightTarget.TupleReal())/hv_HeightDomain;
      }
    }
    //
    //Collect ground truth information for instance type rectangle1.
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      //Get the sample bounding boxes.
      try
      {
        hv_Row1 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_row1");
        if (0 != (int((hv_Row1.TupleLength())==0)))
        {
          continue;
        }
        hv_Col1 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_col1");
        hv_Row2 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_row2");
        hv_Col2 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_col2");
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Bounding box label missing for rectangle1 object detection.");
      }
      //Crop the bounding boxes if necessary.
      if (0 != (HTuple(hv_Preprocessed.TupleNot()).TupleAnd(int(hv_DomainHandling==HTuple("crop_domain")))))
      {
        hv_Row1 = hv_Row1.TupleMax2(hv_DomainRow1-.5);
        hv_Col1 = hv_Col1.TupleMax2(hv_DomainColumn1-.5);
        hv_Row2 = hv_Row2.TupleMin2(hv_DomainRow2+.5);
        hv_Col2 = hv_Col2.TupleMin2(hv_DomainColumn2+.5);
        //Remove empty boxes resulted from the clipping.
        hv_BoxMask = (hv_Row1.TupleLessElem(hv_Row2)).TupleAnd(hv_Col1.TupleLessElem(hv_Col2));
        hv_Row1 = (hv_Row1.TupleSelectMask(hv_BoxMask))-hv_DomainRow1;
        hv_Row2 = (hv_Row2.TupleSelectMask(hv_BoxMask))-hv_DomainRow1;
        hv_Col1 = (hv_Col1.TupleSelectMask(hv_BoxMask))-hv_DomainColumn1;
        hv_Col2 = (hv_Col2.TupleSelectMask(hv_BoxMask))-hv_DomainColumn1;
      }
      //Increase the pre-allocated tuple-length, if necessary.
      if (0 != (int((hv_InstanceCount+(hv_Row1.TupleLength()))>=(hv_Rows1.TupleLength()))))
      {
        hv_Rows1 = hv_Rows1.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Row1.TupleLength()),0.));
        hv_Rows2 = hv_Rows2.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Row1.TupleLength()),0.));
        hv_Cols1 = hv_Cols1.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Row1.TupleLength()),0.));
        hv_Cols2 = hv_Cols2.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Row1.TupleLength()),0.));
      }
      //Collect the scaled bounding box data.
      hv_Row1 = hv_Row1*hv_FactorHeight;
      hv_Row2 = hv_Row2*hv_FactorHeight;
      hv_Col1 = hv_Col1*hv_FactorWidth;
      hv_Col2 = hv_Col2*hv_FactorWidth;
      hv_Rows1[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Row1.TupleLength()))-1,1)] = hv_Row1;
      hv_Rows2[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Row1.TupleLength()))-1,1)] = hv_Row2;
      hv_Cols1[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Row1.TupleLength()))-1,1)] = hv_Col1;
      hv_Cols2[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Row1.TupleLength()))-1,1)] = hv_Col2;
      hv_InstanceCount += hv_Row1.TupleLength();
      //Collect ground truth information for instance type rectangle2.
    }
    else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      //Get the sample bounding boxes.
      try
      {
        hv_Row = hv_DLSampleCurrent.TupleGetDictTuple("bbox_row");
        if (0 != (int((hv_Row.TupleLength())==0)))
        {
          continue;
        }
        hv_Col = hv_DLSampleCurrent.TupleGetDictTuple("bbox_col");
        hv_Length1 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_length1");
        hv_Length2 = hv_DLSampleCurrent.TupleGetDictTuple("bbox_length2");
        hv_Phi = hv_DLSampleCurrent.TupleGetDictTuple("bbox_phi");
        hv_Label = hv_DLSampleCurrent.TupleGetDictTuple("bbox_label_id");
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Bounding box label missing for rectangle2 object detection.");
      }
      //Crop the bounding boxes by removing boxes with centers outside
      //of the domain.
      if (0 != (HTuple(hv_Preprocessed.TupleNot()).TupleAnd(int(hv_DomainHandling==HTuple("crop_domain")))))
      {
        hv_BoxMask = HTuple(HTuple((hv_Row.TupleGreaterEqualElem(hv_DomainRow1)).TupleAnd(hv_Col.TupleGreaterEqualElem(hv_DomainColumn1))).TupleAnd(hv_Row.TupleLessElem(hv_DomainRow2))).TupleAnd(hv_Col.TupleLessElem(hv_DomainColumn2));
        //Store the bounding boxes after the clipping.
        hv_Row = (hv_Row.TupleSelectMask(hv_BoxMask))-hv_DomainRow1;
        hv_Col = (hv_Col.TupleSelectMask(hv_BoxMask))-hv_DomainColumn1;
        hv_Length1 = hv_Length1.TupleSelectMask(hv_BoxMask);
        hv_Length2 = hv_Length2.TupleSelectMask(hv_BoxMask);
        hv_Phi = hv_Phi.TupleSelectMask(hv_BoxMask);
        hv_Label = hv_Label.TupleSelectMask(hv_BoxMask);
      }
      //Turn bounding boxes of classes in ClassIDsNoOrientation to axis-aligned bounding boxes.
      hv_ClassIDsNoOrientationIndices = HTuple();
      {
      HTuple end_val324 = (hv_ClassIDsNoOrientation.TupleLength())-1;
      HTuple step_val324 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val324, step_val324); hv_Index += step_val324)
      {
        hv_ClassIDsNoOrientationIndicesTmp = (hv_Label.TupleEqualElem(HTuple(hv_ClassIDsNoOrientation[hv_Index]))).TupleFind(1);
        if (0 != (int(hv_ClassIDsNoOrientationIndicesTmp!=-1)))
        {
          hv_ClassIDsNoOrientationIndices = hv_ClassIDsNoOrientationIndices.TupleConcat(hv_ClassIDsNoOrientationIndicesTmp);
        }
      }
      }
      if (0 != (int((hv_ClassIDsNoOrientationIndices.TupleLength())>0)))
      {
        //Calculate length1 and length2 using position of corners.
        hv_DirectionLength1Row = -(HTuple(hv_Phi[hv_ClassIDsNoOrientationIndices]).TupleSin());
        hv_DirectionLength1Col = HTuple(hv_Phi[hv_ClassIDsNoOrientationIndices]).TupleCos();
        hv_DirectionLength2Row = -hv_DirectionLength1Col;
        hv_DirectionLength2Col = hv_DirectionLength1Row;
        hv_Corner1Row = (HTuple(hv_Length1[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength1Row)+(HTuple(hv_Length2[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength2Row);
        hv_Corner1Col = (HTuple(hv_Length1[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength1Col)+(HTuple(hv_Length2[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength2Col);
        hv_Corner2Row = (HTuple(hv_Length1[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength1Row)-(HTuple(hv_Length2[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength2Row);
        hv_Corner2Col = (HTuple(hv_Length1[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength1Col)-(HTuple(hv_Length2[hv_ClassIDsNoOrientationIndices])*hv_DirectionLength2Col);
        //
        hv_Phi[hv_ClassIDsNoOrientationIndices] = 0.0;
        hv_Length1[hv_ClassIDsNoOrientationIndices] = (hv_Corner1Col.TupleAbs()).TupleMax2(hv_Corner2Col.TupleAbs());
        hv_Length2[hv_ClassIDsNoOrientationIndices] = (hv_Corner1Row.TupleAbs()).TupleMax2(hv_Corner2Row.TupleAbs());
      }
      //Clip Phi to [-Pi,Pi].
      hv_Pi = HTuple(180).TupleRad();
      hv_PhiMod = hv_Phi.TupleFmod(2*hv_Pi);
      hv_Phi = hv_PhiMod-(((hv_PhiMod.TupleGreaterElem(hv_Pi))*2)*hv_Pi);
      hv_Phi += ((hv_Phi.TupleLessElem(-hv_Pi))*2)*hv_Pi;
      //Get the scaled bounding box data.
      if (0 != (int(hv_FactorHeight==hv_FactorWidth)))
      {
        //In case the factors in both directions are the same, the scaling
        //is simple and Phi stays unchanged.
        hv_Length1 = hv_Length1*hv_FactorHeight;
        hv_Length2 = hv_Length2*hv_FactorWidth;
        hv_Row = hv_Row*hv_FactorHeight;
        hv_Col = hv_Col*hv_FactorWidth;
      }
      else
      {
        //In case the factors in both directions are not the same, the scaling
        //differs for the two directions.
        scale_rectangle2_bbox(hv_Row, hv_Col, hv_Length1, hv_Length2, hv_Phi, hv_FactorHeight, 
            hv_FactorWidth, &hv_Row, &hv_Col, &hv_Length1, &hv_Length2, &hv_Phi);
      }
      //If 'ignore_direction' is set to true, we need to further process the
      //bounding box parameters so that the following two conditions are met:
      //1) -Pi/2 < Phi <= Pi/2
      //2) Length1 > Length2
      if (0 != hv_IgnoreDirection)
      {
        //-Pi/2 < Phi <= Pi/2
        hv_Phi = hv_Phi-((hv_Phi.TupleGreaterElem(hv_Pi/2))*hv_Pi);
        hv_Phi += (hv_Phi.TupleLessEqualElem((-hv_Pi)/2))*hv_Pi;
        //Ignore classes without orientation.
        hv_Phi[hv_ClassIDsNoOrientationIndices] = 0.0;
        hv_IgnoreMask = HTuple(hv_Phi.TupleLength(),1);
        hv_IgnoreMask[hv_ClassIDsNoOrientationIndices] = 0;
        //Length1 > Length2
        hv_SwapMask = (hv_Length2.TupleGreaterElem(hv_Length1))*hv_IgnoreMask;
        hv_SwapMaskInverted = 1-hv_SwapMask;
        hv_Length1Tmp = hv_Length1*hv_SwapMask;
        hv_Length2Tmp = hv_Length2*hv_SwapMask;
        hv_Length1 = (hv_Length1*hv_SwapMaskInverted)+hv_Length2Tmp;
        hv_Length2 = (hv_Length2*hv_SwapMaskInverted)+hv_Length1Tmp;
        hv_PhiMultMask = ((hv_Phi.TupleLessEqualElem(0))-(hv_Phi.TupleGreaterElem(0)))*hv_SwapMask;
        hv_Phi += (hv_PhiMultMask*hv_Pi)/2;
      }
      //Increase the pre-allocated tuple-length, if necessary.
      if (0 != (int((hv_InstanceCount+(hv_Length1.TupleLength()))>=(hv_Lengths1.TupleLength()))))
      {
        hv_Lengths1 = hv_Lengths1.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Length1.TupleLength()),0.));
        hv_Lengths2 = hv_Lengths2.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Length1.TupleLength()),0.));
        hv_Phis = hv_Phis.TupleConcat(HTuple(hv_AllocationBlockLength.TupleMax2(hv_Length1.TupleLength()),0.));
      }
      //Collect the scaled bounding box data.
      hv_Lengths1[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Length1.TupleLength()))-1,1)] = hv_Length1;
      hv_Lengths2[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Length1.TupleLength()))-1,1)] = hv_Length2;
      hv_Phis[HTuple::TupleGenSequence(hv_InstanceCount,(hv_InstanceCount+(hv_Length1.TupleLength()))-1,1)] = hv_Phi;
      hv_InstanceCount += hv_Length1.TupleLength();
    }
    else
    {
      throw HException("Wrong instance type for deep learning object detection.");
    }
    //
    if (0 != hv_ComputeMaxOverlap)
    {
      //Compute the maximum overlap values (class specific and class agnostic).
      GetDictParam(hv_DLSampleCurrent, "key_exists", "bbox_label_id", &hv_KeyExists);
      if (0 != (hv_KeyExists.TupleNot()))
      {
        throw HException("Bounding box label id is missing. Label id is necessary to compute max_overlap.");
      }
      CreateDict(&hv_BoundingBox);
      GetDictParam(hv_DLSampleCurrent, "key_data_type", "bbox_label_id", &hv___Tmp_Ctrl_Type);
      if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
      {
        SetDictObject(hv_DLSampleCurrent.TupleGetDictObject("bbox_label_id"), hv_BoundingBox, 
            "label_id");
      }
      else
      {
        SetDictTuple(hv_BoundingBox, "label_id", hv_DLSampleCurrent.TupleGetDictTuple("bbox_label_id"));
      }
      if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
      {
        SetDictTuple(hv_BoundingBox, "row1", hv_Row1);
        SetDictTuple(hv_BoundingBox, "col1", hv_Col1);
        SetDictTuple(hv_BoundingBox, "row2", hv_Row2);
        SetDictTuple(hv_BoundingBox, "col2", hv_Col2);
      }
      else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
      {
        SetDictTuple(hv_BoundingBox, "row", hv_Row);
        SetDictTuple(hv_BoundingBox, "col", hv_Col);
        SetDictTuple(hv_BoundingBox, "length1", hv_Length1);
        SetDictTuple(hv_BoundingBox, "length2", hv_Length2);
        SetDictTuple(hv_BoundingBox, "phi", hv_Phi);
      }
      compute_max_overlap(hv_BoundingBox, hv_MaxOverlapDict);
    }
  }
  }
  //
  //
  if (0 != hv_ComputeMaxOverlap)
  {
    //Suppress outliers in IoU.
    hv_IdxsWithOverlap = ((hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps_class_agnostic")).TupleGreaterElem(0)).TupleFind(1);
    hv_Percentile = 0.99;
    if (0 != (int(HTuple(hv_IdxsWithOverlap[0])>-1)))
    {
      tuple_percentile(HTuple((hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps_class_agnostic"))[hv_IdxsWithOverlap]), 
          hv_Percentile, &(*hv_MaxOverlapClassAgnostic));
    }
    hv_IdxsWithOverlap = ((hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps")).TupleGreaterElem(0)).TupleFind(1);
    if (0 != (int(HTuple(hv_IdxsWithOverlap[0])>-1)))
    {
      tuple_percentile(HTuple((hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps"))[hv_IdxsWithOverlap]), 
          hv_Percentile, &(*hv_MaxOverlap));
    }
    //
    //Relax the max overlap values.
    hv_RelaxFactor = 1.1;
    (*hv_MaxOverlap) = ((((hv_RelaxFactor*(*hv_MaxOverlap))*100.).TupleRound())/100.).TupleMin2(1.0);
    (*hv_MaxOverlapClassAgnostic) = ((((hv_RelaxFactor*(*hv_MaxOverlapClassAgnostic))*100.).TupleRound())/100.).TupleMin2(1.0);
  }
  //
  //
  //Compute the areas and aspect ratios of all bounding boxes. Also set the
  //output angles in case of rectangle2.
  if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
  {
    //Remove unused pre-allocated memory from box parameter tuples.
    hv_Rows1 = hv_Rows1.TupleSelectRange(0,hv_InstanceCount-1);
    hv_Rows2 = hv_Rows2.TupleSelectRange(0,hv_InstanceCount-1);
    hv_Cols1 = hv_Cols1.TupleSelectRange(0,hv_InstanceCount-1);
    hv_Cols2 = hv_Cols2.TupleSelectRange(0,hv_InstanceCount-1);
    //
    hv_Heights = hv_Rows2-hv_Rows1;
    hv_Widths = hv_Cols2-hv_Cols1;
    (*hv_Areas) = hv_Heights*hv_Widths;
    (*hv_AspectRatios) = hv_Heights/(hv_Widths.TupleReal());
  }
  else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
  {
    //Remove unused pre-allocated memory from box parameter tuples.
    hv_Lengths1 = hv_Lengths1.TupleSelectRange(0,hv_InstanceCount-1);
    hv_Lengths2 = hv_Lengths2.TupleSelectRange(0,hv_InstanceCount-1);
    hv_Phis = hv_Phis.TupleSelectRange(0,hv_InstanceCount-1);
    //
    (*hv_Areas) = (4*hv_Lengths1)*hv_Lengths2;
    (*hv_AspectRatios) = hv_Lengths2/(hv_Lengths1.TupleReal());
    (*hv_Angles) = hv_Phis;
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Perform a k-means clustering on the given parameter values. 
void cluster_dl_detection_param (HTuple hv_Values, HTuple hv_K, HTuple hv_MinRatio, 
    HTuple hv_MinDiff, HTuple hv_IsAngle, HTuple *hv_ClusteredValues)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_KCurrent, hv_MinDelta, hv_MaxIteration;
  HTuple  hv_Points, hv_NumPoints, hv_Repeat, hv_InitCenters;
  HTuple  hv_InitialClusterCenters, hv_Step, hv_Index, hv_ClusterCenters;
  HTuple  hv_MinMembers, hv_ClusterCentersSorted, hv_Diffs;
  HTuple  hv_MinDiffIdx;
  HTupleVector  hvec_PointClusters(1);

  //This procedure performs clustering on the given input data using
  //a simplified 1D k-means algorithm in order to find a small number
  //of values which represent the data well.
  //
  //
  //The number of clusters may be changed, set the initial number given
  //by the input parameter K.
  hv_KCurrent = hv_K;
  //Stop the clustering iteration if the cluster centers do not change
  //more than MaxDelta or after MaxIteration iterations.
  hv_MinDelta = 1e-5;
  hv_MaxIteration = 100;
  //
  //Sort the values in order to generate cluster centers.
  hv_Points = hv_Values.TupleSort();
  hv_NumPoints = hv_Points.TupleLength();
  //
  //Check the inputs.
  if (0 != (int(hv_K<1)))
  {
    throw HException("K has to be at least 1.");
  }
  if (0 != (int(hv_NumPoints<1)))
  {
    throw HException("No data to cluster.");
  }
  //
  hv_Repeat = 1;
  hv_InitCenters = 1;
  //Repeat as long as the number of clusters is reduced during the iteration.
  while (0 != hv_Repeat)
  {
    hv_Repeat = 0;
    //
    //Initialize the cluster centers by taking points from the input data
    //in equal distances.
    if (0 != hv_InitCenters)
    {
      hv_InitialClusterCenters = HTuple();
      if (0 != (int(hv_KCurrent>1)))
      {
        hv_Step = (hv_NumPoints.TupleReal())/(hv_KCurrent-1);
        {
        HTuple end_val37 = hv_KCurrent-2;
        HTuple step_val37 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val37, step_val37); hv_Index += step_val37)
        {
          hv_InitialClusterCenters[hv_Index] = HTuple(hv_Points[(hv_Index*hv_Step).TupleInt()]);
        }
        }
        hv_InitialClusterCenters[hv_KCurrent-1] = HTuple(hv_Points[hv_NumPoints-1]);
      }
      else if (0 != (int(hv_KCurrent==1)))
      {
        hv_InitialClusterCenters = HTuple(hv_Points[hv_NumPoints/2]);
      }
      else
      {
        throw HException("Invalid value for K.");
      }
      hv_InitCenters = 0;
    }
    //
    //Perform k-means clustering with the given initial cluster centers.
    if (0 != (hv_IsAngle.TupleNot()))
    {
      cluster_kmeans_1d(hv_Points, hv_InitialClusterCenters, hv_MaxIteration, hv_MinDelta, 
          &hvec_PointClusters, &hv_ClusterCenters);
    }
    else
    {
      cluster_kmeans_angles(hv_Points, hv_InitialClusterCenters, hv_MaxIteration, 
          hv_MinDelta, &hvec_PointClusters, &hv_ClusterCenters);
    }
    //
    //It is possible that the number of centers is reduced after the clustering,
    //so read it after the process.
    hv_KCurrent = hv_ClusterCenters.TupleLength();
    //
    //Check the clusters for the restrictions.
    //
    //Each cluster should contain at least a ratio (MinRatio) of the total number
    //of data points. If at least one cluster does not fulfill this restriction,
    //reduce the number of clusters and redo the clustering.
    hv_MinMembers = hv_MinRatio*hv_NumPoints;
    {
    HTuple end_val66 = HTuple(hvec_PointClusters.Length())-1;
    HTuple step_val66 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val66, step_val66); hv_Index += step_val66)
    {
      if (0 != (int((hvec_PointClusters[hv_Index].T().TupleLength())<hv_MinMembers)))
      {
        hv_KCurrent = hv_KCurrent-1;
        hv_InitialClusterCenters = hv_ClusterCenters.TupleRemove(hv_Index);
        hv_Repeat = 1;
        break;
      }
    }
    }
    //
    if (0 != hv_Repeat)
    {
      continue;
    }
    //
    //The cluster centers should have a certain distance from each other
    //(specified with MinDiff). If the centers do not fulfill this restriction,
    //also reduce the number of clusters and redo the clustering.
    hv_ClusterCentersSorted = hv_ClusterCenters.TupleSort();
    hv_Diffs = (hv_ClusterCentersSorted.TupleSelectRange(1,(hv_ClusterCentersSorted.TupleLength())-1))-(hv_ClusterCentersSorted.TupleSelectRange(0,(hv_ClusterCentersSorted.TupleLength())-2));
    if (0 != (hv_IsAngle.TupleAnd(int(hv_KCurrent>1))))
    {
      //For angles we additionally calculate the distance between
      //the first and the last cluster center.
      hv_Diffs[hv_Diffs.TupleLength()] = HTuple(hv_ClusterCentersSorted[(hv_ClusterCentersSorted.TupleLength())-1])-HTuple(hv_ClusterCentersSorted[0]);
      if (0 != (int(HTuple(hv_Diffs[(hv_Diffs.TupleLength())-1])>(HTuple(180).TupleRad()))))
      {
        hv_Diffs[(hv_Diffs.TupleLength())-1] = (HTuple(360).TupleRad())-HTuple(hv_Diffs[(hv_Diffs.TupleLength())-1]);
      }
    }
    if (0 != (int(((hv_Diffs.TupleLessElem(hv_MinDiff)).TupleSum())>0)))
    {
      hv_KCurrent = hv_KCurrent-1;
      hv_MinDiffIdx = (hv_Diffs.TupleEqualElem(hv_Diffs.TupleMin())).TupleFind(1);
      hv_InitialClusterCenters = hv_ClusterCentersSorted.TupleRemove(HTuple(hv_MinDiffIdx[0]));
      hv_Repeat = 1;
    }
    //
  }
  //
  (*hv_ClusteredValues) = hv_ClusterCentersSorted;
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Cluster the given data Points with the specified initial cluster centers InitialClusterCenters. 
void cluster_kmeans_1d (HTuple hv_Points, HTuple hv_InitialClusterCenters, HTuple hv_MaxIteration, 
    HTuple hv_MinDelta, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_PointClusters, 
    HTuple *hv_ClusterCenters)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumClusters, hv_NumPoints, hv_Iteration;
  HTuple  hv_CIdx, hv_PIdx, hv_CurrentPoint, hv_Distances;
  HTuple  hv_ClusterIndex, hv_ClusterChanged, hv_ClusterCenterNew;
  HTupleVector  hvec_Clusters(1);

  //This procedure performs clustering on the given
  //1D data points with the specified initial cluster centers.
  //
  (*hv_ClusterCenters) = hv_InitialClusterCenters;
  hv_NumClusters = (*hv_ClusterCenters).TupleLength();
  hv_NumPoints = hv_Points.TupleLength();
  //
  {
  HTuple end_val7 = hv_MaxIteration-1;
  HTuple step_val7 = 1;
  for (hv_Iteration=0; hv_Iteration.Continue(end_val7, step_val7); hv_Iteration += step_val7)
  {
    //Initialize new cluster vector to store clustered points.
    {
    HTuple end_val9 = hv_NumClusters-1;
    HTuple step_val9 = 1;
    for (hv_CIdx=0; hv_CIdx.Continue(end_val9, step_val9); hv_CIdx += step_val9)
    {
      hvec_Clusters[hv_CIdx] = HTupleVector(HTuple());
    }
    }
    //Assign each point to the closest cluster center.
    {
    HTuple end_val13 = hv_NumPoints-1;
    HTuple step_val13 = 1;
    for (hv_PIdx=0; hv_PIdx.Continue(end_val13, step_val13); hv_PIdx += step_val13)
    {
      hv_CurrentPoint = HTuple(hv_Points[hv_PIdx]);
      hv_Distances = ((*hv_ClusterCenters)-hv_CurrentPoint).TupleAbs();
      hv_ClusterIndex = hv_Distances.TupleFindFirst(hv_Distances.TupleMin());
      hvec_Clusters[hv_ClusterIndex] = HTupleVector(hvec_Clusters[hv_ClusterIndex].T().TupleConcat(hv_CurrentPoint));
    }
    }
    //Check that all clusters have at least one data point.
    //If not -> remove the cluster and the corresponding center.
    for (hv_CIdx=hv_NumClusters-1; hv_CIdx>=0; hv_CIdx+=-1)
    {
      if (0 != (int((hvec_Clusters[hv_CIdx].T().TupleLength())==0)))
      {
        hvec_Clusters.Remove(hv_CIdx);
        (*hv_ClusterCenters) = (*hv_ClusterCenters).TupleRemove(hv_CIdx);
        hv_NumClusters = hv_NumClusters-1;
      }
    }
    //Update cluster centers based on point clusters.
    hv_ClusterChanged = 0;
    {
    HTuple end_val30 = hv_NumClusters-1;
    HTuple step_val30 = 1;
    for (hv_CIdx=0; hv_CIdx.Continue(end_val30, step_val30); hv_CIdx += step_val30)
    {
      hv_ClusterCenterNew = hvec_Clusters[hv_CIdx].T().TupleMean();
      if (0 != (int(((hv_ClusterCenterNew-HTuple((*hv_ClusterCenters)[hv_CIdx])).TupleAbs())>hv_MinDelta)))
      {
        (*hv_ClusterCenters)[hv_CIdx] = hv_ClusterCenterNew;
        hv_ClusterChanged = 1;
      }
    }
    }
    //If clusters did not change, exit early.
    if (0 != (hv_ClusterChanged.TupleNot()))
    {
      break;
    }
  }
  }
  //
  (*hvec_PointClusters) = hvec_Clusters;
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Cluster angles with a simplified kmeans algorithm. 
void cluster_kmeans_angles (HTuple hv_Points, HTuple hv_InitialClusterCenters, HTuple hv_MaxIteration, 
    HTuple hv_MinDelta, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_PointClusters, 
    HTuple *hv_ClusterCenters)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumClusters, hv_NumPoints, hv_Iteration;
  HTuple  hv_CIdx, hv_PIdx, hv_CurrentPoint, hv_Distances;
  HTuple  hv_IdxsLarge, hv_ClusterIndex, hv_ClusterChanged;
  HTuple  hv_MinPhi, hv_Phi, hv_PhiMod, hv_ClusterCenterNew;
  HTupleVector  hvec_Clusters(1);

  //This procedure performs clustering on the given
  //angle data points with the specified initial cluster centers.
  //In comparison to cluster_kmeans_1d this procedure takes special
  //care of the jump discontinuity of angles at rad(180) when
  //calculating distances and cluster centers.
  //
  (*hv_ClusterCenters) = hv_InitialClusterCenters;
  hv_NumClusters = (*hv_ClusterCenters).TupleLength();
  hv_NumPoints = hv_Points.TupleLength();
  //
  {
  HTuple end_val10 = hv_MaxIteration-1;
  HTuple step_val10 = 1;
  for (hv_Iteration=0; hv_Iteration.Continue(end_val10, step_val10); hv_Iteration += step_val10)
  {
    //Initialize new cluster vector to store clustered points.
    {
    HTuple end_val12 = hv_NumClusters-1;
    HTuple step_val12 = 1;
    for (hv_CIdx=0; hv_CIdx.Continue(end_val12, step_val12); hv_CIdx += step_val12)
    {
      hvec_Clusters[hv_CIdx] = HTupleVector(HTuple());
    }
    }
    //Assign each point to the closest cluster center.
    {
    HTuple end_val16 = hv_NumPoints-1;
    HTuple step_val16 = 1;
    for (hv_PIdx=0; hv_PIdx.Continue(end_val16, step_val16); hv_PIdx += step_val16)
    {
      hv_CurrentPoint = HTuple(hv_Points[hv_PIdx]);
      hv_Distances = ((*hv_ClusterCenters)-hv_CurrentPoint).TupleAbs();
      //Check that the intermediate angle is taken as distance.
      hv_IdxsLarge = (hv_Distances.TupleGreaterElem(HTuple(180).TupleRad())).TupleFind(1);
      if (0 != (int(hv_IdxsLarge!=-1)))
      {
        hv_Distances[hv_IdxsLarge] = (HTuple(360).TupleRad())-HTuple(hv_Distances[hv_IdxsLarge]);
      }
      hv_ClusterIndex = hv_Distances.TupleFindFirst(hv_Distances.TupleMin());
      hvec_Clusters[hv_ClusterIndex] = HTupleVector(hvec_Clusters[hv_ClusterIndex].T().TupleConcat(hv_CurrentPoint));
    }
    }
    //Check that all clusters have at least one data point.
    //If not -> remove the cluster and the corresponding center.
    for (hv_CIdx=hv_NumClusters-1; hv_CIdx>=0; hv_CIdx+=-1)
    {
      if (0 != (int((hvec_Clusters[hv_CIdx].T().TupleLength())==0)))
      {
        hvec_Clusters.Remove(hv_CIdx);
        (*hv_ClusterCenters) = (*hv_ClusterCenters).TupleRemove(hv_CIdx);
        hv_NumClusters = hv_NumClusters-1;
      }
    }
    //Update cluster centers based on point clusters.
    hv_ClusterChanged = 0;
    {
    HTuple end_val38 = hv_NumClusters-1;
    HTuple step_val38 = 1;
    for (hv_CIdx=0; hv_CIdx.Continue(end_val38, step_val38); hv_CIdx += step_val38)
    {
      hv_MinPhi = hvec_Clusters[hv_CIdx].T().TupleMin();
      hv_Phi = hvec_Clusters[hv_CIdx].T();
      //In case some ClusterPoints are negative and others are not,
      //we shift the values for the mean calculation. This avoids
      //problems with the jump discontinuity at rad(180).
      if (0 != (int(hv_MinPhi<0.0)))
      {
        //Shift and clip ClusterPoints to (-Pi, Pi].
        hv_PhiMod = hv_Phi-hv_MinPhi;
        hv_Phi = hv_PhiMod-((hv_PhiMod.TupleGreaterElem(HTuple(180).TupleRad()))*(HTuple(360).TupleRad()));
      }
      hv_ClusterCenterNew = (hv_Phi.TupleMean())+((hv_MinPhi.TupleLessElem(0.0))*hv_MinPhi);
      //Make sure the new cluster center is in (-Pi, Pi]
      hv_ClusterCenterNew += (hv_ClusterCenterNew.TupleLessEqualElem(HTuple(-180).TupleRad()))*(HTuple(360).TupleRad());
      hv_ClusterCenterNew = hv_ClusterCenterNew-((hv_ClusterCenterNew.TupleGreaterElem(HTuple(180).TupleRad()))*(HTuple(360).TupleRad()));
      if (0 != (HTuple(int(((hv_ClusterCenterNew-HTuple((*hv_ClusterCenters)[hv_CIdx])).TupleAbs())>hv_MinDelta)).TupleAnd(int(((hv_ClusterCenterNew-HTuple((*hv_ClusterCenters)[hv_CIdx])).TupleAbs())<((HTuple(360).TupleRad())-hv_MinDelta)))))
      {
        (*hv_ClusterCenters)[hv_CIdx] = hv_ClusterCenterNew;
        hv_ClusterChanged = 1;
      }
    }
    }
    //If clusters did not change, exit early.
    if (0 != (hv_ClusterChanged.TupleNot()))
    {
      break;
    }
  }
  }
  //
  (*hvec_PointClusters) = hvec_Clusters;
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_iou_rect1 (HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, HTuple hv_Col2, 
    HTuple *hv_IoU)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumInstances, hv_Area, hv_InstanceIdx;
  HTuple  hv_HeightIntersect, hv_WidthIntersect, hv_ValidIdxs;
  HTuple  hv_Intersection, hv_Union;

  //Compute the IoU of axis-aligned bounding boxes.
  //
  hv_NumInstances = hv_Row1.TupleLength();
  (*hv_IoU) = HTuple(hv_NumInstances*hv_NumInstances,0.0);
  //
  //Compute areas of instances.
  hv_Area = (hv_Row2-hv_Row1)*(hv_Col2-hv_Col1);
  //Compute IoUs.
  {
  HTuple end_val8 = hv_NumInstances-1;
  HTuple step_val8 = 1;
  for (hv_InstanceIdx=0; hv_InstanceIdx.Continue(end_val8, step_val8); hv_InstanceIdx += step_val8)
  {
    hv_HeightIntersect = (HTuple(hv_Row2[hv_InstanceIdx]).TupleMin2(hv_Row2))-(HTuple(hv_Row1[hv_InstanceIdx]).TupleMax2(hv_Row1));
    hv_WidthIntersect = (HTuple(hv_Col2[hv_InstanceIdx]).TupleMin2(hv_Col2))-(HTuple(hv_Col1[hv_InstanceIdx]).TupleMax2(hv_Col1));
    hv_ValidIdxs = HTuple((hv_HeightIntersect.TupleGreaterElem(0)).TupleAnd(hv_WidthIntersect.TupleGreaterElem(0))).TupleFind(1);
    if (0 != (int(hv_ValidIdxs>-1)))
    {
      hv_Intersection = HTuple(hv_HeightIntersect[hv_ValidIdxs])*HTuple(hv_WidthIntersect[hv_ValidIdxs]);
      hv_Union = (HTuple(hv_Area[hv_InstanceIdx])+HTuple(hv_Area[hv_ValidIdxs]))-hv_Intersection;
      (*hv_IoU)[(hv_InstanceIdx*hv_NumInstances)+hv_ValidIdxs] = (hv_Intersection.TupleReal())/hv_Union;
    }
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_iou_rect2 (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, HTuple hv_Length2, 
    HTuple hv_Phi, HTuple *hv_IoU)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumInstances, hv_Area, hv_InstanceIdx;
  HTuple  hv_ValidIdxs, hv_Intersection, hv_Union;

  //Compute the IoU of rotated bounding boxes.
  //
  hv_NumInstances = hv_Row.TupleLength();
  (*hv_IoU) = HTuple(hv_NumInstances*hv_NumInstances,0.0);
  //Compute Areas.
  hv_Area = (4.0*hv_Length1)*hv_Length2;
  //
  //Compute IoUs.
  {
  HTuple end_val8 = hv_NumInstances-1;
  HTuple step_val8 = 1;
  for (hv_InstanceIdx=0; hv_InstanceIdx.Continue(end_val8, step_val8); hv_InstanceIdx += step_val8)
  {
    hv_ValidIdxs = (hv_Area.TupleGreaterElem(0)).TupleFind(1);
    if (0 != (int(hv_ValidIdxs>-1)))
    {
      AreaIntersectionRectangle2(HTuple(hv_Row[hv_InstanceIdx]), HTuple(hv_Col[hv_InstanceIdx]), 
          HTuple(hv_Phi[hv_InstanceIdx]), HTuple(hv_Length1[hv_InstanceIdx]), HTuple(hv_Length2[hv_InstanceIdx]), 
          HTuple(hv_Row[hv_ValidIdxs]), HTuple(hv_Col[hv_ValidIdxs]), HTuple(hv_Phi[hv_ValidIdxs]), 
          HTuple(hv_Length1[hv_ValidIdxs]), HTuple(hv_Length2[hv_ValidIdxs]), &hv_Intersection);
      hv_Union = (HTuple(hv_Area[hv_InstanceIdx])+HTuple(hv_Area[hv_ValidIdxs]))-hv_Intersection;
      (*hv_IoU)[(hv_InstanceIdx*hv_NumInstances)+hv_ValidIdxs] = (hv_Intersection.TupleReal())/hv_Union;
    }
  }
  }
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
void compute_max_overlap (HTuple hv_BoundingBox, HTuple hv_MaxOverlapDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MaxOverlaps, hv_MaxOverlapsClassAgnostic;
  HTuple  hv_MaxOverlap, hv_MaxOverlapClassAgnostic, hv_NumMaxOverlaps;
  HTuple  hv_NumMaxOverlapsClassAgnostic, hv_KeysExist, hv_InstanceType;
  HTuple  hv_LabelId, hv_NumInstances, hv_IoU, hv_IoUCleaned;
  HTuple  hv_UniqueLabels, hv_L, hv_Label, hv_IdxsLabel, hv_IoUIdxsLabel;
  HTuple  hv_Idx;

  //Compute the IoUs of instances in the dictionary BoundingBox
  //and collect them to compute the max overlap values.
  //
  //Get the relevant information from the dictionary MaxOverlapDict.
  hv_MaxOverlaps = hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps");
  hv_MaxOverlapsClassAgnostic = hv_MaxOverlapDict.TupleGetDictTuple("max_overlaps_class_agnostic");
  hv_MaxOverlap = hv_MaxOverlapDict.TupleGetDictTuple("max_overlap");
  hv_MaxOverlapClassAgnostic = hv_MaxOverlapDict.TupleGetDictTuple("max_overlap_class_agnostic");
  hv_NumMaxOverlaps = hv_MaxOverlapDict.TupleGetDictTuple("num_max_overlaps");
  hv_NumMaxOverlapsClassAgnostic = hv_MaxOverlapDict.TupleGetDictTuple("num_max_overlaps_class_agnostic");
  //
  GetDictParam(hv_BoundingBox, "key_exists", (HTuple("row1").Append("row")), &hv_KeysExist);
  if (0 != (HTuple(hv_KeysExist[0])))
  {
    hv_InstanceType = "rectangle1";
  }
  else if (0 != (HTuple(hv_KeysExist[1])))
  {
    hv_InstanceType = "rectangle2";
  }
  //
  hv_LabelId = hv_BoundingBox.TupleGetDictTuple("label_id");
  hv_NumInstances = hv_LabelId.TupleLength();
  //
  if (0 != (int(hv_NumInstances>0)))
  {
    //
    //Compute IoUs.
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      compute_iou_rect1(hv_BoundingBox.TupleGetDictTuple("row1"), hv_BoundingBox.TupleGetDictTuple("col1"), 
          hv_BoundingBox.TupleGetDictTuple("row2"), hv_BoundingBox.TupleGetDictTuple("col2"), 
          &hv_IoU);
    }
    else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      compute_iou_rect2(hv_BoundingBox.TupleGetDictTuple("row"), hv_BoundingBox.TupleGetDictTuple("col"), 
          hv_BoundingBox.TupleGetDictTuple("length1"), hv_BoundingBox.TupleGetDictTuple("length2"), 
          hv_BoundingBox.TupleGetDictTuple("phi"), &hv_IoU);
    }
    //
    //Delete the diagonal of the IoU-matrix.
    TupleRemove(hv_IoU, HTuple::TupleGenSequence(0,hv_IoU.TupleLength(),hv_NumInstances+1), 
        &hv_IoUCleaned);
    //
    if (0 != (hv_IoUCleaned.TupleLength()))
    {
      //Max overlap class agnostic.
      hv_MaxOverlapClassAgnostic = hv_MaxOverlapClassAgnostic.TupleMax2(hv_IoUCleaned.TupleMax());
      //Collect all overlaps to suppress outliers.
      if (0 != (int((hv_NumMaxOverlapsClassAgnostic+(hv_IoUCleaned.TupleLength()))>(hv_MaxOverlapsClassAgnostic.TupleLength()))))
      {
        hv_MaxOverlapsClassAgnostic = hv_MaxOverlapsClassAgnostic.TupleConcat(HTuple(1000,-1));
      }
      hv_MaxOverlapsClassAgnostic[HTuple::TupleGenSequence(hv_NumMaxOverlapsClassAgnostic,((hv_IoUCleaned.TupleLength())+hv_NumMaxOverlapsClassAgnostic)-1,1)] = hv_IoUCleaned;
      hv_NumMaxOverlapsClassAgnostic += hv_IoUCleaned.TupleLength();
    }
    //
    //Max overlap class specific.
    hv_UniqueLabels = (hv_LabelId.TupleSort()).TupleUniq();
    {
    HTuple end_val46 = (hv_UniqueLabels.TupleLength())-1;
    HTuple step_val46 = 1;
    for (hv_L=0; hv_L.Continue(end_val46, step_val46); hv_L += step_val46)
    {
      hv_Label = HTuple(hv_UniqueLabels[hv_L]);
      hv_IdxsLabel = hv_LabelId.TupleFind(hv_Label);
      //Note: IoU is symmetric --> we only look at the upper-half of the IoU-matrix.
      hv_IoUIdxsLabel = HTuple();
      {
      HTuple end_val51 = (hv_IdxsLabel.TupleLength())-2;
      HTuple step_val51 = 1;
      for (hv_Idx=0; hv_Idx.Continue(end_val51, step_val51); hv_Idx += step_val51)
      {
        hv_IoUIdxsLabel = hv_IoUIdxsLabel.TupleConcat((HTuple(hv_IdxsLabel[hv_Idx])*hv_NumInstances)+(hv_IdxsLabel.TupleSelectRange(hv_Idx+1,(hv_IdxsLabel.TupleLength())-1)));
      }
      }
      if (0 != (int((hv_IoUIdxsLabel.TupleLength())>0)))
      {
        hv_MaxOverlap = hv_MaxOverlap.TupleMax2(HTuple(hv_IoU[hv_IoUIdxsLabel]).TupleMax());
        //Collect all overlaps to suppress outliers.
        if (0 != (int((hv_NumMaxOverlaps+(hv_IoU.TupleLength()))>(hv_MaxOverlaps.TupleLength()))))
        {
          hv_MaxOverlaps = hv_MaxOverlaps.TupleConcat(HTuple(1000,-1));
        }
        hv_MaxOverlaps[HTuple::TupleGenSequence(hv_NumMaxOverlaps,((HTuple(hv_IoU[hv_IoUIdxsLabel]).TupleLength())+hv_NumMaxOverlaps)-1,1)] = HTuple(hv_IoU[hv_IoUIdxsLabel]);
        hv_NumMaxOverlaps += HTuple(hv_IoU[hv_IoUIdxsLabel]).TupleLength();
      }
    }
    }
    //
    //Set the relevant information to the dictionary MaxOverlapDict.
    SetDictTuple(hv_MaxOverlapDict, "max_overlaps", hv_MaxOverlaps);
    SetDictTuple(hv_MaxOverlapDict, "max_overlaps_class_agnostic", hv_MaxOverlapsClassAgnostic);
    SetDictTuple(hv_MaxOverlapDict, "max_overlap", hv_MaxOverlap);
    SetDictTuple(hv_MaxOverlapDict, "max_overlap_class_agnostic", hv_MaxOverlapClassAgnostic);
    SetDictTuple(hv_MaxOverlapDict, "num_max_overlaps", hv_NumMaxOverlaps);
    SetDictTuple(hv_MaxOverlapDict, "num_max_overlaps_class_agnostic", hv_NumMaxOverlapsClassAgnostic);
    //
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Analyze the provided DLDataset for object detection to find model parameters relevant for anchor generation. 
void determine_dl_model_detection_param (HTuple hv_DLDataset, HTuple hv_ImageWidthTarget, 
    HTuple hv_ImageHeightTarget, HTuple hv_GenParam, HTuple *hv_DLDetectionModelParam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinLevel, hv_MaxLevel, hv_AnchorNumSubscales;
  HTuple  hv_DatasetSplit, hv_DisplayHistogram, hv_IgnoreDirection;
  HTuple  hv_ClassIDsNoOrientation, hv_MaxNumSamples, hv_ComputeMaxOverlap;
  HTuple  hv_AvailableGenParams, hv_GenParamName, hv_GenParamIndex;
  HTuple  hv_DatasetKeys, hv_KeyIndex, hv_DatasetKeyExists;
  HTuple  hv_Rect1Keys, hv_Rect2Keys, hv_Rect1KeysExist, hv_Rect2KeysExist;
  HTuple  hv_InstanceType, hv_ClassIdsExist, hv_ClassNamesExist;
  HTuple  hv_Areas, hv_AspectRatios, hv_Angles, hv_MaxOverlap;
  HTuple  hv_MaxOverlapClassAgnostic, hv_AreasReduced, hv_AspectRatiosReduced;
  HTuple  hv_AnglesReduced, hv_MinLevelToUse, hv_MaxLevelToUse;
  HTuple  hv_AnchorNumSubscalesToUse, hv_ErrorMessage, hv_MinRatio;
  HTuple  hv_MinDiff, hv_K, hv_ClusteredAspectRatios, hv_ClusteredAngles;
  HTuple  hv_MinAngleIdx, hv_WindowBGColor, hv_SplitText;
  HTuple  hv_WindowHandle, hv_WindowHandle2, hv_WindowHandle3;
  HTuple  hv___Tmp_Ctrl_Dict_Init_0, hv___Tmp_Ctrl_Dict_Init_1;
  HTuple  hv___Tmp_Ctrl_Dict_Init_2, hv___Tmp_Ctrl_Dict_Init_3;
  HTuple  hv___Tmp_Ctrl_Dict_Init_4, hv___Tmp_Ctrl_Dict_Init_5;
  HTuple  hv___Tmp_Ctrl_Type;

  //This procedure analyzes the input DLDataset for object detection
  //in order to find good values for parameters which control the
  //generation of anchor bounding boxes.
  //
  //
  //Set default values for generic parameters.
  hv_MinLevel = 2;
  hv_MaxLevel = 6;
  hv_AnchorNumSubscales = 3;
  hv_DatasetSplit = "train";
  hv_DisplayHistogram = 0;
  hv_IgnoreDirection = 0;
  hv_ClassIDsNoOrientation = HTuple();
  hv_MaxNumSamples = 1500;
  hv_ComputeMaxOverlap = 1;
  //
  hv_AvailableGenParams.Clear();
  hv_AvailableGenParams[0] = "min_level";
  hv_AvailableGenParams[1] = "max_level";
  hv_AvailableGenParams[2] = "anchor_num_subscales";
  hv_AvailableGenParams[3] = "display_histogram";
  hv_AvailableGenParams[4] = "split";
  hv_AvailableGenParams[5] = "raw_width";
  hv_AvailableGenParams[6] = "raw_height";
  hv_AvailableGenParams[7] = "domain_handling";
  hv_AvailableGenParams[8] = "preprocessed_path";
  hv_AvailableGenParams[9] = "class_ids_no_orientation";
  hv_AvailableGenParams[10] = "ignore_direction";
  hv_AvailableGenParams[11] = "max_num_samples";
  hv_AvailableGenParams[12] = "compute_max_overlap";
  hv_AvailableGenParams[13] = "image_size_constant";
  //Read generic parameters and check the provided values.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamName);
    {
    HTuple end_val20 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val20 = 1;
    for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val20, step_val20); hv_GenParamIndex += step_val20)
    {
      if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("min_level"))))
      {
        hv_MinLevel = hv_GenParam.TupleGetDictTuple("min_level");
        if (0 != ((hv_MinLevel.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (int(hv_MinLevel<2)))
        {
          throw HException(("Invalid value for parameter 'min_level': "+hv_MinLevel)+". The minimum value is 2.");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("max_level"))))
      {
        hv_MaxLevel = hv_GenParam.TupleGetDictTuple("max_level");
        if (0 != ((hv_MaxLevel.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (int(hv_MaxLevel<2)))
        {
          throw HException(("Invalid value for parameter 'max_level': "+hv_MaxLevel)+". The minimum value is 2.");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("anchor_num_subscales"))))
      {
        hv_AnchorNumSubscales = hv_GenParam.TupleGetDictTuple("anchor_num_subscales");
        if (0 != ((hv_AnchorNumSubscales.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (int(hv_AnchorNumSubscales<1)))
        {
          throw HException(("Invalid value for parameter 'anchor_num_subscales': "+hv_AnchorNumSubscales)+". The minimum value is 1.");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("display_histogram"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_0);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
        hv_DisplayHistogram = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1)).TupleTestEqualDictItem("display_histogram","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0)).TupleTestEqualDictItem("display_histogram","comp"));
        hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_0 = HTuple::TupleConstant("HNULL");
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("split"))))
      {
        hv_DatasetSplit = hv_GenParam.TupleGetDictTuple("split");
        if (0 != ((hv_DatasetSplit.TupleIsString()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type string");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("class_ids_no_orientation"))))
      {
        hv_ClassIDsNoOrientation = hv_GenParam.TupleGetDictTuple("class_ids_no_orientation");
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("ignore_direction"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_2);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_3);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", "true");
        hv_IgnoreDirection = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3)).TupleTestEqualDictItem("ignore_direction","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2)).TupleTestEqualDictItem("ignore_direction","comp"));
        hv___Tmp_Ctrl_Dict_Init_3 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_2 = HTuple::TupleConstant("HNULL");
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("max_num_samples"))))
      {
        hv_MaxNumSamples = hv_GenParam.TupleGetDictTuple("max_num_samples");
        if (0 != ((hv_MaxNumSamples.TupleIsInt()).TupleNot()))
        {
          throw HException(HTuple(hv_GenParamName[hv_GenParamIndex])+" should be of type int");
        }
        if (0 != (HTuple(int(hv_MaxNumSamples<1)).TupleAnd(int(hv_MaxNumSamples!=-1))))
        {
          throw HException(("Invalid value for parameter 'max_num_samples': "+hv_MaxNumSamples)+". Only -1 or values greater or equal to 1 are allowed.");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("compute_max_overlap"))))
      {
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_4);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_4, "comp", 1);
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_5);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_5, "comp", "true");
        hv_ComputeMaxOverlap = ((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_5)).TupleTestEqualDictItem("compute_max_overlap","comp")).TupleOr((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_4)).TupleTestEqualDictItem("compute_max_overlap","comp"));
        hv___Tmp_Ctrl_Dict_Init_5 = HTuple::TupleConstant("HNULL");
        hv___Tmp_Ctrl_Dict_Init_4 = HTuple::TupleConstant("HNULL");
      }
      else if (0 != (int((hv_AvailableGenParams.TupleFind(HTuple(hv_GenParamName[hv_GenParamIndex])))==-1)))
      {
        throw HException(("Unsupported generic parameter: '"+HTuple(hv_GenParamName[hv_GenParamIndex]))+"'");
      }
    }
    }
  }
  else
  {
    CreateDict(&hv_GenParam);
  }
  //
  //Check that all necessary keys (for this procedure) exist in the input dataset.
  hv_DatasetKeys.Clear();
  hv_DatasetKeys[0] = "image_dir";
  hv_DatasetKeys[1] = "samples";
  {
  HTuple end_val94 = (hv_DatasetKeys.TupleLength())-1;
  HTuple step_val94 = 1;
  for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val94, step_val94); hv_KeyIndex += step_val94)
  {
    GetDictParam(hv_DLDataset, "key_exists", HTuple(hv_DatasetKeys[hv_KeyIndex]), 
        &hv_DatasetKeyExists);
    if (0 != (hv_DatasetKeyExists.TupleNot()))
    {
      throw HException(("Missing key in DLDataset: '"+HTuple(hv_DatasetKeys[hv_KeyIndex]))+"'.");
    }
  }
  }
  //Check that MaxLevel >= MinLevel
  if (0 != (int(hv_MaxLevel<hv_MinLevel)))
  {
    throw HException("Value for parameter 'max_level' should not be smaller than 'min_level'.");
  }
  //
  //Get instance type of the dataset.
  //
  //Keys defining bounding boxes of instance type rectangle1 and rectangle2, respectively.
  hv_Rect1Keys.Clear();
  hv_Rect1Keys[0] = "bbox_row1";
  hv_Rect1Keys[1] = "bbox_col1";
  hv_Rect1Keys[2] = "bbox_row2";
  hv_Rect1Keys[3] = "bbox_col2";
  hv_Rect2Keys.Clear();
  hv_Rect2Keys[0] = "bbox_row";
  hv_Rect2Keys[1] = "bbox_col";
  hv_Rect2Keys[2] = "bbox_length1";
  hv_Rect2Keys[3] = "bbox_length2";
  hv_Rect2Keys[4] = "bbox_phi";
  //
  GetDictParam(HTuple((hv_DLDataset.TupleGetDictTuple("samples"))[0]), "key_exists", 
      hv_Rect1Keys, &hv_Rect1KeysExist);
  GetDictParam(HTuple((hv_DLDataset.TupleGetDictTuple("samples"))[0]), "key_exists", 
      hv_Rect2Keys, &hv_Rect2KeysExist);
  if (0 != (int((hv_Rect1KeysExist.TupleSum())==(hv_Rect1Keys.TupleLength()))))
  {
    hv_InstanceType = "rectangle1";
  }
  else if (0 != (int((hv_Rect2KeysExist.TupleSum())==(hv_Rect2Keys.TupleLength()))))
  {
    hv_InstanceType = "rectangle2";
  }
  else
  {
    throw HException("Please provide the data labeled for an object detection model of either instance type rectangle1 or rectangle2.");
  }
  //
  //Create output parameter dictionary.
  CreateDict(&(*hv_DLDetectionModelParam));
  //First we can set the class ids to the output dictionary.
  GetDictParam(hv_DLDataset, "key_exists", "class_ids", &hv_ClassIdsExist);
  if (0 != hv_ClassIdsExist)
  {
    GetDictParam(hv_DLDataset, "key_data_type", "class_ids", &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject(hv_DLDataset.TupleGetDictObject("class_ids"), (*hv_DLDetectionModelParam), 
          "class_ids");
    }
    else
    {
      SetDictTuple((*hv_DLDetectionModelParam), "class_ids", hv_DLDataset.TupleGetDictTuple("class_ids"));
    }
  }
  GetDictParam(hv_DLDataset, "key_exists", "class_names", &hv_ClassNamesExist);
  if (0 != hv_ClassNamesExist)
  {
    GetDictParam(hv_DLDataset, "key_data_type", "class_names", &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject(hv_DLDataset.TupleGetDictObject("class_names"), (*hv_DLDetectionModelParam), 
          "class_names");
    }
    else
    {
      SetDictTuple((*hv_DLDetectionModelParam), "class_names", hv_DLDataset.TupleGetDictTuple("class_names"));
    }
  }
  //Then, we also already know the instance type.
  SetDictTuple((*hv_DLDetectionModelParam), "instance_type", hv_InstanceType);
  //In case of rectangle2 we can add the parameter 'ignore_direction'.
  if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
  {
    if (0 != hv_IgnoreDirection)
    {
      SetDictTuple((*hv_DLDetectionModelParam), "ignore_direction", "true");
    }
    else
    {
      SetDictTuple((*hv_DLDetectionModelParam), "ignore_direction", "false");
    }
  }
  //
  //Create relevant information collections from the dataset.
  analyze_dl_dataset_detection(hv_DLDataset, hv_InstanceType, hv_ImageWidthTarget, 
      hv_ImageHeightTarget, hv_GenParam, &hv_Areas, &hv_AspectRatios, &hv_Angles, 
      &hv_MaxOverlap, &hv_MaxOverlapClassAgnostic);
  //Set the image width and target to the output dictionary.
  if (0 != (HTuple(int(hv_ImageWidthTarget==HTuple())).TupleOr(int(hv_ImageHeightTarget==HTuple()))))
  {
    hv_ImageWidthTarget = hv_GenParam.TupleGetDictTuple("image_width_target");
    hv_ImageHeightTarget = hv_GenParam.TupleGetDictTuple("image_height_target");
    RemoveDictKey(hv_GenParam, "image_width_target");
    RemoveDictKey(hv_GenParam, "image_height_target");
  }
  SetDictTuple((*hv_DLDetectionModelParam), "image_width", hv_ImageWidthTarget);
  SetDictTuple((*hv_DLDetectionModelParam), "image_height", hv_ImageHeightTarget);
  //
  if (0 != hv_ComputeMaxOverlap)
  {
    SetDictTuple((*hv_DLDetectionModelParam), "max_overlap", hv_MaxOverlap);
    SetDictTuple((*hv_DLDetectionModelParam), "max_overlap_class_agnostic", hv_MaxOverlapClassAgnostic);
  }
  //
  //Remove outliers in the data which could potentially have a big impact on the results
  //of this procedure. If you wish not to do so, comment out the following procedure calls
  //and set the variables AreasReduce, AspectRatiosReduced and AnglesReduced accordingly.
  remove_dl_data_outliers(hv_Areas, &hv_AreasReduced);
  remove_dl_data_outliers(hv_AspectRatios, &hv_AspectRatiosReduced);
  remove_dl_data_outliers(hv_Angles, &hv_AnglesReduced);
  //
  //Select min_level, max_level and anchor_num_subscales based on the retrieved ground truth
  //bounding box areas.
  select_dl_detection_levels(hv_AreasReduced, hv_MinLevel, hv_MaxLevel, hv_AnchorNumSubscales, 
      &hv_MinLevelToUse, &hv_MaxLevelToUse, &hv_AnchorNumSubscalesToUse);
  SetDictTuple((*hv_DLDetectionModelParam), "min_level", hv_MinLevelToUse);
  SetDictTuple((*hv_DLDetectionModelParam), "max_level", hv_MaxLevelToUse);
  SetDictTuple((*hv_DLDetectionModelParam), "anchor_num_subscales", hv_AnchorNumSubscalesToUse);
  //
  //Check if the given image dimensions and computed levels are compatible.
  if (0 != (HTuple(int((hv_ImageWidthTarget.TupleFmod(HTuple(2).TuplePow(hv_MaxLevelToUse)))>0)).TupleOr(int((hv_ImageHeightTarget.TupleFmod(HTuple(2).TuplePow(hv_MaxLevelToUse)))>0))))
  {
    hv_ErrorMessage = ((((("The target image dimensions "+hv_ImageWidthTarget)+"x")+hv_ImageHeightTarget)+" are not compatible with the computed maximum level ")+hv_MaxLevelToUse)+".\nThe image width and height must be a multiple of 2 to the power of the maximum level.";
    throw HException(hv_ErrorMessage);
  }
  //
  //Determine values for anchor aspect ratios and angles using k-means clustering.
  //
  //Minimum ratio of members each cluster should at least have.
  hv_MinRatio = 0.01;
  //Minimum distance between the cluster centers.
  hv_MinDiff = 0.1;
  //Number of centers to start k-means with. For aspect ratios, set K to 4.
  hv_K = 4;
  //Perform clustering of collected aspect ratios.
  cluster_dl_detection_param(hv_AspectRatiosReduced, hv_K, hv_MinRatio, hv_MinDiff, 
      0, &hv_ClusteredAspectRatios);
  SetDictTuple((*hv_DLDetectionModelParam), "anchor_aspect_ratios", hv_ClusteredAspectRatios);
  //
  //For rectangle2, also perform clustering on the angles.
  if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
  {
    //Since the variance for the angles is usually greater,
    //adapt K and MinDiff accordingly.
    hv_K = 8;
    hv_MinDiff = HTuple(45).TupleRad();
    //If 'ignore_direction' is set to true, we multiply the angles by 2 in order to stretch
    //the range from (-pi/2, pi/2] to (-pi, pi]. MinDiff has to be increased as well.
    if (0 != hv_IgnoreDirection)
    {
      hv_AnglesReduced = 2.0*hv_AnglesReduced;
      hv_MinDiff = HTuple(60).TupleRad();
    }
    //Perform clustering of collected angles.
    cluster_dl_detection_param(hv_AnglesReduced, hv_K, hv_MinRatio, hv_MinDiff, 1, 
        &hv_ClusteredAngles);
    //In case of 'ignore_direction', we have to retransform the cluster centers
    //from range (-pi, pi] to (-pi/2, pi/2].
    if (0 != hv_IgnoreDirection)
    {
      hv_ClusteredAngles = hv_ClusteredAngles/2.0;
    }
    //If we have ClassIDsNoOrientation and if there is a cluster center that is close
    //to 0.0, we set this cluster center to 0.0 to account for the typically many
    //ground truth boxes with angle 0.0.
    if (0 != (int((hv_ClassIDsNoOrientation.TupleLength())>0)))
    {
      hv_MinAngleIdx = ((hv_ClusteredAngles.TupleAbs()).TupleEqualElem((hv_ClusteredAngles.TupleAbs()).TupleMin())).TupleFind(1);
      if (0 != (int((HTuple(hv_ClusteredAngles[HTuple(hv_MinAngleIdx[0])]).TupleAbs())<(HTuple(5).TupleRad()))))
      {
        hv_ClusteredAngles[HTuple(hv_MinAngleIdx[0])] = 0.0;
      }
    }
    SetDictTuple((*hv_DLDetectionModelParam), "anchor_angles", hv_ClusteredAngles);
  }
  //
  //Display the histograms calculated from the data collections.
  hv_WindowBGColor = "light gray";
  hv_SplitText = "";
  if (0 != (int(hv_DatasetSplit!=HTuple("all"))))
  {
    hv_SplitText = (" ("+hv_DatasetSplit)+")";
  }
  if (0 != hv_DisplayHistogram)
  {
    //Plot histogram of bounding box areas.
    SetWindowAttr("background_color",hv_WindowBGColor);
    OpenWindow(0,0,512,400,0,"visible","",&hv_WindowHandle);
    HDevWindowStack::Push(hv_WindowHandle);
    plot_dl_detection_histogram(hv_Areas, "#ff6384", (HTuple("title").Append("label_x")), 
        ("Histogram of bounding box areas"+hv_SplitText).TupleConcat("Bounding box area"), 
        hv_WindowHandle);
    //Plot histogram of aspect ratios.
    SetWindowAttr("background_color",hv_WindowBGColor);
    OpenWindow(0,520,512,400,0,"visible","",&hv_WindowHandle2);
    HDevWindowStack::Push(hv_WindowHandle2);
    plot_dl_detection_histogram(hv_AspectRatios, "#66ff92", (HTuple("title").Append("label_x")), 
        ("Histogram of aspect ratios"+hv_SplitText).TupleConcat("Aspect ratio"), 
        hv_WindowHandle2);
    if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      //Plot histogram of anchor angles.
      SetWindowAttr("background_color",hv_WindowBGColor);
      OpenWindow(450,0,512,400,0,"visible","",&hv_WindowHandle3);
      HDevWindowStack::Push(hv_WindowHandle3);
      plot_dl_detection_histogram(hv_Angles, "#36a2eb", (HTuple("title").Append("label_x")), 
          ("Histogram of angles"+hv_SplitText).TupleConcat("Angle (rad)"), hv_WindowHandle3);
    }
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Generate a histogram out of the input and displays the plot. 
void plot_dl_detection_histogram (HTuple hv_DataCollection, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_PlotBackground;

  // Local control variables
  HTuple  hv_LabelY, hv_AxesColor, hv_Title, hv_LabelX;
  HTuple  hv_GenParamIndex, hv_MinHisto, hv_DataHisto, hv_DataBinSize;
  HTuple  hv_PartRow1, hv_PartColumn1, hv_PartRow2, hv_PartColumn2;
  HTuple  hv_LeftX, hv_RightX, hv_StepX, hv_StepY, hv_LabelXShift;

  //This procedure generates and displays a histogram of the data given
  //in DataCollection.
  //
  //Fixed display parameters.
  hv_LabelY = "Frequency";
  hv_AxesColor = "#898b8f";
  //
  //Variable display parameters.
  hv_Title = "";
  hv_LabelX = "";
  //
  {
  HTuple end_val11 = (hv_GenParamName.TupleLength())-1;
  HTuple step_val11 = 1;
  for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val11, step_val11); hv_GenParamIndex += step_val11)
  {
    if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("label_x"))))
    {
      hv_LabelX = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("title"))))
    {
      hv_Title = HTuple(hv_GenParamValue[hv_GenParamIndex]);
    }
    else
    {
      throw HException(("Unknown generic parameter "+HTuple(hv_GenParamName[hv_GenParamIndex]))+".");
    }
  }
  }
  //
  //Get data histogram. Set minimum to 0 if it is greater than 0.
  hv_MinHisto = hv_DataCollection.TupleMin();
  if (0 != (int(hv_MinHisto>0)))
  {
    hv_MinHisto = 0;
  }
  TupleHistoRange(hv_DataCollection, hv_MinHisto, hv_DataCollection.TupleMax(), 100, 
      &hv_DataHisto, &hv_DataBinSize);
  //
  //Set some window parameters.
  set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
  SetWindowParam(hv_WindowHandle, "flush", "false");
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),2);
  //
  //Plot white background.
  GetPart(hv_WindowHandle, &hv_PartRow1, &hv_PartColumn1, &hv_PartRow2, &hv_PartColumn2);
  GenRectangle1(&ho_PlotBackground, hv_PartRow1+40, hv_PartColumn1+20, hv_PartRow2-20, 
      hv_PartColumn2-20);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"white");
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"fill");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_PlotBackground, HDevWindowStack::GetActive());
  //Plot title text.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Title, "image", hv_PartRow1+10, hv_PartColumn1+20, 
        "black", "box", "false");
  //
  //Set data for x tick.
  hv_LeftX = hv_MinHisto;
  hv_RightX = hv_DataCollection.TupleMax();
  hv_StepX = hv_DataBinSize;
  if (0 != (int(hv_StepX>1)))
  {
    hv_StepX = hv_StepX.TupleInt();
  }
  hv_StepY = (((hv_DataHisto.TupleMax())/7).TupleConcat(1)).TupleMax();
  //
  //Plot the histogram.
  plot_tuple(hv_WindowHandle, HTuple::TupleGenSequence(hv_LeftX,hv_RightX-(hv_DataBinSize/2.),hv_DataBinSize), 
      hv_DataHisto, "", "", hv_Color, ((((((HTuple("axes_color").Append("ticks_x")).Append("ticks_y")).Append("margin_top")).Append("margin_bottom")).Append("margin_left")).Append("margin_right")), 
      ((hv_AxesColor.TupleConcat(15*hv_StepX)).TupleConcat(hv_StepY)).TupleConcat((((HTuple(75).Append(60)).Append(70)).Append(60))));
  //Display the x and y labels.
  hv_LabelXShift = ((hv_LabelX.TupleStrlen())*10)+25;
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_LabelX, "image", hv_PartRow2-42, hv_PartColumn2-hv_LabelXShift, 
        hv_AxesColor, "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_LabelY, "image", hv_PartRow1+45, hv_PartColumn1+25, 
        hv_AxesColor, "box", "false");
  //
  FlushBuffer(hv_WindowHandle);
  SetWindowParam(hv_WindowHandle, "flush", "true");
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Remove given ratio of the smallest and largest data points in the data collection DataCollection. 
void remove_dl_data_outliers (HTuple hv_DataCollection, HTuple *hv_DataCollectionReduced)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OutliersRatio, hv_MinNumData, hv_NumData;
  HTuple  hv_DataSorted, hv_DataOutliers;

  //This procedure removes a given ratio of the smallest and largest data
  //points in the input DataCollection in order to remove possible outliers.
  //
  //The ratio of the data collections to be considered as outliers.
  hv_OutliersRatio = 0.0025;
  hv_MinNumData = (1/hv_OutliersRatio)-1;
  //
  //Remove outliers in the given data collection.
  hv_NumData = hv_DataCollection.TupleLength();
  if (0 != (int(hv_NumData>hv_MinNumData)))
  {
    hv_DataSorted = hv_DataCollection.TupleSort();
    hv_DataOutliers = (hv_OutliersRatio*hv_NumData).TupleInt();
    (*hv_DataCollectionReduced) = hv_DataSorted.TupleSelectRange(hv_DataOutliers,(hv_NumData-hv_DataOutliers)-1);
  }
  else
  {
    (*hv_DataCollectionReduced) = hv_DataCollection;
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Calculate the scaled bounding box parameters for a bounding box of type rectangle2. 
void scale_rectangle2_bbox (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, HTuple hv_Length2, 
    HTuple hv_Phi, HTuple hv_FactorHeight, HTuple hv_FactorWidth, HTuple *hv_NewRow, 
    HTuple *hv_NewCol, HTuple *hv_NewLength1, HTuple *hv_NewLength2, HTuple *hv_NewPhi)
{

  // Local iconic variables
  HObject  ho_Rectangle2XLD, ho_Rectangle2XLDSheared;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DScale;
  HTuple  hv_NewPhi1, hv_NewPhi2, hv_NewPhi3, hv_NewPhi4;
  HTuple  hv_Pi, hv_MaskPhi2, hv_MaskPhi3, hv_MaskPhi4, hv_Diff1;
  HTuple  hv_Diff2, hv_Diff3, hv_Diff4, hv_MaskDiff1, hv_MaskDiff2;
  HTuple  hv_MaskDiff3, hv_MaskDiff4, hv_MaskDiff1Mult, hv_MaskDiff2Mult;
  HTuple  hv_MaskDiff3Mult, hv_MaskDiff4Mult, hv_MinDiff12;
  HTuple  hv_MinIndex12, hv_MinDiff34, hv_MinIndex34, hv_MinDiff1234;
  HTuple  hv_MinIndex12Mask, hv_MinIndex34Mask, hv_MinIndex12Masked;
  HTuple  hv_MinIndex34Masked, hv_MinIndex1234, hv_NewPhi1Masked;
  HTuple  hv_NewPhi2Masked, hv_NewPhi3Masked, hv_NewPhi4Masked;
  HTuple  hv_SwapMask, hv_SwapMaskInverted, hv_Length1Tmp;
  HTuple  hv_Length2Tmp;

  //This procedure computes the parameters of a given bounding box of type
  //rectangle2 for an image scaling by FactorHeight and FactorWidth.
  //
  //Generate XLD contour for the rectangle.
  GenRectangle2ContourXld(&ho_Rectangle2XLD, hv_Row, hv_Col, hv_Phi, hv_Length1, 
      hv_Length2);
  //Create scaling matrix.
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dScale(hv_HomMat2DIdentity, hv_FactorHeight, hv_FactorWidth, 0, 0, &hv_HomMat2DScale);
  //
  //Scale the XLD contours --> results in sheared regions.
  AffineTransContourXld(ho_Rectangle2XLD, &ho_Rectangle2XLDSheared, hv_HomMat2DScale);
  SmallestRectangle2Xld(ho_Rectangle2XLDSheared, &(*hv_NewRow), &(*hv_NewCol), &(*hv_NewPhi), 
      &(*hv_NewLength1), &(*hv_NewLength2));
  //
  //Since the angle Phi can point to 4 different directions for the same rectangle2,
  //it is possible that the new Phi returned by smallest_rectangle2_xld is not the one
  //corresponding to the original Phi. Hence we need to get all 4 possible Phis and
  //find the one closest to the original.
  //
  //At first, get the 4 angles.
  hv_NewPhi1 = (*hv_NewPhi);
  hv_NewPhi2 = (*hv_NewPhi)+(HTuple(90).TupleRad());
  hv_NewPhi3 = (*hv_NewPhi)+(HTuple(180).TupleRad());
  hv_NewPhi4 = (*hv_NewPhi)+(HTuple(270).TupleRad());
  //Clip the angles to the range -Pi to Pi.
  hv_Pi = HTuple(180).TupleRad();
  hv_MaskPhi2 = ((hv_NewPhi2.TupleGreaterElem(hv_Pi))*2)*hv_Pi;
  hv_MaskPhi3 = ((hv_NewPhi3.TupleGreaterElem(hv_Pi))*2)*hv_Pi;
  hv_MaskPhi4 = ((hv_NewPhi4.TupleGreaterElem(hv_Pi))*2)*hv_Pi;
  hv_NewPhi2 = hv_NewPhi2-hv_MaskPhi2;
  hv_NewPhi3 = hv_NewPhi3-hv_MaskPhi3;
  hv_NewPhi4 = hv_NewPhi4-hv_MaskPhi4;
  //Calculate the distance between the new angles and the original one.
  hv_Diff1 = (hv_NewPhi1-hv_Phi).TupleAbs();
  hv_Diff2 = (hv_NewPhi2-hv_Phi).TupleAbs();
  hv_Diff3 = (hv_NewPhi3-hv_Phi).TupleAbs();
  hv_Diff4 = (hv_NewPhi4-hv_Phi).TupleAbs();
  //The distance should not be larger than Pi. Let's view the range of possible
  //values for the angles as a clock where 12 o'clock is Pi and -Pi, 3 o'clock is Pi/2
  //6 o'clock is 0 and 9 o'clock is -Pi/2. If we calculate the distance of two
  //angles on this clock, the distance can not be larger than half of the perimeter
  //of the clock which is Pi. If it is larger, it means that we have calculated the
  //distance in the wrong clock direction. The right distance can be simply calculated
  //with 2*Pi (perimeter of the clock) minus the wrong distance.
  hv_MaskDiff1 = hv_Diff1.TupleGreaterElem(hv_Pi);
  hv_MaskDiff2 = hv_Diff2.TupleGreaterElem(hv_Pi);
  hv_MaskDiff3 = hv_Diff3.TupleGreaterElem(hv_Pi);
  hv_MaskDiff4 = hv_Diff4.TupleGreaterElem(hv_Pi);
  hv_MaskDiff1Mult = 1-(hv_MaskDiff1*2);
  hv_MaskDiff2Mult = 1-(hv_MaskDiff2*2);
  hv_MaskDiff3Mult = 1-(hv_MaskDiff3*2);
  hv_MaskDiff4Mult = 1-(hv_MaskDiff4*2);
  hv_Diff1 = (hv_MaskDiff1Mult*hv_Diff1)+((hv_MaskDiff1*2)*hv_Pi);
  hv_Diff2 = (hv_MaskDiff2Mult*hv_Diff2)+((hv_MaskDiff2*2)*hv_Pi);
  hv_Diff3 = (hv_MaskDiff3Mult*hv_Diff3)+((hv_MaskDiff3*2)*hv_Pi);
  hv_Diff4 = (hv_MaskDiff4Mult*hv_Diff4)+((hv_MaskDiff4*2)*hv_Pi);
  //Get the angles with the minimum distances. Therefore we compare the angle tuples pairwise.
  //At first, NewPhi1 and NewPhi2 ...
  hv_MinDiff12 = hv_Diff1.TupleMin2(hv_Diff2);
  //... and store the tuple index of the minimum.
  hv_MinIndex12 = (hv_Diff1.TupleGreaterEqualElem(hv_Diff2))+1;
  //Now, compare NewPhi3 and NewPhi4 ...
  hv_MinDiff34 = hv_Diff3.TupleMin2(hv_Diff4);
  //... and also store the tuple index of the minimum.
  hv_MinIndex34 = (hv_Diff3.TupleGreaterEqualElem(hv_Diff4))+3;
  //At last, compare the results from previous comparisons ...
  hv_MinDiff1234 = hv_MinDiff12.TupleMin2(hv_MinDiff34);
  //... and store the final indices.
  hv_MinIndex12Mask = hv_MinDiff12.TupleLessElem(hv_MinDiff34);
  hv_MinIndex34Mask = 1-hv_MinIndex12Mask;
  hv_MinIndex12Masked = hv_MinIndex12*hv_MinIndex12Mask;
  hv_MinIndex34Masked = hv_MinIndex34*hv_MinIndex34Mask;
  hv_MinIndex1234 = hv_MinIndex12Masked+hv_MinIndex34Masked;
  //
  //Using the final indices, we can create a mask for each of the angle tuples.
  hv_NewPhi1Masked = (hv_MinIndex1234.TupleEqualElem(1))*hv_NewPhi1;
  hv_NewPhi2Masked = (hv_MinIndex1234.TupleEqualElem(2))*hv_NewPhi2;
  hv_NewPhi3Masked = (hv_MinIndex1234.TupleEqualElem(3))*hv_NewPhi3;
  hv_NewPhi4Masked = (hv_MinIndex1234.TupleEqualElem(4))*hv_NewPhi4;
  (*hv_NewPhi) = ((hv_NewPhi1Masked+hv_NewPhi2Masked)+hv_NewPhi3Masked)+hv_NewPhi4Masked;
  //In case the correct angle is the angle returned by smallest_rectangle2 + 90 or
  //+ 270 degrees, we need to swap length1 and length2.
  hv_SwapMask = (hv_MinIndex1234.TupleEqualElem(2))+(hv_MinIndex1234.TupleEqualElem(4));
  hv_SwapMaskInverted = 1-hv_SwapMask;
  hv_Length1Tmp = (*hv_NewLength1)*hv_SwapMask;
  hv_Length2Tmp = (*hv_NewLength2)*hv_SwapMask;
  (*hv_NewLength1) = ((*hv_NewLength1)*hv_SwapMaskInverted)+hv_Length2Tmp;
  (*hv_NewLength2) = ((*hv_NewLength2)*hv_SwapMaskInverted)+hv_Length1Tmp;
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Suggest the minimum and maximum level as well as the number of anchor subscales for an object detection model. 
void select_dl_detection_levels (HTuple hv_Areas, HTuple hv_MinLevel, HTuple hv_MaxLevel, 
    HTuple hv_AnchorNumSubscales, HTuple *hv_MinLevelToUse, HTuple *hv_MaxLevelToUse, 
    HTuple *hv_AnchorNumSubscalesToUse)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GoodIoU, hv_GoodIoURatio, hv_AnchorScale;
  HTuple  hv_LevelScales, hv_LevelHalfStrides, hv_LevelHalfStridesSq;
  HTuple  hv_GTBWidths, hv_Subscales, hv_SubscaleFactors;
  HTuple  hv_SubLevelWidths, hv_Lvl, hv_AnchorWidths, hv_SubLevelAreas;
  HTuple  hv_Cs_1, hv_Cs_2, hv_C_1, hv_C_2, hv_SmallWidth;
  HTuple  hv_SubLevelWidthMinusC1, hv_LargeWidth, hv_CheckResult;
  HTuple  hv_MinSmallWidth, hv_Sublvl, hv_ZeroIndices, hv_MinWidth;
  HTuple  hv_MinSubLevel, hv_SmallWidthDistances, hv_MaxWidth;
  HTuple  hv_MaxSubLevel, hv_LargeWidthDistances;

  //This procedure suggests levels and number of anchor subscales
  //suiting best for a deep-learning-based object detection model
  //based on the input Areas.
  //
  //Check that the input Areas has at least one value.
  if (0 != (int((hv_Areas.TupleLength())<1)))
  {
    throw HException("No bounding box areas to process.");
  }
  //
  //Try to find the minimum number of subscales required to get
  //a good IoU for all bounding box sizes.
  //
  //As long as the IoU is above the following threshold value, it is
  //considered to be good.
  hv_GoodIoU = 0.5;
  //Minimum ratio of all ground truth bounding boxes which need to have
  //the good IoU stated above.
  hv_GoodIoURatio = 0.99;
  //
  //Scaling constants and strides for anchor boxes of different levels.
  hv_AnchorScale = 4.;
  hv_LevelScales = hv_AnchorScale*(HTuple(2.).TuplePow(HTuple::TupleGenSequence(hv_MinLevel,hv_MaxLevel,1)));
  hv_LevelHalfStrides = (HTuple(2.).TuplePow(HTuple::TupleGenSequence(hv_MinLevel,hv_MaxLevel,1)))/2;
  hv_LevelHalfStridesSq = hv_LevelHalfStrides*hv_LevelHalfStrides;
  //
  //Ground truth bounding box widths.
  hv_GTBWidths = hv_Areas.TupleSqrt();
  //
  //Loop over the subscales (starting at 1) until a value is found for
  //which all IoUs are good or the upper bound (given by AnchorNumSubscales)
  //is reached.
  (*hv_AnchorNumSubscalesToUse) = hv_AnchorNumSubscales;
  {
  HTuple end_val32 = hv_AnchorNumSubscales;
  HTuple step_val32 = 1;
  for (hv_Subscales=1; hv_Subscales.Continue(end_val32, step_val32); hv_Subscales += step_val32)
  {
    //Calculate scaling factors for the subscales.
    hv_SubscaleFactors = HTuple(2).TuplePow(HTuple::TupleGenSequence(0,hv_Subscales-1,1)/(hv_Subscales.TupleReal()));
    //Calculate the widths of each sublevel (level + subscales).
    hv_SubLevelWidths = HTuple();
    {
    HTuple end_val37 = hv_MaxLevel;
    HTuple step_val37 = 1;
    for (hv_Lvl=hv_MinLevel; hv_Lvl.Continue(end_val37, step_val37); hv_Lvl += step_val37)
    {
      hv_AnchorWidths = hv_SubscaleFactors*HTuple(hv_LevelScales[hv_Lvl-hv_MinLevel]);
      hv_SubLevelWidths = hv_SubLevelWidths.TupleConcat(hv_AnchorWidths);
    }
    }
    hv_SubLevelAreas = hv_SubLevelWidths*hv_SubLevelWidths;
    //
    //For each sublevel one can determine the range of possible bounding
    //box widths leading to a good IoU. Therewith we can check, if every
    //ground truth bounding box width is between a minimum and a maximum
    //value.
    //
    //The minimum and maximum can be derived from the formula of the
    //IoU. To calculate the IoU, we need to consider the stride
    //length of the level. With a stride of d, the worst case
    //(minimum overlap) between the ground truth bounding box and
    //anchor bounding box looks like follows
    //
    //       ---------
    //      |         |< d/2
    //      |    -----|--------
    //      |   |     |        |
    //      |   |     |        |
    //       ---------         |
    //       ^  |              |
    //      d/2 |              |
    //          |              |
    //           --------------
    //
    //With X = width of the smaller bounding box and Y = width of the larger
    //bounding box, r = GoodIoU, the IoU is calculated by
    //
    //            X^2 - 2*d/2*X + d^2/4
    //         -------------------------- >= r
    //           Y^2 + (2*d/2*X - d^2/4)
    //
    //              X^2 - d*X + d^2/4
    //         -------------------------- >= r
    //              Y^2 + d*X - d^2/4
    //
    //                  X^2 - d*X + d^2/4 >= r * (Y^2 + d*X - d^2/4)
    //      X^2 - (1+r)*d*X + (1+r)*d^2/4 >= r*Y^2
    //(X - (1+r)*d/2)^2 - (r^2 + r)*d^2/4 >= r*Y^2
    //
    //By substituting the constants
    //C_1 = (1+r)*d/2
    //C_2 = (r^2 + r)*d^2/4,
    //we get
    //(X - C_1)^2 - C_2 >= r*Y^2
    //
    hv_Cs_1 = HTuple();
    hv_Cs_2 = HTuple();
    {
    HTuple end_val88 = hv_MaxLevel;
    HTuple step_val88 = 1;
    for (hv_Lvl=hv_MinLevel; hv_Lvl.Continue(end_val88, step_val88); hv_Lvl += step_val88)
    {
      hv_C_1 = (1+hv_GoodIoU)*HTuple(hv_LevelHalfStrides[hv_Lvl-hv_MinLevel]);
      hv_Cs_1 = hv_Cs_1.TupleConcat(HTuple(hv_Subscales,hv_C_1));
      hv_C_2 = ((hv_GoodIoU.TuplePow(2))+hv_GoodIoU)*HTuple(hv_LevelHalfStridesSq[hv_Lvl-hv_MinLevel]);
      hv_Cs_2 = hv_Cs_2.TupleConcat(HTuple(hv_Subscales,hv_C_2));
    }
    }
    //
    //In case the ground truth bounding box is smaller than the anchor bounding box
    //=> ground truth bounding box width = X:
    //X >= sqrt(r*Y^2 + C_2) + C_1
    hv_SmallWidth = (((hv_GoodIoU*hv_SubLevelAreas)+hv_Cs_2).TupleSqrt())+hv_Cs_1;
    //
    //In case the ground truth bounding box is larger than the anchor bounding box
    //=> ground truth bounding box width = Y:
    //Y <= sqrt(((X - C_1)^2 - C_2) * 1/r)
    hv_SubLevelWidthMinusC1 = hv_SubLevelWidths-hv_Cs_1;
    hv_LargeWidth = (((hv_SubLevelWidthMinusC1*hv_SubLevelWidthMinusC1)-hv_Cs_2)/hv_GoodIoU).TupleSqrt();
    //
    //Check whether all ground truth bounding box widths lie within the above
    //calculated minimum and maximum widths of one sublevel.
    hv_CheckResult = HTuple(hv_GTBWidths.TupleLength(),0);
    //Set CheckResult for ground truth bounding boxes smaller than the minimum
    //to 1 since these do not fit regardless of anchor_num_subscales.
    hv_MinSmallWidth = hv_SmallWidth.TupleMin();
    hv_CheckResult += hv_GTBWidths.TupleLessElem(hv_MinSmallWidth);
    //Check for each sublevel whether the ground truth widths fit in.
    {
    HTuple end_val114 = (hv_SubLevelWidths.TupleLength())-1;
    HTuple step_val114 = 1;
    for (hv_Sublvl=0; hv_Sublvl.Continue(end_val114, step_val114); hv_Sublvl += step_val114)
    {
      hv_CheckResult += (hv_GTBWidths.TupleGreaterEqualElem(HTuple(hv_SmallWidth[hv_Sublvl]))).TupleAnd(hv_GTBWidths.TupleLessEqualElem(HTuple(hv_LargeWidth[hv_Sublvl])));
    }
    }
    //
    hv_ZeroIndices = hv_CheckResult.TupleFind(0);
    //In case there is only an insignificant number of ground truth widths which
    //do not fit in any of the sublevels, the current number of subscales is chosen.
    if (0 != (HTuple(int(hv_ZeroIndices==-1)).TupleOr(int((hv_ZeroIndices.TupleLength())<((1-hv_GoodIoURatio)*(hv_GTBWidths.TupleLength()))))))
    {
      (*hv_AnchorNumSubscalesToUse) = hv_Subscales;
      break;
    }
  }
  }
  //
  //Get minimum ground truth bounding box width.
  hv_MinWidth = hv_GTBWidths.TupleMin();
  //Get last sublevel where the smallest object fits in.
  hv_MinSubLevel = HTuple((hv_SmallWidth.TupleLessEqualElem(hv_MinWidth)).TupleAnd(hv_LargeWidth.TupleGreaterEqualElem(hv_MinWidth))).TupleFindLast(1);
  //If no sublevel could be found, take the sublevel with the SmallWidth
  //closest to MinWidth.
  if (0 != (int(hv_MinSubLevel==-1)))
  {
    hv_SmallWidthDistances = (hv_SmallWidth-hv_MinWidth).TupleAbs();
    hv_MinSubLevel = hv_SmallWidthDistances.TupleFindLast(hv_SmallWidthDistances.TupleMin());
  }
  hv_MinSubLevel = (HTuple(0).TupleConcat(hv_MinSubLevel)).TupleMax();
  //
  //Get maximum ground truth bounding box width.
  hv_MaxWidth = hv_GTBWidths.TupleMax();
  //Get first sublevel where the largest object fits in.
  hv_MaxSubLevel = HTuple((hv_SmallWidth.TupleLessEqualElem(hv_MaxWidth)).TupleAnd(hv_LargeWidth.TupleGreaterEqualElem(hv_MaxWidth))).TupleFindFirst(1);
  //If no sublevel could be found, take the sublevel with the LargeWidth
  //closest to MaxWidth.
  if (0 != (int(hv_MaxSubLevel==-1)))
  {
    hv_LargeWidthDistances = (hv_LargeWidth-hv_MaxWidth).TupleAbs();
    hv_MaxSubLevel = hv_LargeWidthDistances.TupleFindFirst(hv_LargeWidthDistances.TupleMin());
  }
  hv_MaxSubLevel = (hv_MinSubLevel.TupleConcat(hv_MaxSubLevel)).TupleMax();
  //
  //Get the levels from the sublevels.
  (*hv_MinLevelToUse) = (hv_MinSubLevel/(*hv_AnchorNumSubscalesToUse))+hv_MinLevel;
  (*hv_MaxLevelToUse) = (hv_MaxSubLevel/(*hv_AnchorNumSubscalesToUse))+hv_MinLevel;
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Compute a percentile of a tuple. 
void tuple_percentile (HTuple hv_Tuple, HTuple hv_Percentile, HTuple *hv_Value)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_L, hv_qidx;

  (*hv_Value) = HTuple();
  if (0 != (HTuple(int(hv_Percentile<0)).TupleOr(int(hv_Percentile>1))))
  {
    throw HException("Error: Percentile should be in the range [0-1]. (e.g. 10% ~ Percentile = 0.1 )");
  }
  hv_L = hv_Tuple.TupleLength();
  if (0 != (int(hv_L>0)))
  {
    TupleSort(hv_Tuple, &hv_Tuple);
    hv_qidx = (hv_Percentile*(hv_L-1)).TupleRound();
    (*hv_Value) = HTuple(hv_Tuple[hv_qidx]);
  }
  return;
}


