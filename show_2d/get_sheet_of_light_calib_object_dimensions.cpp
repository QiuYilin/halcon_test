///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;


// Chapter: 3D Reconstruction / Sheet of Light
// Short Description: Calculate the dimensions of a sheet-of-light calibration object. 
void get_sheet_of_light_calib_object_dimensions (HTuple hv_Width, HTuple hv_Length, 
    HTuple hv_HeightMin, HTuple hv_HeightMax, HTuple *hv_DiameterCircle, HTuple *hv_PyramidHeight, 
    HTuple *hv_PyramidDistanceFromFront, HTuple *hv_PyramidBottomDiagonal, HTuple *hv_PyramidTopDiagonal, 
    HTuple *hv_Angle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CircleFactor, hv_PyramidBottomFactor;
  HTuple  hv_PyramidTopFactor, hv_OffsetFactor, hv_MaxAngle;
  HTuple  hv_Pi, hv_Height, hv_Hypotenuse, hv_CosAlpha, hv_SinAlpha;
  HTuple  hv_Dist, hv_PyramidHeight1, hv_PyramidHeight2;

  //
  //Constants:
  hv_CircleFactor = 0.075;
  hv_PyramidBottomFactor = 0.9;
  hv_PyramidTopFactor = 0.5;
  hv_OffsetFactor = 0.1;
  hv_MaxAngle = HTuple(45).TupleRad();
  hv_Pi = HTuple(180).TupleRad();
  //
  //Circle:
  (*hv_DiameterCircle) = hv_CircleFactor*hv_Width;
  //
  (*hv_PyramidBottomDiagonal) = hv_Width*hv_PyramidBottomFactor;
  (*hv_PyramidTopDiagonal) = (*hv_PyramidBottomDiagonal)*hv_PyramidTopFactor;
  (*hv_PyramidDistanceFromFront) = 0.1*hv_Length;
  //
  //Find the height of the truncated pyramid such that
  //its highest point's Z coordinate is equal to HeightMax.
  hv_Height = hv_HeightMax-hv_HeightMin;
  hv_Hypotenuse = ((hv_Length*hv_Length)+(hv_Height*hv_Height)).TupleSqrt();
  hv_CosAlpha = hv_Length/hv_Hypotenuse;
  hv_SinAlpha = hv_Height/hv_Hypotenuse;
  (*hv_Angle) = hv_CosAlpha.TupleAcos();
  hv_Dist = ((hv_OffsetFactor*hv_Length)+(0.5*(*hv_PyramidBottomDiagonal)))+(0.5*(*hv_PyramidTopDiagonal));
  hv_PyramidHeight1 = (hv_Height-(hv_Dist*hv_SinAlpha))/hv_CosAlpha;
  //
  //Limit the height of the pyramid such that the angle of
  //its side planes to the ground plane is at most MaxAngle.
  hv_PyramidHeight2 = ((hv_MaxAngle.TupleTan())*0.5)*((*hv_PyramidBottomDiagonal)-(*hv_PyramidTopDiagonal));
  (*hv_PyramidHeight) = hv_PyramidHeight1.TupleMin2(hv_PyramidHeight2);
  return;
}
