///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;


// Chapter: System / Operating System
// Short Description: Create a formatted string of a time span. 
void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, HTuple *hv_TimeString)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Seconds, hv_TotalMinutes, hv_Minutes;
  HTuple  hv_TotalHours, hv_Hours, hv_Days;

  //
  //This procedure creates a readable representation of a time span
  //given the elapsed time in seconds.
  //
  //Ensure that the input is an integer.
  hv_TotalSeconds = hv_TotalSeconds.TupleInt();
  //
  hv_Seconds = hv_TotalSeconds%60;
  //
  hv_TotalMinutes = hv_TotalSeconds/60;
  hv_Minutes = hv_TotalMinutes%60;
  //
  hv_TotalHours = hv_TotalSeconds/3600;
  hv_Hours = hv_TotalHours%24;
  //
  hv_Days = hv_TotalSeconds/86400;
  //
  if (0 != (int(hv_Format==HTuple("auto"))))
  {
    //Print the highest non-zero unit and all remaining sub-units.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (((((((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (((((hv_Hours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (((hv_Minutes.TupleString("d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("top1"))))
  {
    //Print the highest non-zero unit.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (hv_Days.TupleString("d"))+"d";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (hv_Hours.TupleString("d"))+"h";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (hv_Minutes.TupleString("d"))+"m";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("top2"))))
  {
    //Print the highest non-zero unit and the following sub-unit.
    if (0 != (int(hv_Days>0)))
    {
      (*hv_TimeString) = (((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h";
    }
    else if (0 != (int(hv_Hours>0)))
    {
      (*hv_TimeString) = (((hv_Hours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m";
    }
    else if (0 != (int(hv_Minutes>0)))
    {
      (*hv_TimeString) = (((hv_Minutes.TupleString("d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
    }
    else
    {
      (*hv_TimeString) = (hv_Seconds.TupleString("d"))+"s";
    }
  }
  else if (0 != (int(hv_Format==HTuple("dhms"))))
  {
    //Print a Days-Hours-Minutes-Seconds string.
    (*hv_TimeString) = (((((((hv_Days.TupleString("d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
  }
  else if (0 != (int(hv_Format==HTuple("hms"))))
  {
    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
    (*hv_TimeString) = (((((hv_TotalHours.TupleString("d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
  }
  else
  {
    throw HException("Unknown format string.");
  }
  //
  return;
}
