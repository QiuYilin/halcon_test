///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
extern void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: OCR / Deep OCR
// Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
extern void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, 
    HTuple *hv_DetectionResults);
// Chapter: Deep Learning / Model
// Short Description: Create a dictionary with the preprocessing parameters based on a given DL model. 
extern void create_dl_preprocess_param_from_model (HTuple hv_DLModelHandle, HTuple hv_NormalizationType, 
    HTuple hv_DomainHandling, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground, 
    HTuple hv_GenParam, HTuple *hv_DLPreprocessParam);
// Chapter: Graphics / Window
// Short Description: Close all window handles contained in a dictionary. 
extern void dev_close_window_dict (HTuple hv_WindowHandleDict);
// Chapter: Graphics / Window
// Short Description: Close all window handles contained in a dictionary. 
extern void dev_close_window_dict (HTuple hv_WindowHandleDict);
// Chapter: Graphics / Window
// Short Description: Close all window handles contained in a dictionary. 
extern void dev_close_window_dict (HTuple hv_WindowHandleDict);
// Chapter: Graphics / Output
// Short Description: Display an interactive button. 
extern void dev_disp_button (HTuple hv_String, HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_ColorString, HTuple hv_ColorBackground, HTuple hv_ColorBackgroundActive, 
    HTuple hv_WindowHandle, HTuple *hv_SelectedButton);
// Chapter: Graphics / Output
// Short Description: Display an interactive button. 
extern void dev_disp_button (HTuple hv_String, HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_ColorString, HTuple hv_ColorBackground, HTuple hv_ColorBackgroundActive, 
    HTuple hv_WindowHandle, HTuple *hv_SelectedButton);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
extern void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
extern void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
extern void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Develop
// Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
extern void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit);
// Chapter: Develop
// Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
extern void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit);
// Chapter: Deep Learning / Model
// Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
extern void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
    HTuple hv_Mode, HTuple *hv_SampleIndices);
// Chapter: Deep Learning / Model
// Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
extern void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
    HTuple hv_Mode, HTuple *hv_SampleIndices);
// Chapter: XLD / Creation
// Short Description: Create an arrow shaped XLD contour. 
extern void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Chapter: XLD / Creation
// Short Description: Create an arrow shaped XLD contour. 
extern void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Chapter: Deep Learning / Classification
// Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
extern void gen_confusion_matrix (HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, HTuple *hv_ConfusionMatrix);
// Chapter: Deep Learning / Model
// Short Description: Return the DLSample dictionaries for given sample indices of a DLDataset. 
extern void gen_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_RestrictKeysDLSample, 
    HTuple hv_GenParam, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Store the given images in a tuple of dictionaries DLSamples. 
extern void gen_dl_samples_from_images (HObject ho_Images, HTuple *hv_DLSampleBatch);
// Chapter: 3D Object Model / Creation
// Short Description: Generate base and tool 3D models of the robot. 
extern void gen_robot_tool_and_base_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowLength, 
    HTuple *hv_OM3DToolOrigin, HTuple *hv_OM3DBase);
// Chapter: Graphics / Output
// Short Description: Plot tuples representing functions or curves in a coordinate system. 
extern void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
    HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue);
// Chapter: Graphics / Output
// Short Description: Plot tuples representing functions or curves in a coordinate system. 
extern void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
    HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue);
// Chapter: Graphics / Output
// Short Description: Plot tuples representing functions or curves in a coordinate system. 
extern void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
    HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue);
// Chapter: Deep Learning / Model
// Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. 
extern void preprocess_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_DLPreprocessParam);
// Chapter: Deep Learning / Model
// Short Description: Read the dictionaries DLSamples from files. 
extern void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Read the dictionaries DLSamples from files. 
extern void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch);
// Chapter: Deep Learning / Model
// Short Description: Read the dictionaries DLSamples from files. 
extern void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch);
// Chapter: Filters / Arithmetic
// Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
extern void scale_image_range (HObject ho_Image, HObject *ho_ImageScaled, HTuple hv_Min, 
    HTuple hv_Max);
// Chapter: Filters / Arithmetic
// Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
extern void scale_image_range (HObject ho_Image, HObject *ho_ImageScaled, HTuple hv_Min, 
    HTuple hv_Max);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
extern void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
    HTuple hv_Bold, HTuple hv_Slant);
// Chapter: Tuple / Element Order
// Short Description: Sort the elements of a tuple randomly. 
extern void tuple_shuffle (HTuple hv_Tuple, HTuple *hv_Shuffled);
// Chapter: Graphics / Output
// Short Description: Display 3D object models 
extern void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
    HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut);
// Chapter: 3D Object Model / Transformations
// Short Description: Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model. 
extern void xyz_attrib_to_object_model_3d (HObject ho_X, HObject ho_Y, HObject ho_Z, 
    HObject ho_AttribImage, HTuple hv_AttribName, HTuple *hv_ObjectModel3D);
// Chapter: 3D Object Model / Transformations
// Short Description: Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model. 
extern void xyz_attrib_to_object_model_3d (HObject ho_X, HObject ho_Y, HObject ho_Z, 
    HObject ho_AttribImage, HTuple hv_AttribName, HTuple *hv_ObjectModel3D);
// Chapter: Image / Channel
void add_colormap_to_image (HObject ho_GrayValueImage, HObject ho_Image, HObject *ho_ColoredImage, 
    HTuple hv_HeatmapColorScheme);
// Chapter: Image / Channel
// Short Description: Create a lookup table and convert a gray scale image. 
void apply_colorscheme_on_gray_value_image (HObject ho_InputImage, HObject *ho_ResultImage, 
    HTuple hv_Schema);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Visualize the results of an evaluation for a model of type 3D Gripping Point Detection. 
void dev_display_3d_gripping_point_detection_evaluation (HTuple hv_EvaluationResult, 
    HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display evaluation results of an evaluated DL model of type 'anomaly_detection' or 'gc_anomaly_detection'. 
void dev_display_anomaly_detection_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display pie charts for prediction or recall of an anomaly detection or Global Context Anomaly Detection evaluation. 
void dev_display_anomaly_evaluation_pie_chart (HTuple hv_WindowHandle, HTuple hv_EvaluationResult, 
    HTuple hv_Mode, HTuple hv_ThresholdIndex);
// Chapter: Deep Learning / Classification
// Short Description: Display evaluation results of an evaluated DL model of type 'classification'. 
void dev_display_classification_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Classification
// Short Description: Display pie charts for prediction or recall of an classification evaluation. 
void dev_display_classification_evaluation_class_pie_chart (HTuple hv_WindowHandle, 
    HTuple hv_EvaluationResult, HTuple hv_ClassIDs, HTuple hv_Mode);
// Chapter: Graphics / Output
// Short Description: Display a map of the confidences. 
void dev_display_confidence_regions (HObject ho_ImageConfidence, HTuple hv_DrawTransparency, 
    HTuple *hv_Colors);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display the confusion matrix for the evaluation results of a model with type detection. 
void dev_display_detection_confusion_matrix (HTuple hv_WindowHandles, HTuple hv_IoUEvaluationResult, 
    HTuple hv_ClassIDs, HTuple hv_GenParam);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Visualize the results of a detailed evaluation for a model of type detection. 
void dev_display_detection_detailed_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display a pie-chart for the evaluation results of one class or all classes together. 
void dev_display_detection_eval_class_pie_chart (HTuple hv_WindowHandle, HTuple hv_ClassEvaluationResult, 
    HTuple hv_CenterRow, HTuple hv_Mode, HTuple hv_CenterColumn, HTuple hv_Radius, 
    HTuple hv_Colors, HTuple hv_Title, HTuple *hv_Ratios);
// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display the evaluation results as pie-charts. 
void dev_display_detection_evaluation_pie_charts (HTuple hv_WindowHandle, HTuple hv_IoUEvaluationResult, 
    HTuple hv_ClassIDs, HTuple hv_Mode, HTuple hv_BaseWindowRow, HTuple hv_BaseWindowColumn);
// Chapter: Deep Learning / Model
// Short Description: Visualize 3D data for a sample. 
void dev_display_dl_3d_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
    HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Model
// Short Description: Visualize different images, annotations and inference results for a sample. 
void dev_display_dl_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
    HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Model
// Short Description: Close all windows whose handle is contained in the dictionary WindowHandleDict. 
void dev_display_dl_data_close_windows (HTuple hv_WindowHandleDict);
// Chapter: Deep Learning / Model
// Short Description: Try to guess the maximum class id based on the given sample/result. 
void dev_display_dl_data_get_max_class_id (HTuple hv_DLSample, HTuple *hv_MaxClassId, 
    HTuple *hv_Empty);
// Chapter: Deep Learning / Model
// Short Description: Visualize for a given number of samples the raw image, ground truth annotation, and inferred results. 
void dev_display_dl_data_tiled (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_NumSamples, 
    HTuple hv_Split, HTuple hv_GenParam, HTuple hv_WindowHandle, HTuple *hv_WindowHandleOut);
// Chapter: Deep Learning / Classification
// Short Description: Display the confusion matrix that can be used interactively to display samples. 
void dev_display_dl_interactive_confusion_matrix (HTuple hv_DLDataset, HTuple hv_EvaluationResult, 
    HTuple hv_GenParam);
// Chapter: OCR / Deep OCR
// Short Description: Displays information about invalid dataset samples of a Deep OCR dataset. 
void dev_display_dl_invalid_samples (HTuple hv_DLDataset, HTuple hv_DLModelHandle, 
    HTuple hv_InvalidSamplesIndices, HTuple hv_InvalidSamplesReasons);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display the ground truth anomaly regions of the given DLSample. 
void dev_display_ground_truth_anomaly_regions (HTuple hv_SampleKeys, HTuple hv_DLSample, 
    HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor, 
    HTuple hv_AnomalyColorTransparency, HTuple *hv_AnomalyRegionExists);
// Chapter: Graphics / Output
// Short Description: Display the ground truth bounding boxes of DLSample. 
void dev_display_ground_truth_detection (HTuple hv_DLSample, HTuple hv_SampleKeys, 
    HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor, 
    HTuple hv_WindowImageRatio, HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, 
    HTuple hv_WindowHandle, HTuple *hv_BboxIDs);
// Chapter: Graphics / Output
// Short Description: Display a color bar next to an image. 
void dev_display_map_color_bar (HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_MapColorBarWidth, 
    HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio, HTuple hv_WindowHandle);
// Chapter: Graphics / Output
// Short Description: Display a matrix inside a window 
void dev_display_matrix (HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames, 
    HTuple hv_WindowHandle, HTuple hv_GenParam);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Display the confusion matrix given by ConfusionMatrix. 
void dev_display_pixel_confusion_matrix (HTuple hv_ConfusionMatrix, HTuple hv_ClassNames, 
    HTuple hv_GenParam, HTuple hv_WindowHandles);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display the detected anomaly regions. 
void dev_display_result_anomaly_regions (HObject ho_AnomalyRegion, HTuple hv_CurrentWindowHandle, 
    HTuple hv_LineWidth, HTuple hv_AnomalyRegionResultColor);
// Chapter: Graphics / Output
// Short Description: Display result bounding boxes. 
void dev_display_result_detection (HTuple hv_DLResult, HTuple hv_ResultKeys, HTuple hv_LineWidthBbox, 
    HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors, HTuple hv_BoxLabelColor, 
    HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow, HTuple hv_TextColor, HTuple hv_ShowLabels, 
    HTuple hv_ShowDirection, HTuple hv_WindowHandle, HTuple *hv_BboxClassIndices);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Visualize the results of an evaluation for a model of type segmentation. 
void dev_display_segmentation_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict);
// Chapter: Graphics / Output
// Short Description: Display the ground truth/result segmentation as regions. 
void dev_display_segmentation_regions (HObject ho_SegmentationImage, HTuple hv_ClassIDs, 
    HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, HTuple *hv_ImageClassIDs);
// Chapter: Graphics / Output
// Short Description: Display a map of weights. 
void dev_display_weight_regions (HObject ho_ImageWeight, HTuple hv_DrawTransparency, 
    HTuple hv_SegMaxWeight, HTuple *hv_Colors);
// Chapter: Deep Learning / Classification
// Short Description: Generate a tiled image for the classified DLSamples and add indications whether the predictions are true or not. 
void gen_tiled_classification_image_result (HObject *ho_TiledImageRow, HTuple hv_DLSamples, 
    HTuple hv_SpacingCol, HTuple hv_PredictionsCorrect, HTuple hv_ResClasses, HTuple *hv_TextImageRows, 
    HTuple *hv_TextImageColumns, HTuple *hv_TextImageWidth, HTuple *hv_TextImageHeight);
// Chapter: Deep Learning / Classification
// Short Description: Generate a tiled image for the Deep OCR DLSamples and add indications whether the predictions are true or not. 
void gen_tiled_ocr_recognition_image_result (HObject *ho_TiledImage, HTuple hv_DLSamples, 
    HTuple hv_PredictionsCorrect, HTuple *hv_TextImageRows, HTuple *hv_TextImageColumns, 
    HTuple *hv_TextImageWidth, HTuple *hv_TextImageHeight);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Generate a tiled image for segmentation and 3D Gripping Point Detection DLSamples. 
void gen_tiled_segmentation_image (HObject *ho_TiledImageRow, HTuple hv_DLSamples, 
    HTuple hv_SpacingCol, HTuple hv_Width, HTuple hv_Height);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Get the ground truth anomaly label and label ID. 
void get_anomaly_ground_truth_label (HTuple hv_SampleKeys, HTuple hv_DLSample, HTuple *hv_AnomalyLabelGroundTruth, 
    HTuple *hv_AnomalyLabelIDGroundTruth);
// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). 
void get_anomaly_result (HObject *ho_AnomalyImage, HObject *ho_AnomalyRegion, HTuple hv_DLResult, 
    HTuple hv_AnomalyClassThreshold, HTuple hv_AnomalyRegionThreshold, HTuple hv_AnomalyResultPostfix, 
    HTuple *hv_AnomalyScore, HTuple *hv_AnomalyClassID, HTuple *hv_AnomalyClassThresholdDisplay, 
    HTuple *hv_AnomalyRegionThresholdDisplay);
// Chapter: Graphics / Window
// Short Description: Get the next child window that can be used for visualization. 
void get_child_window (HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize, 
    HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowImageRatio, HTuple *hv_PrevWindowCoordinatesOut);
// Chapter: Deep Learning / Classification
// Short Description: Get the ground truth classification label id. 
void get_classification_ground_truth (HTuple hv_SampleKeys, HTuple hv_DLSample, HTuple *hv_ClassificationLabelIDGroundTruth);
// Chapter: Deep Learning / Classification
// Short Description: Get the predicted classification class ID. 
void get_classification_result (HTuple hv_ResultKeys, HTuple hv_DLResult, HTuple *hv_ClassificationClassID);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the confidences of the segmentation result. 
void get_confidence_image (HObject *ho_ImageConfidence, HTuple hv_ResultKeys, HTuple hv_DLResult);
// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
    HTuple hv_EndColor, HTuple *hv_Colors);
// Chapter: Deep Learning / Model
// Short Description: Generate certain colors for different ClassNames 
void get_dl_class_colors (HTuple hv_ClassNames, HTuple hv_AdditionalGreenClassNames, 
    HTuple *hv_Colors);
// Chapter: Deep Learning / Model
// Short Description: Get an image of a sample with a certain key. 
void get_dl_sample_image (HObject *ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample, 
    HTuple hv_Key);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points from a dictionary. 
void get_gripping_points_from_dict (HTuple hv_DLResult, HTuple *hv_Rows, HTuple *hv_Columns);
// Chapter: Graphics / Window
// Short Description: Get the next window that can be used for visualization. 
void get_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
    HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
    HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_CurrentWindowHandle, HTuple *hv_WindowImageRatioHeight, 
    HTuple *hv_PrevWindowCoordinatesOut);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the ground truth segmentation image. 
void get_segmentation_image_ground_truth (HObject *ho_SegmentationImagGroundTruth, 
    HTuple hv_SampleKeys, HTuple hv_DLSample);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the predicted segmentation result image. 
void get_segmentation_image_result (HObject *ho_SegmentationImageResult, HTuple hv_ResultKeys, 
    HTuple hv_DLResult);
// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the weight image of a sample. 
void get_weight_image (HObject *ho_ImageWeight, HTuple hv_SampleKeys, HTuple hv_DLSample);
// Chapter: Deep Learning / Model
// Short Description: Shuffle the input colors in a deterministic way 
void make_neighboring_colors_distinguishable (HTuple hv_ColorsRainbow, HTuple *hv_Colors);
// Chapter: Graphics / Window
// Short Description: Open a window next to the given WindowHandleFather.  
void open_child_window (HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize, 
    HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowHandleChild, HTuple *hv_PrevWindowCoordinatesOut);
// Chapter: Graphics / Window
// Short Description: Open a new window, either next to the last ones, or in a new row. 
void open_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
    HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
    HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowHandleNew, HTuple *hv_WindowImageRatioHeight, 
    HTuple *hv_PrevWindowCoordinatesOut);
// Chapter: Graphics / Window
// Short Description: Set and return meta information to display images correctly. 
void update_window_meta_information (HTuple hv_WindowHandle, HTuple hv_WidthImage, 
    HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth, 
    HTuple hv_MarginBottom, HTuple *hv_WindowImageRatioHeight, HTuple *hv_WindowImageRatioWidth, 
    HTuple *hv_SetPartRow2, HTuple *hv_SetPartColumn2, HTuple *hv_PrevWindowCoordinatesOut);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Visualize a point cloud and 3D gripping poses. 
void visualize_point_cloud_and_gripping_pose (HTuple hv_DLSample, HTuple hv_DLResult, 
    HTuple hv_GenParams, HTuple hv_WindowHandle);

// Procedures 
// Chapter: Image / Channel
void add_colormap_to_image (HObject ho_GrayValueImage, HObject ho_Image, HObject *ho_ColoredImage, 
    HTuple hv_HeatmapColorScheme)
{

  // Local iconic variables
  HObject  ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
  HObject  ho_Channel, ho_ChannelScaled, ho_ChannelScaledByte;
  HObject  ho_ImageByte, ho_ImageByteR, ho_ImageByteG, ho_ImageByteB;

  // Local control variables
  HTuple  hv_Type, hv_NumChannels, hv_ChannelIndex;
  HTuple  hv_ChannelMin, hv_ChannelMax, hv__;

  //
  //This procedure adds a gray-value image to a RGB image with a chosen color map.
  //
  GetImageType(ho_GrayValueImage, &hv_Type);
  //The image LUT needs a byte image. Rescale real images.
  if (0 != (int(hv_Type==HTuple("real"))))
  {
    scale_image_range(ho_GrayValueImage, &ho_GrayValueImage, 0, 1);
    ConvertImageType(ho_GrayValueImage, &ho_GrayValueImage, "byte");
  }
  else if (0 != (int(hv_Type!=HTuple("byte"))))
  {
    throw HException(HTuple("For this transformation, a byte or real image is needed!"));
  }
  //
  //Apply the chosen color scheme on the gray value.
  apply_colorscheme_on_gray_value_image(ho_GrayValueImage, &ho_RGBValueImage, hv_HeatmapColorScheme);
  //
  //Convert input image to byte image for visualization.
  ImageToChannels(ho_Image, &ho_Channels);
  CountChannels(ho_Image, &hv_NumChannels);
  GenEmptyObj(&ho_ChannelsScaled);
  {
  HTuple end_val19 = hv_NumChannels;
  HTuple step_val19 = 1;
  for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex += step_val19)
  {
    SelectObj(ho_Channels, &ho_Channel, hv_ChannelIndex);
    MinMaxGray(ho_Channel, ho_Channel, 0, &hv_ChannelMin, &hv_ChannelMax, &hv__);
    scale_image_range(ho_Channel, &ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
    ConvertImageType(ho_ChannelScaled, &ho_ChannelScaledByte, "byte");
    ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, &ho_ChannelsScaled);
  }
  }
  ChannelsToImage(ho_ChannelsScaled, &ho_ImageByte);
  //
  //Note that ImageByte needs to have the same number of channels as
  //RGBValueImage to display color map image correctly.
  CountChannels(ho_ImageByte, &hv_NumChannels);
  if (0 != (int(hv_NumChannels!=3)))
  {
    //Just take the first channel and use this to generate
    //an image with 3 channels for visualization.
    AccessChannel(ho_ImageByte, &ho_ImageByteR, 1);
    CopyImage(ho_ImageByteR, &ho_ImageByteG);
    CopyImage(ho_ImageByteR, &ho_ImageByteB);
    Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, &ho_ImageByte);
  }
  //
  AddImage(ho_ImageByte, ho_RGBValueImage, &ho_RGBValueImage, 0.5, 0);
  (*ho_ColoredImage) = ho_RGBValueImage;
  //
  return;
}

// Chapter: Image / Channel
// Short Description: Create a lookup table and convert a gray scale image. 
void apply_colorscheme_on_gray_value_image (HObject ho_InputImage, HObject *ho_ResultImage, 
    HTuple hv_Schema)
{

  // Local iconic variables
  HObject  ho_ImageR, ho_ImageG, ho_ImageB;

  // Local control variables
  HTuple  hv_X, hv_Low, hv_High, hv_OffR, hv_OffG;
  HTuple  hv_OffB, hv_A1, hv_A0, hv_R, hv_G, hv_B, hv_A0R;
  HTuple  hv_A0G, hv_A0B;

  //
  //This procedure generates an RGB ResultImage for a gray-value InputImage.
  //In order to do so, create a color distribution as look up table
  //according to the Schema.
  //
  hv_X = HTuple::TupleGenSequence(0,255,1);
  TupleGenConst(256, 0, &hv_Low);
  TupleGenConst(256, 255, &hv_High);
  //
  if (0 != (int(hv_Schema==HTuple("jet"))))
  {
    //Scheme Jet: from blue to red
    hv_OffR = 3.0*64.0;
    hv_OffG = 2.0*64.0;
    hv_OffB = 64.0;
    hv_A1 = -4.0;
    hv_A0 = 255.0+128.0;
    hv_R = (((((hv_X-hv_OffR).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_G = (((((hv_X-hv_OffG).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_B = (((((hv_X-hv_OffB).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    //
  }
  else if (0 != (int(hv_Schema==HTuple("inverse_jet"))))
  {
    //Scheme InvJet: from red to blue.
    hv_OffR = 64;
    hv_OffG = 2*64;
    hv_OffB = 3*64;
    hv_A1 = -4.0;
    hv_A0 = 255.0+128.0;
    hv_R = (((((hv_X-hv_OffR).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_G = (((((hv_X-hv_OffG).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_B = (((((hv_X-hv_OffB).TupleAbs())*hv_A1)+hv_A0).TupleMax2(hv_Low)).TupleMin2(hv_High);
    //
  }
  else if (0 != (int(hv_Schema==HTuple("hot"))))
  {
    //Scheme Hot.
    hv_A1 = 3.0;
    hv_A0R = 0.0;
    hv_A0G = ((1.0/3.0)*hv_A1)*255.0;
    hv_A0B = ((2.0/3.0)*hv_A1)*255.0;
    hv_R = (((hv_X*hv_A1)-hv_A0R).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_G = (((hv_X*hv_A1)-hv_A0G).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_B = (((hv_X*hv_A1)-hv_A0B).TupleMax2(hv_Low)).TupleMin2(hv_High);
    //
  }
  else if (0 != (int(hv_Schema==HTuple("inverse_hot"))))
  {
    //Scheme Inverse Hot.
    hv_A1 = -3.0;
    hv_A0R = hv_A1*255.0;
    hv_A0G = ((2.0/3.0)*hv_A1)*255.0;
    hv_A0B = ((1.0/3.0)*hv_A1)*255.0;
    hv_R = (((hv_X*hv_A1)-hv_A0R).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_G = (((hv_X*hv_A1)-hv_A0G).TupleMax2(hv_Low)).TupleMin2(hv_High);
    hv_B = (((hv_X*hv_A1)-hv_A0B).TupleMax2(hv_Low)).TupleMin2(hv_High);
    //
  }
  else
  {
    //
    throw HException(("Unknown color schema: "+hv_Schema)+".");
    //
  }
  //
  LutTrans(ho_InputImage, &ho_ImageR, hv_R);
  LutTrans(ho_InputImage, &ho_ImageG, hv_G);
  LutTrans(ho_InputImage, &ho_ImageB, hv_B);
  Compose3(ho_ImageR, ho_ImageG, ho_ImageB, &(*ho_ResultImage));
  //
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Visualize the results of an evaluation for a model of type 3D Gripping Point Detection. 
void dev_display_3d_gripping_point_detection_evaluation (HTuple hv_EvaluationResult, 
    HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MeasureColor, hv_RowColNameColor, hv_DisplayColor;
  HTuple  hv_GenParamKeys, hv_Keys, hv_KeyIndex, hv_KeyExists;
  HTuple  hv_Value, hv_RGB, hv_Exception, hv_KeysExist, hv_ClassIDs;
  HTuple  hv_ClassNames, hv_MaxChars, hv_Index, hv_Str, hv_IsString;
  HTuple  hv_Length, hv_SubStr, hv_MeasureKeys, hv_MeasureKeysExist;
  HTuple  hv_MeasureKeysSelected, hv_GenParamMeasures, hv_NumRows;
  HTuple  hv_RowNames, hv_Measures, hv_RowIndex, hv_WindowMeasuresExists;
  HTuple  hv_WindowHandleMeasures;

  //
  //This procedure visualizes the evaluation results for a model
  //of type 3D Gripping Point Detection.
  //
  //Set the default values.
  hv_MeasureColor = "white";
  hv_RowColNameColor = "light gray";
  hv_DisplayColor = 1;
  //
  //Handle the generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "measure_color";
    hv_GenParamKeys[1] = "row_col_names_color";
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_Keys);
    {
    HTuple end_val13 = (hv_Keys.TupleLength())-1;
    HTuple step_val13 = 1;
    for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val13, step_val13); hv_KeyIndex += step_val13)
    {
      if (0 != (int((hv_GenParamKeys.TupleFind(HTuple(hv_Keys[hv_KeyIndex])))==-1)))
      {
        throw HException(("Invalid GenParam key '"+HTuple(hv_Keys[hv_KeyIndex]))+"'");
      }
    }
    }
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //Set MeasureColor.
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[0]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'measure_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'measure_color' must be a valid color string");
      }
      hv_MeasureColor = hv_Value;
    }
    //Set color for row and column names.
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[1]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'row_col_names_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'row_col_names_color' must be a valid color string");
      }
      hv_RowColNameColor = hv_Value;
    }
  }
  //
  //Get the class names.
  GetDictParam(hv_EvalParam, "key_exists", (HTuple("class_names").Append("class_ids")), 
      &hv_KeysExist);
  if (0 != ((hv_KeysExist.TupleSum()).TupleNot()))
  {
    throw HException("EvalParam must contain at least one of the keys 'class_names' or 'class_ids'");
  }
  else if (0 != (HTuple(hv_KeysExist[0]).TupleNot()))
  {
    //If class names are not given, use class IDs instead.
    GetDictTuple(hv_EvalParam, "class_ids", &hv_ClassIDs);
    hv_ClassNames = "class_"+hv_ClassIDs;
  }
  else
  {
    //Get the class names from the EvalParam dict.
    GetDictTuple(hv_EvalParam, "class_names", &hv_ClassNames);
  }
  //
  //Cut class names for better visualization.
  if (0 != (int(hv_ClassNames!=HTuple())))
  {
    hv_MaxChars = 14;
    {
    HTuple end_val63 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val63 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val63, step_val63); hv_Index += step_val63)
    {
      hv_Str = HTuple(hv_ClassNames[hv_Index]);
      TupleIsString(hv_Str, &hv_IsString);
      if (0 != hv_IsString)
      {
        TupleStrlen(hv_Str, &hv_Length);
        if (0 != (int(hv_Length>hv_MaxChars)))
        {
          hv_SubStr = (hv_Str.TupleSubstr(0,hv_MaxChars-3))+"...";
          hv_ClassNames[hv_Index] = hv_SubStr;
        }
      }
    }
    }
  }
  //
  //Get some evaluation parameters.
  hv_MeasureKeys.Clear();
  hv_MeasureKeys[0] = "mean_pro";
  hv_MeasureKeys[1] = "mean_precision";
  hv_MeasureKeys[2] = "mean_iou";
  hv_MeasureKeys[3] = "gripping_point_precision";
  hv_MeasureKeys[4] = "gripping_point_recall";
  hv_MeasureKeys[5] = "gripping_point_f_score";
  GetDictParam(hv_EvaluationResult, "key_exists", hv_MeasureKeys, &hv_MeasureKeysExist);
  hv_MeasureKeysSelected = hv_MeasureKeys.TupleSelectMask(hv_MeasureKeysExist);
  //
  //Check the input evaluation results for necessary entries.
  if (0 != (int((hv_MeasureKeysSelected.TupleLength())==0)))
  {
    throw HException("There are no valid keys given in EvaluationResult.");
  }
  //
  //Set parameters for the visualization of measures.
  CreateDict(&hv_GenParamMeasures);
  SetDictTuple(hv_GenParamMeasures, "title", "Measures");
  SetDictTuple(hv_GenParamMeasures, "number_format", "0.3f");
  SetDictTuple(hv_GenParamMeasures, "display_column_width", "minimal");
  SetDictTuple(hv_GenParamMeasures, "display_color", 1);
  SetDictTuple(hv_GenParamMeasures, "value_colors", hv_MeasureColor);
  SetDictTuple(hv_GenParamMeasures, "row_col_names_color", hv_RowColNameColor);
  //
  //Visualize mean measures.
  hv_NumRows = hv_MeasureKeysSelected.TupleLength();
  hv_RowNames = hv_MeasureKeysSelected;
  CreateMatrix(hv_NumRows, 1, 0., &hv_Measures);
  {
  HTuple end_val99 = (hv_MeasureKeysSelected.TupleLength())-1;
  HTuple step_val99 = 1;
  for (hv_RowIndex=0; hv_RowIndex.Continue(end_val99, step_val99); hv_RowIndex += step_val99)
  {
    SetValueMatrix(hv_Measures, hv_RowIndex, 0, hv_EvaluationResult.TupleGetDictTuple(HTuple(hv_MeasureKeysSelected[hv_RowIndex])));
  }
  }
  //
  //Check if there is already a window handle.
  GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", &hv_WindowMeasuresExists);
  if (0 != hv_WindowMeasuresExists)
  {
    GetDictTuple(hv_WindowHandleDict, "window_measures", &hv_WindowHandleMeasures);
    HDevWindowStack::SetActive(hv_WindowHandleMeasures);
  }
  else
  {
    SetWindowAttr("background_color","black");
    OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleMeasures);
    HDevWindowStack::Push(hv_WindowHandleMeasures);
    SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
  }
  //
  dev_display_matrix(hv_Measures, hv_ClassNames, hv_RowNames, hv_WindowHandleMeasures, 
      hv_GenParamMeasures);
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display evaluation results of an evaluated DL model of type 'anomaly_detection' or 'gc_anomaly_detection'. 
void dev_display_anomaly_detection_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BackgroundColor, hv_OKColor, hv_OKColorPlot;
  HTuple  hv_NOKColor, hv_NOKColorPlot, hv_IntermediateColor;
  HTuple  hv_PredefinedColors, hv_EvaluationThresholds, hv_AdditionalThresholds;
  HTuple  hv_EvaluationThresholdIndex, hv_RowColNameColor;
  HTuple  hv_DisplayColumnWidth, hv_DisplayMatrixColor, hv_Font;
  HTuple  hv_FontSize, hv_HistogramLegendVerticalOffset, hv_NumXTicks;
  HTuple  hv_HistogramMin, hv_HistogramMax, hv_DisplayThresholds;
  HTuple  hv_DisplayScoreHistogram, hv_DisplayScoreLegend;
  HTuple  hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative;
  HTuple  hv_DisplayPieChartPrecision, hv_DisplayPieChartRecall;
  HTuple  hv_WindowRow, hv_WindowColumn, hv_WindowMaxColumn;
  HTuple  hv_WindowColumnSeparator, hv_GenParamKeys, hv_GenParamIndex;
  HTuple  hv_ThresholdValues, hv_DisplayMode, hv_DisplayAll;
  HTuple  hv_MinValue, hv_MaxValue, hv_CalculateHistogramMin;
  HTuple  hv_CalculateHistogramMax, hv_EvaluationType, hv_EvalThresholdsExist;
  HTuple  hv_DiffEpsilon, hv_RemoveIndices, hv_ThresholdIdx;
  HTuple  hv_MinThresholdDiff, hv_AllThresholds, hv_ThresholdColors;
  HTuple  hv_UseSpecificLegend, hv_RandomColors, hv_AnomalyScoreHistogram;
  HTuple  hv_Exception, hv_HistoOKXValues, hv_HistoOKYValues;
  HTuple  hv_HistoNOKXValues, hv_HistoNOKYValues, hv_AnomalyScores;
  HTuple  hv_HistogramWidthOK, hv_HistogramRangeWidth, hv_HistogramWidthNOK;
  HTuple  hv_MaxScore, hv_MinScore, hv_TicksX, hv_FormatX;
  HTuple  hv_OKMinY, hv_OKMinIndex, hv_NOKMaxY, hv_NOKMaxIndex;
  HTuple  hv_MaxY, hv_PlotOKXValues, hv_PlotOKYValues, hv_OKIndex;
  HTuple  hv_PlotNOKXValues, hv_PlotNOKYValues, hv_NOKIndex;
  HTuple  hv_WindowScoreHistogramExists, hv_WindowHandleScoreHistogram;
  HTuple  hv_FlushStateScoreHistogram, hv_Index, hv_Color;
  HTuple  hv_WindowHandle, hv__, hv_Width, hv_Height, hv_WindowScoreLegendExists;
  HTuple  hv_WindowHandleScoreLegend, hv_FlushStateScoreLegend;
  HTuple  hv_Offset, hv_RunningIndex, hv_ThresholdCaptions;
  HTuple  hv_WindowExists, hv_WindowHandlePrecision, hv_WindowHandleRecall;
  HTuple  hv_RowColumnNames, hv_ValueColors, hv_DiagonalColor;
  HTuple  hv_DiagonalIndices, hv_DisplayMatrices, hv_Strings;
  HTuple  hv_CapitalStrings, hv_TitelAdditions, hv_IndexMatrixToDisplay;
  HTuple  hv_ConfusionMatrixDictionaries, hv_ConfusionMatrixDictionary;
  HTuple  hv_ConfusionMatrix, hv_ThresholdValue, hv_ConfusionMatrixDisplay;
  HTuple  hv_ValuesRelative, hv_MatrixMaxID, hv_NumberFormat;
  HTuple  hv_WindowHandleConfusion;

  //
  //This procedure visualizes the evaluation results for models of
  //type 'anomaly_detection' or 'gc_anomaly_detection'.
  //
  //Set the default values.
  hv_BackgroundColor = "light gray";
  hv_OKColor = "#1354ad";
  hv_OKColorPlot = "#3e94d8";
  hv_NOKColor = "#ff3410";
  hv_NOKColorPlot = "#ff942e";
  hv_IntermediateColor = "#444444";
  hv_PredefinedColors.Clear();
  hv_PredefinedColors.Append(hv_OKColor);
  hv_PredefinedColors.Append(hv_NOKColor);
  hv_PredefinedColors.Append(hv_IntermediateColor);
  //
  hv_EvaluationThresholds = HTuple();
  hv_AdditionalThresholds = HTuple();
  hv_EvaluationThresholdIndex = -1;
  //
  hv_RowColNameColor = "light gray";
  hv_DisplayColumnWidth = "equal";
  hv_DisplayMatrixColor = 1;
  hv_Font = "mono";
  hv_FontSize = 14;
  //
  hv_HistogramLegendVerticalOffset = 50;
  hv_NumXTicks = 10;
  hv_HistogramMin = -1;
  hv_HistogramMax = -1;
  //
  hv_DisplayThresholds = 0;
  hv_DisplayScoreHistogram = 1;
  hv_DisplayScoreLegend = 1;
  hv_DisplayConfusionAbsolute = 0;
  hv_DisplayConfusionRelative = 0;
  hv_DisplayPieChartPrecision = 0;
  hv_DisplayPieChartRecall = 0;
  //
  //Parameters used for the window placements:
  hv_WindowRow = 0;
  hv_WindowColumn = 0;
  hv_WindowMaxColumn = 0;
  hv_WindowColumnSeparator = 8;
  //
  //Handle the generic parameters.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamKeys);
    {
    HTuple end_val45 = (hv_GenParamKeys.TupleLength())-1;
    HTuple step_val45 = 1;
    for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val45, step_val45); hv_GenParamIndex += step_val45)
    {
      if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("estimated_thresholds"))))
      {
        GetDictTuple(hv_GenParam, "estimated_thresholds", &hv_ThresholdValues);
        if (0 != (int((((hv_ThresholdValues.TupleIsIntElem())+(hv_ThresholdValues.TupleIsRealElem())).TupleFind(0))!=-1)))
        {
          throw HException("GenParam 'estimated_thresholds' must be numeric values");
        }
        if (0 != (int((hv_ThresholdValues.TupleLength())>3)))
        {
          throw HException("GenParam 'estimated_thresholds' must be of length 3 or less");
        }
        //
        hv_DisplayThresholds = 1;
        hv_AdditionalThresholds = hv_ThresholdValues;
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("display_mode"))))
      {
        hv_DisplayScoreHistogram = 0;
        hv_DisplayScoreLegend = 0;
        GetDictTuple(hv_GenParam, "display_mode", &hv_DisplayMode);
        hv_DisplayAll = HTuple(int((hv_DisplayMode.TupleFind("all"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
        if (0 != hv_DisplayAll)
        {
          hv_DisplayScoreHistogram = 1;
          hv_DisplayScoreLegend = 1;
          hv_DisplayConfusionAbsolute = 1;
          hv_DisplayConfusionRelative = 1;
          hv_DisplayPieChartPrecision = 1;
          hv_DisplayPieChartRecall = 1;
        }
        else
        {
          hv_DisplayScoreHistogram = HTuple(int((hv_DisplayMode.TupleFind("score_histogram"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
          hv_DisplayScoreLegend = HTuple(int((hv_DisplayMode.TupleFind("score_legend"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
          hv_DisplayConfusionAbsolute = HTuple(int((hv_DisplayMode.TupleFind("absolute_confusion_matrix"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
          hv_DisplayConfusionRelative = HTuple(int((hv_DisplayMode.TupleFind("relative_confusion_matrix"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
          hv_DisplayPieChartPrecision = HTuple(int((hv_DisplayMode.TupleFind("pie_charts_precision"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
          hv_DisplayPieChartRecall = HTuple(int((hv_DisplayMode.TupleFind("pie_charts_recall"))!=-1)).TupleAnd(int(hv_DisplayMode!=HTuple()));
        }
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("classification_threshold_index"))))
      {
        GetDictTuple(hv_GenParam, "classification_threshold_index", &hv_EvaluationThresholdIndex);
        if (0 != (HTuple((hv_EvaluationThresholdIndex.TupleIsInt()).TupleNot()).TupleOr(int((hv_EvaluationThresholdIndex.TupleLength())!=1))))
        {
          throw HException("GenParam 'classification_threshold_index' must be one integer value");
        }
        if (0 != (int(hv_EvaluationThresholdIndex<0)))
        {
          throw HException("GenParam 'classification_threshold_index' must be greater or equal 0");
        }
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("histogram_min"))))
      {
        GetDictTuple(hv_GenParam, "histogram_min", &hv_MinValue);
        if (0 != (int((hv_MinValue.TupleLength())!=1)))
        {
          throw HException("GenParam 'histogram_min' must be one value");
        }
        if (0 != (HTuple((hv_MinValue.TupleIsInt()).TupleOr(hv_MinValue.TupleIsReal())).TupleNot()))
        {
          throw HException("GenParam 'histogram_min' must be a numeric value");
        }
        hv_HistogramMin = hv_MinValue;
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("histogram_max"))))
      {
        GetDictTuple(hv_GenParam, "histogram_max", &hv_MaxValue);
        if (0 != (int((hv_MaxValue.TupleLength())!=1)))
        {
          throw HException("GenParam 'histogram_max' must be one value");
        }
        if (0 != (HTuple((hv_MaxValue.TupleIsInt()).TupleOr(hv_MaxValue.TupleIsReal())).TupleNot()))
        {
          throw HException("GenParam 'histogram_max' must be a numeric value");
        }
        hv_HistogramMax = hv_MaxValue;
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("row_col_names_color"))))
      {
        GetDictTuple(hv_GenParam, "row_col_names_color", &hv_RowColNameColor);
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("display_column_width"))))
      {
        GetDictTuple(hv_GenParam, "display_column_width", &hv_DisplayColumnWidth);
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("display_matrix_color"))))
      {
        GetDictTuple(hv_GenParam, "display_matrix_color", &hv_DisplayMatrixColor);
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("font"))))
      {
        GetDictTuple(hv_GenParam, "font", &hv_Font);
      }
      else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("font_size"))))
      {
        GetDictTuple(hv_GenParam, "font_size", &hv_FontSize);
      }
      else
      {
        throw HException(("Invalid GenParam key '"+HTuple(hv_GenParamKeys[hv_GenParamIndex]))+"'");
      }
    }
    }
  }
  //
  hv_CalculateHistogramMin = int(hv_HistogramMin==-1);
  hv_CalculateHistogramMax = int(hv_HistogramMax==-1);
  //
  //Check that evaluation type is correct.
  GetDictTuple(hv_EvalParam, "evaluation_type", &hv_EvaluationType);
  if (0 != (HTuple(int(hv_EvaluationType!=HTuple("anomaly_detection"))).TupleAnd(int(hv_EvaluationType!=HTuple("gc_anomaly_detection")))))
  {
    throw HException("Wrong evaluation type for display");
  }
  //
  //Get thresholds used for evaluation.
  GetDictParam(hv_EvalParam, "key_exists", "anomaly_classification_thresholds", &hv_EvalThresholdsExist);
  if (0 != hv_EvalThresholdsExist)
  {
    GetDictTuple(hv_EvalParam, "anomaly_classification_thresholds", &hv_EvaluationThresholds);
    if (0 != (int((hv_EvaluationThresholds.TupleLength())>0)))
    {
      hv_DisplayThresholds = 1;
      //If no threshold is set, use the last evaluation index as default.
      if (0 != (int(hv_EvaluationThresholdIndex==-1)))
      {
        hv_EvaluationThresholdIndex = (hv_EvaluationThresholds.TupleLength())-1;
      }
    }
    //Check that the set threshold index is valid.
    if (0 != (int(hv_EvaluationThresholdIndex>((hv_EvaluationThresholds.TupleLength())-1))))
    {
      throw HException("No evaluation available for 'classification_threshold_index': "+hv_EvaluationThresholdIndex);
    }
    //Remove extra thresholds in case they are already included in the evaluation.
    if (0 != (HTuple(int((hv_AdditionalThresholds.TupleLength())>0)).TupleAnd(int((hv_EvaluationThresholds.TupleLength())>0))))
    {
      hv_DiffEpsilon = 1e-7;
      hv_RemoveIndices = HTuple();
      {
      HTuple end_val147 = (hv_AdditionalThresholds.TupleLength())-1;
      HTuple step_val147 = 1;
      for (hv_ThresholdIdx=0; hv_ThresholdIdx.Continue(end_val147, step_val147); hv_ThresholdIdx += step_val147)
      {
        hv_MinThresholdDiff = ((hv_EvaluationThresholds-HTuple(hv_AdditionalThresholds[hv_ThresholdIdx])).TupleAbs()).TupleMin();
        if (0 != (int(hv_MinThresholdDiff<hv_DiffEpsilon)))
        {
          hv_RemoveIndices = hv_RemoveIndices.TupleConcat(hv_ThresholdIdx);
        }
      }
      }
      hv_AdditionalThresholds = hv_AdditionalThresholds.TupleRemove(hv_RemoveIndices);
    }
  }
  //
  hv_AllThresholds.Clear();
  hv_AllThresholds.Append(hv_EvaluationThresholds);
  hv_AllThresholds.Append(hv_AdditionalThresholds);
  //
  //Set colors for the thresholds.
  hv_ThresholdColors = HTuple();
  hv_UseSpecificLegend = 0;
  //In case the overall number of thresholds is exactly 3 (either passed as EvalParam
  //or GenParam), we assume that they are the ones calculated with
  //compute_dl_anomaly_thresholds and use the specific colors and legend.
  if (0 != (HTuple(int((hv_AllThresholds.TupleLength())==3)).TupleAnd(HTuple(int((hv_EvaluationThresholds.TupleLength())==0)).TupleOr(int((hv_AdditionalThresholds.TupleLength())==0)))))
  {
    hv_UseSpecificLegend = 1;
    hv_ThresholdColors = hv_PredefinedColors;
  }
  else if (0 != (int((hv_AllThresholds.TupleLength())!=0)))
  {
    //Get random colors to display thresholds.
    get_distinct_colors(hv_AllThresholds.TupleLength(), 0, 175, 250, &hv_RandomColors);
    if (0 != (int((hv_EvaluationThresholds.TupleLength())==3)))
    {
      hv_UseSpecificLegend = 1;
      hv_ThresholdColors.Clear();
      hv_ThresholdColors.Append(hv_PredefinedColors);
      hv_ThresholdColors.Append(hv_RandomColors);
    }
    else
    {
      hv_ThresholdColors = hv_RandomColors;
    }
  }
  //
  if (0 != hv_DisplayScoreHistogram)
  {
    //
    //Check if the anomaly score histogram is given.
    try
    {
      GetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", &hv_AnomalyScoreHistogram);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      throw HException("EvaluationResult must contain the anomaly score histogram.");
    }
    //Check if OK score x and y values exist.
    try
    {
      GetDictTuple(hv_AnomalyScoreHistogram, "ok_x", &hv_HistoOKXValues);
      GetDictTuple(hv_AnomalyScoreHistogram, "ok_y", &hv_HistoOKYValues);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      throw HException("AnomalyScoreHistogram must contain values for 'ok_x' and 'ok_y'.");
    }
    //Check if NOK score x and y values exist.
    try
    {
      GetDictTuple(hv_AnomalyScoreHistogram, "nok_x", &hv_HistoNOKXValues);
      GetDictTuple(hv_AnomalyScoreHistogram, "nok_y", &hv_HistoNOKYValues);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      throw HException("AnomalyScoreHistogram must contain values for 'nok_x' and 'nok_y'.");
    }
    //
    //Validate the histogram content.
    if (0 != (int((hv_HistoOKXValues.TupleLength())!=(hv_HistoOKYValues.TupleLength()))))
    {
      throw HException("Number of 'ok_x' values does not match number of 'ok_y' values.");
    }
    if (0 != (int((hv_HistoNOKXValues.TupleLength())!=(hv_HistoNOKYValues.TupleLength()))))
    {
      throw HException("Number of 'nok_x' values does not match number of 'nok_y' values.");
    }
    if (0 != (HTuple(int((hv_HistoOKXValues.TupleLength())==0)).TupleAnd(int((hv_HistoNOKXValues.TupleLength())==0))))
    {
      throw HException("No data for display");
    }
    //
    //In case the min or max histogram value is not specified, estimate it by
    //using min/max of the anomaly scores.
    hv_AnomalyScores.Clear();
    hv_AnomalyScores.Append(hv_HistoOKXValues);
    hv_AnomalyScores.Append(hv_HistoNOKXValues);
    //
    if (0 != hv_CalculateHistogramMin)
    {
      hv_HistogramMin = hv_AnomalyScores.TupleMin();
    }
    if (0 != hv_CalculateHistogramMax)
    {
      hv_HistogramMax = hv_AnomalyScores.TupleMax();
    }
    //
    //Check min and max values.
    if (0 != (int(hv_HistogramMin>=hv_HistogramMax)))
    {
      throw HException(((("Maximum histogram value needs to be greater than the minimum value. Current values: "+hv_HistogramMin)+HTuple(" (min), "))+hv_HistogramMax)+" (max).");
    }
    //
    //There are cases where the histogram does not look good if we simply set the
    //histogram min and max like we do above. In the following, we adapt the min
    //and max to make the histogram look better.
    //
    //Add 10% to the border for better boundary visualization.
    //Thus, you can see clearly when 100% FPR and 100% FNR are reached.
    //Also, the histogram should start at zero, if the anomaly scores are all positive.
    if (0 != hv_CalculateHistogramMin)
    {
      hv_HistogramMin = HTuple(0.0).TupleMin2(hv_HistogramMin-(0.1*(hv_HistogramMax-hv_HistogramMin)));
    }
    if (0 != hv_CalculateHistogramMax)
    {
      hv_HistogramMax += 0.1*(hv_HistogramMax-hv_HistogramMin);
    }
    //
    //There can be cases where the OK or the NOK values make up most of the histogram.
    //For example, let OK scores range from 0 to 0.05 and NOK values from 0.04 to 1.
    //In this case, the OK area will be very small, which might lead to wrong conclusions
    //about the ratio of OK and NOK images or the performance of the anomaly detection
    //or Global Context Anomaly Detection.
    //In the following, we adapt the histogram min and max so that the widths of the OK
    //and NOK areas make up at least a certain percentage of the total width.
    if (0 != (hv_CalculateHistogramMin.TupleAnd(int(hv_HistoOKXValues!=HTuple()))))
    {
      //Make sure that the distance between the histogram min and the maximum OK score
      //is large enough. We take the histogram min instead of the minimum OK score, because
      //the range of the OK area starts at the histogram min and not necessarily at the
      //minimum OK score (for example when the smallest anomaly score comes from a
      //NOK image).
      hv_HistogramWidthOK = (hv_HistoOKXValues.TupleMax())-hv_HistogramMin;
      hv_HistogramRangeWidth = hv_HistogramMax-hv_HistogramMin;
      if (0 != (int(hv_HistogramWidthOK<(0.15*hv_HistogramRangeWidth))))
      {
        hv_HistogramMin = (hv_HistoOKXValues.TupleMax())-(0.15*hv_HistogramRangeWidth);
      }
    }
    //
    if (0 != (hv_CalculateHistogramMax.TupleAnd(int(hv_HistoNOKXValues!=HTuple()))))
    {
      //Update the histogram max in the same way as the histogram min
      hv_HistogramWidthNOK = hv_HistogramMax-(hv_HistoNOKXValues.TupleMin());
      hv_HistogramRangeWidth = hv_HistogramMax-hv_HistogramMin;
      if (0 != (int(hv_HistogramWidthNOK<(0.15*hv_HistogramRangeWidth))))
      {
        hv_HistogramMax = (hv_HistoNOKXValues.TupleMin())+(0.15*hv_HistogramRangeWidth);
      }
    }
    //
    hv_MaxScore = hv_AnomalyScores.TupleMax();
    if (0 != (int(hv_HistogramMin>=hv_MaxScore)))
    {
      throw HException(((("Minimum histogram value ("+hv_HistogramMin)+") is larger than the highest score (")+hv_MaxScore)+").");
    }
    hv_MinScore = hv_AnomalyScores.TupleMin();
    if (0 != (int(hv_HistogramMax<=hv_MinScore)))
    {
      throw HException(((("Maximum histogram value ("+hv_HistogramMax)+") is smaller than the lowest score (")+hv_MinScore)+").");
    }
    //
    //Append HistogramMin/HistogramMax to histogram values if necessary.
    if (0 != (int((hv_HistoOKXValues.TupleLength())!=0)))
    {
      if (0 != (int(hv_HistogramMin<(hv_HistoOKXValues.TupleMin()))))
      {
        hv_HistoOKXValues = hv_HistogramMin.TupleConcat(hv_HistoOKXValues);
        hv_HistoOKYValues = HTuple(1.0).TupleConcat(hv_HistoOKYValues);
      }
    }
    if (0 != (int((hv_HistoNOKXValues.TupleLength())!=0)))
    {
      if (0 != (int(hv_HistogramMax>(hv_HistoNOKXValues.TupleMax()))))
      {
        hv_HistoNOKXValues = hv_HistoNOKXValues.TupleConcat(hv_HistogramMax);
        hv_HistoNOKYValues = hv_HistoNOKYValues.TupleConcat(1.0);
      }
    }
    //
    //Specify other plot parameters.
    hv_TicksX = ((hv_HistogramMax-hv_HistogramMin)/hv_NumXTicks).TupleReal();
    if (0 != (int(hv_HistogramMax>=10)))
    {
      hv_FormatX = ".1f";
    }
    else
    {
      hv_FormatX = ".2f";
    }
    //Find maximum y value to plot.
    hv_OKMinY = 0;
    hv_OKMinIndex = (hv_HistoOKXValues.TupleGreaterEqualElem(hv_HistogramMin)).TupleFindFirst(1);
    if (0 != (int(hv_OKMinIndex!=-1)))
    {
      hv_OKMinY = HTuple(hv_HistoOKYValues[hv_OKMinIndex]);
    }
    hv_NOKMaxY = 0;
    hv_NOKMaxIndex = (hv_HistoNOKXValues.TupleLessEqualElem(hv_HistogramMax)).TupleFindLast(1);
    if (0 != (int(hv_NOKMaxIndex!=-1)))
    {
      hv_NOKMaxY = HTuple(hv_HistoNOKYValues[hv_NOKMaxIndex]);
    }
    hv_MaxY = (hv_OKMinY.TupleConcat(hv_NOKMaxY)).TupleMax();
    //
    //Extend the histogram values so that they will be plotted as steps with the 'filled' style.
    hv_PlotOKXValues = HTuple();
    hv_PlotOKYValues = HTuple();
    if (0 != (int((hv_HistoOKXValues.TupleLength())!=0)))
    {
      {
      HTuple end_val319 = (hv_HistoOKXValues.TupleLength())-2;
      HTuple step_val319 = 1;
      for (hv_OKIndex=0; hv_OKIndex.Continue(end_val319, step_val319); hv_OKIndex += step_val319)
      {
        hv_PlotOKXValues = (hv_PlotOKXValues.TupleConcat(HTuple(hv_HistoOKXValues[hv_OKIndex]))).TupleConcat(HTuple(hv_HistoOKXValues[hv_OKIndex]));
        hv_PlotOKYValues = (hv_PlotOKYValues.TupleConcat(HTuple(hv_HistoOKYValues[hv_OKIndex]))).TupleConcat(HTuple(hv_HistoOKYValues[hv_OKIndex+1]));
      }
      }
      hv_PlotOKXValues = (hv_PlotOKXValues.TupleConcat(HTuple(hv_HistoOKXValues[hv_OKIndex]))).TupleConcat(HTuple(hv_HistoOKXValues[hv_OKIndex]));
      hv_PlotOKYValues = (hv_PlotOKYValues.TupleConcat(HTuple(hv_HistoOKYValues[hv_OKIndex]))).TupleConcat(0.0);
    }
    //
    hv_PlotNOKXValues = HTuple();
    hv_PlotNOKYValues = HTuple();
    if (0 != (int((hv_HistoNOKXValues.TupleLength())!=0)))
    {
      hv_PlotNOKXValues.Clear();
      hv_PlotNOKXValues.Append(HTuple(hv_HistoNOKXValues[0]));
      hv_PlotNOKXValues.Append(HTuple(hv_HistoNOKXValues[0]));
      hv_PlotNOKYValues.Clear();
      hv_PlotNOKYValues[0] = 0.0;
      hv_PlotNOKYValues.Append(HTuple(hv_HistoNOKYValues[0]));
      {
      HTuple end_val332 = (hv_HistoNOKXValues.TupleLength())-1;
      HTuple step_val332 = 1;
      for (hv_NOKIndex=1; hv_NOKIndex.Continue(end_val332, step_val332); hv_NOKIndex += step_val332)
      {
        hv_PlotNOKXValues = (hv_PlotNOKXValues.TupleConcat(HTuple(hv_HistoNOKXValues[hv_NOKIndex]))).TupleConcat(HTuple(hv_HistoNOKXValues[hv_NOKIndex]));
        hv_PlotNOKYValues = (hv_PlotNOKYValues.TupleConcat(HTuple(hv_HistoNOKYValues[hv_NOKIndex-1]))).TupleConcat(HTuple(hv_HistoNOKYValues[hv_NOKIndex]));
      }
      }
    }
    //
    //Create drawing window for histogram.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_score_histogram", &hv_WindowScoreHistogramExists);
    if (0 != (hv_WindowScoreHistogramExists.TupleNot()))
    {
      SetWindowAttr("background_color",hv_BackgroundColor);
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleScoreHistogram);
      HDevWindowStack::Push(hv_WindowHandleScoreHistogram);
      SetDictTuple(hv_WindowHandleDict, "window_score_histogram", hv_WindowHandleScoreHistogram);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_score_histogram", &hv_WindowHandleScoreHistogram);
    }
    GetWindowParam(hv_WindowHandleScoreHistogram, "flush", &hv_FlushStateScoreHistogram);
    SetWindowParam(hv_WindowHandleScoreHistogram, "flush", "false");
    //
    //Adapt fonts and background colors in the histogram.
    set_display_font(hv_WindowHandleScoreHistogram, 14, hv_Font, "true", "false");
    SetWindowParam(hv_WindowHandleScoreHistogram, "background_color", hv_BackgroundColor);
    //
    plot_tuple(hv_WindowHandleScoreHistogram, hv_PlotOKXValues, hv_PlotOKYValues, 
        "Score", "Fraction of wrongly classified images", hv_OKColorPlot+"80", ((((((((((HTuple("start_x").Append("end_x")).Append("start_y")).Append("end_y")).Append("ticks_x")).Append("ticks_y")).Append("axes_color")).Append("format_x")).Append("format_y")).Append("style")).Append("clip")), 
        ((((((hv_HistogramMin.TupleConcat(hv_HistogramMax)).TupleConcat(0.0)).TupleConcat(hv_MaxY+0.05)).TupleConcat(hv_TicksX)).TupleConcat((HTuple(0.1).Append("black")))).TupleConcat(hv_FormatX)).TupleConcat(((HTuple(".1f").Append("filled")).Append("yes"))));
    plot_tuple(hv_WindowHandleScoreHistogram, hv_PlotNOKXValues, hv_PlotNOKYValues, 
        HTuple(), HTuple(), hv_NOKColorPlot+"80", ((((((((HTuple("start_x").Append("end_x")).Append("start_y")).Append("end_y")).Append("ticks_x")).Append("ticks_y")).Append("axes_color")).Append("style")).Append("clip")), 
        (((hv_HistogramMin.TupleConcat(hv_HistogramMax)).TupleConcat(0.0)).TupleConcat(hv_MaxY+0.05)).TupleConcat(((((HTuple("none").Append("none")).Append("none")).Append("filled")).Append("yes"))));
    //
    //Plot thresholds from evaluation or generic parameters if given.
    if (0 != hv_DisplayThresholds)
    {
      {
      HTuple end_val358 = (hv_AllThresholds.TupleLength())-1;
      HTuple step_val358 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val358, step_val358); hv_Index += step_val358)
      {
        hv_Color = HTuple(hv_ThresholdColors[hv_Index]);
        plot_tuple(hv_WindowHandleScoreHistogram, HTuple(hv_AllThresholds[hv_Index]).TupleConcat(HTuple(hv_AllThresholds[hv_Index])), 
            HTuple(0.0).TupleConcat(hv_MaxY), HTuple(), HTuple(), hv_Color, (((((((HTuple("start_x").Append("end_x")).Append("start_y")).Append("end_y")).Append("ticks_x")).Append("ticks_y")).Append("axes_color")).Append("clip")), 
            (((hv_HistogramMin.TupleConcat(hv_HistogramMax)).TupleConcat(0.0)).TupleConcat(hv_MaxY+0.05)).TupleConcat((((HTuple("none").Append("none")).Append("none")).Append("yes"))));
      }
      }
    }
    //
    //Recalculate Window Coordinates for the following plots.
    GetDictTuple(hv_WindowHandleDict, "window_score_histogram", &hv_WindowHandle);
    GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_Width, &hv_Height);
    //Next plots will be shown on the right of the histograms.
    hv_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(hv_Width);
    hv_WindowRow = 0;
    hv_WindowColumn = (hv_WindowColumn+hv_WindowMaxColumn)+hv_WindowColumnSeparator;
    hv_WindowMaxColumn = 0;
    //
    FlushBuffer(hv_WindowHandleScoreHistogram);
    SetWindowParam(hv_WindowHandleScoreHistogram, "flush", hv_FlushStateScoreHistogram);
  }
  //
  //Plot histogram legend.
  if (0 != hv_DisplayScoreLegend)
  {
    //Create drawing window for legend.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_score_legend", &hv_WindowScoreLegendExists);
    if (0 != (hv_WindowScoreLegendExists.TupleNot()))
    {
      SetWindowAttr("background_color",hv_BackgroundColor);
      OpenWindow(hv_WindowRow,hv_WindowColumn,320,512,0,"visible","",&hv_WindowHandleScoreLegend);
      HDevWindowStack::Push(hv_WindowHandleScoreLegend);
      SetDictTuple(hv_WindowHandleDict, "window_score_legend", hv_WindowHandleScoreLegend);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_score_legend", &hv_WindowHandleScoreLegend);
    }
    //Adapt fonts and background colors in the histogram.
    HDevWindowStack::SetActive(hv_WindowHandleScoreLegend);
    GetWindowParam(hv_WindowHandleScoreLegend, "flush", &hv_FlushStateScoreLegend);
    SetWindowParam(hv_WindowHandleScoreLegend, "flush", "false");
    //
    HDevWindowStack::SetActive(hv_WindowHandleScoreLegend);
    SetWindowParam(hv_WindowHandleScoreLegend, "background_color", hv_BackgroundColor);
    set_display_font(hv_WindowHandleScoreLegend, hv_FontSize, hv_Font, "true", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"Area graphs", "image", 10+hv_HistogramLegendVerticalOffset, 
          5, "black", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"OK", "image", 35+hv_HistogramLegendVerticalOffset, 
          20, hv_OKColorPlot, "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"NOK", "image", 60+hv_HistogramLegendVerticalOffset, 
          20, hv_NOKColorPlot, "box", "false");
    //
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"Thresholds", "image", 100+hv_HistogramLegendVerticalOffset, 
          5, "black", "box", "false");
    if (0 != hv_DisplayThresholds)
    {
      hv_Offset = 25;
      hv_RunningIndex = 0;
      if (0 != hv_UseSpecificLegend)
      {
        hv_ThresholdCaptions.Clear();
        hv_ThresholdCaptions[0] = "No wrongly classified OK images";
        hv_ThresholdCaptions[1] = "No wrongly classified NOK images";
        hv_ThresholdCaptions[2] = "Minimal sum of OK and NOK fractions";
        for (hv_Index=0; hv_Index<=2; hv_Index+=1)
        {
          hv_Color = HTuple(hv_ThresholdColors[hv_Index]);
          if (HDevWindowStack::IsOpen())
            DispText(HDevWindowStack::GetActive(),HTuple(hv_ThresholdCaptions[hv_Index]), 
                "image", (125+hv_HistogramLegendVerticalOffset)+(hv_Index*hv_Offset), 
                20, hv_Color, "box", "false");
        }
        hv_RunningIndex = 3;
      }
      {
      HTuple end_val411 = (hv_AllThresholds.TupleLength())-1;
      HTuple step_val411 = 1;
      for (hv_Index=hv_RunningIndex; hv_Index.Continue(end_val411, step_val411); hv_Index += step_val411)
      {
        hv_Color = HTuple(hv_ThresholdColors[hv_Index]);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"Threshold "+(hv_Index+1), "image", 
              (125+hv_HistogramLegendVerticalOffset)+(hv_Index*hv_Offset), 20, hv_Color, 
              "box", "false");
      }
      }
    }
    else
    {
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),"None available for display", "image", 
            125+hv_HistogramLegendVerticalOffset, 20, "black", "box", "false");
    }
    //
    //Recalculate Window Coordinates for the following plots.
    GetDictTuple(hv_WindowHandleDict, "window_score_legend", &hv_WindowHandle);
    GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_Width, &hv_Height);
    hv_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(hv_Width);
    hv_WindowColumn = (hv_WindowColumn+hv_WindowMaxColumn)+hv_WindowColumnSeparator;
    hv_WindowRow = 0;
    hv_WindowMaxColumn = 0;
    FlushBuffer(hv_WindowHandleScoreLegend);
    SetWindowParam(hv_WindowHandleScoreLegend, "flush", hv_FlushStateScoreLegend);
  }
  //
  //Visualization of precision pie charts.
  if (0 != hv_DisplayPieChartPrecision)
  {
    //
    //Check if there is already a window handle.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_precision", 
        &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandlePrecision);
      HDevWindowStack::Push(hv_WindowHandlePrecision);
      SetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision", hv_WindowHandlePrecision);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision", &hv_WindowHandlePrecision);
    }
    //
    //Display.
    set_display_font(hv_WindowHandlePrecision, hv_FontSize, hv_Font, "true", "false");
    dev_display_anomaly_evaluation_pie_chart(hv_WindowHandlePrecision, hv_EvaluationResult, 
        "precision", hv_EvaluationThresholdIndex);
    //
    GetWindowExtents(hv_WindowHandlePrecision, &hv__, &hv__, &hv_Width, &hv_Height);
    HDevWindowStack::SetActive(hv_WindowHandlePrecision);
    if (HDevWindowStack::IsOpen())
      SetWindowExtents(HDevWindowStack::GetActive(),hv_WindowRow, hv_WindowColumn, 
          hv_Width, hv_Height);
    hv_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(hv_Width);
    hv_WindowRow = (hv_WindowRow+hv_Height)+55;
  }
  //
  // Visualization of recall pie charts.
  if (0 != hv_DisplayPieChartRecall)
  {
    //
    //Check if there is already a window handle.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_recall", &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleRecall);
      HDevWindowStack::Push(hv_WindowHandleRecall);
      SetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall", hv_WindowHandleRecall);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall", &hv_WindowHandleRecall);
    }
    //Display.
    set_display_font(hv_WindowHandleRecall, hv_FontSize, hv_Font, "true", "false");
    dev_display_anomaly_evaluation_pie_chart(hv_WindowHandleRecall, hv_EvaluationResult, 
        "recall", hv_EvaluationThresholdIndex);
    //Recalculate Window Coordinates for the following plots.
    GetWindowExtents(hv_WindowHandleRecall, &hv__, &hv__, &hv_Width, &hv_Height);
    HDevWindowStack::SetActive(hv_WindowHandleRecall);
    if (HDevWindowStack::IsOpen())
      SetWindowExtents(HDevWindowStack::GetActive(),hv_WindowRow, hv_WindowColumn, 
          hv_Width, hv_Height);
    hv_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(hv_Width);
    hv_WindowRow = (hv_WindowRow+hv_Height)+55;
  }
  //
  //Set window coordinates in order to display in a new column.
  hv_WindowRow = 0;
  hv_WindowColumn = (hv_WindowColumn+hv_WindowMaxColumn)+hv_WindowColumnSeparator;
  hv_WindowMaxColumn = 0;
  //
  //Visualization of confusion matrices.
  if (0 != (hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)))
  {
    //Set general generic parameters for dev_display_matrix.
    CreateDict(&hv_GenParam);
    SetDictTuple(hv_GenParam, "display_column_width", hv_DisplayColumnWidth);
    SetDictTuple(hv_GenParam, "display_color", hv_DisplayMatrixColor);
    SetDictTuple(hv_GenParam, "row_col_names_color", hv_RowColNameColor);
    SetDictTuple(hv_GenParam, "axis_titles", (HTuple("Ground truth").Append("Predicted")));
    //Set row and column names.
    GetDictTuple(hv_EvalParam, "class_names", &hv_RowColumnNames);
    if (0 != (int(hv_DisplayMatrixColor==1)))
    {
      //Display off-diagonal values in red.
      hv_ValueColors = HTuple(4,"#ff4500");
      //Display diagonal values in green.
      hv_DiagonalColor = "#00ff00";
      //Matrix entries get indices numbered as following:
      //a(1,1), a(1,2), ..., a(1,n), a(2,1), a(2,2), ... , a(2,n), ... a(m,1), a(m,2), ..., a(m,n)
      hv_DiagonalIndices.Clear();
      hv_DiagonalIndices[0] = 0;
      hv_DiagonalIndices[1] = 3;
      hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
      SetDictTuple(hv_GenParam, "value_colors", hv_ValueColors);
    }
    //
    //Display confusion matrices.
    hv_DisplayMatrices.Clear();
    hv_DisplayMatrices.Append(hv_DisplayConfusionAbsolute);
    hv_DisplayMatrices.Append(hv_DisplayConfusionRelative);
    hv_Strings.Clear();
    hv_Strings[0] = "absolute";
    hv_Strings[1] = "relative";
    hv_CapitalStrings.Clear();
    hv_CapitalStrings[0] = "Absolute";
    hv_CapitalStrings[1] = "Relative";
    hv_TitelAdditions.Clear();
    hv_TitelAdditions[0] = "    ";
    hv_TitelAdditions[1] = " [%]";
    //
    {
    HTuple end_val508 = (hv_DisplayMatrices.TupleLength())-1;
    HTuple step_val508 = 1;
    for (hv_IndexMatrixToDisplay=0; hv_IndexMatrixToDisplay.Continue(end_val508, step_val508); hv_IndexMatrixToDisplay += step_val508)
    {
      if (0 != (HTuple(hv_DisplayMatrices[hv_IndexMatrixToDisplay]).TupleNot()))
      {
        continue;
      }
      try
      {
        GetDictTuple(hv_EvaluationResult, HTuple(hv_Strings[hv_IndexMatrixToDisplay])+"_confusion_matrix", 
            &hv_ConfusionMatrixDictionaries);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException(("No evaluation available for "+HTuple(hv_Strings[hv_IndexMatrixToDisplay]))+" confusion matrix");
      }
      //Check that the specified index is valid.
      if (0 != (int(hv_EvaluationThresholdIndex>((hv_ConfusionMatrixDictionaries.TupleLength())-1))))
      {
        throw HException((("No "+HTuple(hv_Strings[hv_IndexMatrixToDisplay]))+" confusion matrix available for 'classification_threshold_index': ")+hv_EvaluationThresholdIndex);
      }
      hv_ConfusionMatrixDictionary = HTuple(hv_ConfusionMatrixDictionaries[hv_EvaluationThresholdIndex]);
      //
      GetDictTuple(hv_ConfusionMatrixDictionary, "confusion_matrix", &hv_ConfusionMatrix);
      GetDictTuple(hv_ConfusionMatrixDictionary, "threshold", &hv_ThresholdValue);
      //
      SetDictTuple(hv_GenParam, "title", (HTuple(hv_CapitalStrings[hv_IndexMatrixToDisplay])+" confusion matrix")+HTuple(hv_TitelAdditions[hv_IndexMatrixToDisplay]));
      SetDictTuple(hv_GenParam, "subtitle", "Threshold: "+hv_ThresholdValue);
      //
      //Copy matrix for display since it might need to be adapted.
      CopyMatrix(hv_ConfusionMatrix, &hv_ConfusionMatrixDisplay);
      //Convert relative matrix values to percent.
      if (0 != (int(HTuple(hv_Strings[hv_IndexMatrixToDisplay])==HTuple("relative"))))
      {
        GetFullMatrix(hv_ConfusionMatrixDisplay, &hv_ValuesRelative);
        SetFullMatrix(hv_ConfusionMatrixDisplay, 100*hv_ValuesRelative);
      }
      //Calculate proper number format.
      MaxMatrix(hv_ConfusionMatrixDisplay, "full", &hv_MatrixMaxID);
      GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
      if (0 != (int(hv_MaxValue>0)))
      {
        hv_NumberFormat = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
      }
      else
      {
        hv_NumberFormat = "1.0f";
      }
      SetDictTuple(hv_GenParam, "number_format", hv_NumberFormat);
      //
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", ("window_"+HTuple(hv_Strings[hv_IndexMatrixToDisplay]))+"_confusion_matrix", 
          &hv_WindowExists);
      if (0 != (hv_WindowExists.TupleNot()))
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleConfusion);
        HDevWindowStack::Push(hv_WindowHandleConfusion);
        SetDictTuple(hv_WindowHandleDict, ("window_"+HTuple(hv_Strings[hv_IndexMatrixToDisplay]))+"_confusion_matrix", 
            hv_WindowHandleConfusion);
      }
      else
      {
        GetDictTuple(hv_WindowHandleDict, ("window_"+HTuple(hv_Strings[hv_IndexMatrixToDisplay]))+"_confusion_matrix", 
            &hv_WindowHandleConfusion);
      }
      //
      //Display.
      set_display_font(hv_WindowHandleConfusion, hv_FontSize, hv_Font, "true", "false");
      dev_display_matrix(hv_ConfusionMatrixDisplay, hv_RowColumnNames, hv_RowColumnNames, 
          hv_WindowHandleConfusion, hv_GenParam);
      //Recalculate Window Coordinates for the following plots.
      GetWindowExtents(hv_WindowHandleConfusion, &hv__, &hv__, &hv_Width, &hv_Height);
      HDevWindowStack::SetActive(hv_WindowHandleConfusion);
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),hv_WindowRow, hv_WindowColumn, 
            hv_Width, hv_Height+15);
      hv_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(hv_Width);
      hv_WindowRow = (hv_WindowRow+hv_Height)+55;
    }
    }
  }
  //
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display pie charts for prediction or recall of an anomaly detection or Global Context Anomaly Detection evaluation. 
void dev_display_anomaly_evaluation_pie_chart (HTuple hv_WindowHandle, HTuple hv_EvaluationResult, 
    HTuple hv_Mode, HTuple hv_ThresholdIndex)
{

  // Local iconic variables
  HObject  ho_Image;

  // Local control variables
  HTuple  hv_FlushValue, hv_CenterRowOverall, hv_CenterColOverall;
  HTuple  hv_RadiusOverall, hv_RadiusClass, hv_ChartRowDistance;
  HTuple  hv_ChartColDistance, hv_StartRow, hv_StartCol, hv_KeyToPlot;
  HTuple  hv_KeyExists, hv_NumClassCharts, hv_Measures, hv_AllMeanValues;
  HTuple  hv_AllValuesPerClass, hv_MeanValue, hv_ValuesPerClass;
  HTuple  hv_MainTitle, hv_ClassTitles, hv_WindowWidth, hv_WindowHeight;
  HTuple  hv_Colors, hv_ColorDataUnavailable, hv_GenParamPieChart;
  HTuple  hv_Description, hv_PercentStr, hv_Index, hv_CenterRow;
  HTuple  hv_CenterCol;

  //
  //This procedure plots pie charts for precision and recall.
  //More detailed, the mean over all classes that have been used for
  //evaluation and the values for each class are plotted.
  //
  //Switch off automatic flushing to make visualization smooth.
  GetWindowParam(hv_WindowHandle, "flush", &hv_FlushValue);
  SetWindowParam(hv_WindowHandle, "flush", "false");
  //Drawing parameters.
  //Overall pie-chart.
  hv_CenterRowOverall = 150;
  hv_CenterColOverall = 150;
  hv_RadiusOverall = 100;
  //Per-class pie-chart.
  hv_RadiusClass = 40;
  hv_ChartRowDistance = 3*hv_RadiusClass;
  hv_ChartColDistance = 2.5*hv_RadiusClass;
  hv_StartRow = (hv_CenterRowOverall+(1.5*hv_RadiusOverall))+(1.5*hv_RadiusClass);
  hv_StartCol = 1.5*hv_RadiusClass;
  //
  //Get values.
  hv_KeyToPlot = "global_evaluation";
  GetDictParam(hv_EvaluationResult, "key_exists", hv_KeyToPlot, &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    hv_NumClassCharts = 2;
    GetDictTuple(hv_EvaluationResult, hv_KeyToPlot, &hv_Measures);
    GetDictTuple(hv_Measures, "mean_"+hv_Mode, &hv_AllMeanValues);
    GetDictTuple(hv_Measures, hv_Mode+"_per_class", &hv_AllValuesPerClass);
    //Check that the specified index is valid.
    if (0 != (HTuple(int(hv_ThresholdIndex>((hv_AllMeanValues.TupleLength())-1))).TupleOr(int(hv_ThresholdIndex>(((hv_AllValuesPerClass.TupleLength())/2)-1)))))
    {
      throw HException((("No "+hv_Mode)+" values available for 'classification_threshold_index': ")+hv_ThresholdIndex);
    }
    hv_MeanValue = HTuple(hv_AllMeanValues[hv_ThresholdIndex]);
    hv_ValuesPerClass = hv_AllValuesPerClass.TupleSelectRange(hv_ThresholdIndex*2,(hv_ThresholdIndex*2)+1);
    hv_MainTitle = "Mean class "+hv_Mode;
    hv_ClassTitles.Clear();
    hv_ClassTitles[0] = "ok";
    hv_ClassTitles[1] = "nok";
  }
  else
  {
    throw HException(((("The dictionary EvaluationResult needs a key '"+hv_KeyToPlot)+"' with the ")+hv_Mode)+" values.");
  }
  //
  //Open Window and set font.
  hv_WindowWidth = HTuple(550).TupleMax2(((hv_NumClassCharts-1)*hv_ChartColDistance)+(2*hv_StartCol));
  hv_WindowHeight = (3*hv_RadiusOverall)+(3*hv_RadiusClass);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),0, 0, hv_WindowWidth, hv_WindowHeight);
  GenImageConst(&ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //
  //Draw the pie-chart.
  hv_Colors.Clear();
  hv_Colors[0] = "green";
  hv_Colors[1] = "red";
  hv_ColorDataUnavailable = "gray";
  CreateDict(&hv_GenParamPieChart);
  SetDictTuple(hv_GenParamPieChart, "title", hv_MainTitle);
  dev_display_pie_chart(hv_WindowHandle, hv_MeanValue.TupleConcat(1.0-hv_MeanValue), 
      hv_CenterRowOverall, hv_CenterColOverall, hv_RadiusOverall, hv_Colors, hv_GenParamPieChart);
  //
  //Write description for pie chart.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Results: ", "image", 20, (hv_CenterColOverall+hv_RadiusOverall)+20, 
        "white", "box", "false");
  if (0 != (int(hv_Mode==HTuple("precision"))))
  {
    hv_Description.Clear();
    hv_Description[0] = "precision (TP / (TP + FP))";
    hv_Description[1] = "false positives";
  }
  else if (0 != (int(hv_Mode==HTuple("recall"))))
  {
    hv_Description.Clear();
    hv_Description[0] = "recall (TP / (TP + FN))";
    hv_Description[1] = "false negatives";
  }
  else
  {
    throw HException("Mode not supported: "+hv_Mode);
  }
  hv_PercentStr = (((hv_MeanValue.TupleConcat(1.0-hv_MeanValue))*100).TupleString(".1f"))+"";
  {
  HTuple end_val66 = (hv_Description.TupleLength())-1;
  HTuple step_val66 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val66, step_val66); hv_Index += step_val66)
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),(HTuple(hv_PercentStr[hv_Index])+"%: ")+HTuple(hv_Description[hv_Index]), 
          "image", 30+((hv_Index+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
          HTuple(hv_Colors[hv_Index]), "box", "false");
  }
  }
  //
  //Per class pie charts.
  {
  HTuple end_val71 = hv_NumClassCharts-1;
  HTuple step_val71 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val71, step_val71); hv_Index += step_val71)
  {
    //Get the position of the class-pie-chart.
    hv_CenterRow = hv_StartRow+((((hv_Index.TupleReal())/2).TupleFloor())*hv_ChartRowDistance);
    hv_CenterCol = hv_StartCol+((hv_Index%2)*hv_ChartColDistance);
    SetDictTuple(hv_GenParamPieChart, "title", HTuple(hv_ClassTitles[hv_Index]));
    if (0 != (int(HTuple(hv_ValuesPerClass[hv_Index])>=0)))
    {
      dev_display_pie_chart(hv_WindowHandle, HTuple(hv_ValuesPerClass[hv_Index]).TupleConcat(1.0-HTuple(hv_ValuesPerClass[hv_Index])), 
          hv_CenterRow, hv_CenterCol, hv_RadiusClass, hv_Colors, hv_GenParamPieChart);
    }
    else
    {
      //No evaluation data was available for this class.
      dev_display_pie_chart(hv_WindowHandle, 1.0, hv_CenterRow, hv_CenterCol, hv_RadiusClass, 
          hv_ColorDataUnavailable, hv_GenParamPieChart);
    }
  }
  }
  //
  //Flush buffer and reset value for 'flush'.
  FlushBuffer(hv_WindowHandle);
  SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Display evaluation results of an evaluated DL model of type 'classification'. 
void dev_display_classification_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayMeasures, hv_DisplayConfusionAbsolute;
  HTuple  hv_DisplayConfusionRelative, hv_DisplayPieChartPrecision;
  HTuple  hv_DisplayPieChartRecall, hv_MeasureColor, hv_RowColNameColor;
  HTuple  hv_DisplayColumnWidth, hv_DisplayColor, hv_Font;
  HTuple  hv_FontSize, hv_GenParamKeys, hv_Keys, hv_KeyIndex;
  HTuple  hv_KeyExists, hv_Value, hv_RGB, hv_Exception, hv_DisplayColumnWidthTmp;
  HTuple  hv_KeysExist, hv_ClassIDs, hv_ClassNames, hv_MaxChars;
  HTuple  hv_Index, hv_Str, hv_IsString, hv_Length, hv_SubStr;
  HTuple  hv_ClassIDsToNamesMapping, hv_AllowedKeyEntries;
  HTuple  hv_KeyClasses, hv_RowNames, hv_Indices, hv_Matches;
  HTuple  hv_EvaluatedClass, hv_KeyEvaluations, hv_TopKErrors;
  HTuple  hv_MatchesLength, hv_OffSet, hv_FScoreIndex, hv_ColumnNames;
  HTuple  hv_MatrixID, hv_RowIndex, hv_Dict, hv_ColumnIndex;
  HTuple  hv_WindowExists, hv_WindowHandleMeasures, hv_ValueColors;
  HTuple  hv_DiagonalColor, hv_Seq, hv_DiagonalIndices, hv_RowColumnNames;
  HTuple  hv_Booleans, hv_Strings, hv_KapitalStrings, hv_ConfusionMatrix;
  HTuple  hv_ValuesRelative, hv_MatrixMaxID, hv_MaxValue;
  HTuple  hv_NumberFormat, hv_WindowHandleConfusion, hv_WindowHandlePrecision;
  HTuple  hv_WindowKeys, hv_DisplayBooleans, hv_WindowHandleKeyNames;
  HTuple  hv_Row, hv_Column, hv_MaxColumn, hv_WindowHandle;
  HTuple  hv__, hv_Width, hv_Height;

  //
  //This procedure visualizes the evaluation results for a model of type classification.
  //
  //Set the default values.
  hv_DisplayMeasures = 1;
  hv_DisplayConfusionAbsolute = 0;
  hv_DisplayConfusionRelative = 0;
  hv_DisplayPieChartPrecision = 0;
  hv_DisplayPieChartRecall = 0;
  hv_MeasureColor = "white";
  hv_RowColNameColor = "light gray";
  hv_DisplayColumnWidth = "equal";
  hv_DisplayColor = 1;
  hv_Font = "mono";
  hv_FontSize = 14;
  //
  //Handle the generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "display_mode";
    hv_GenParamKeys[1] = "measure_color";
    hv_GenParamKeys[2] = "row_col_names_color";
    hv_GenParamKeys[3] = "display_column_width";
    hv_GenParamKeys[4] = "display_color";
    hv_GenParamKeys[5] = "font";
    hv_GenParamKeys[6] = "font_size";
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_Keys);
    {
    HTuple end_val20 = (hv_Keys.TupleLength())-1;
    HTuple step_val20 = 1;
    for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val20, step_val20); hv_KeyIndex += step_val20)
    {
      if (0 != (int((hv_GenParamKeys.TupleFind(HTuple(hv_Keys[hv_KeyIndex])))==-1)))
      {
        throw HException(("Invalid GenParam key '"+HTuple(hv_Keys[hv_KeyIndex]))+"'");
      }
    }
    }
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //Set display mode.
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[0]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())==0)))
      {
        throw HException("GenParam key 'display_mode' cannot be an empty tuple");
      }
      else
      {
        //Display measures.
        hv_DisplayMeasures = hv_Value.TupleFind("measures");
        hv_DisplayMeasures = HTuple(int((hv_DisplayMeasures.TupleLength())>0)).TupleAnd(int(hv_DisplayMeasures!=-1));
        //Display absolute confusion matrix.
        hv_DisplayConfusionAbsolute = hv_Value.TupleFind("absolute_confusion_matrix");
        hv_DisplayConfusionAbsolute = HTuple(int((hv_DisplayConfusionAbsolute.TupleLength())>0)).TupleAnd(int(hv_DisplayConfusionAbsolute!=-1));
        //Display relative confusion matrix.
        hv_DisplayConfusionRelative = hv_Value.TupleFind("relative_confusion_matrix");
        hv_DisplayConfusionRelative = HTuple(int((hv_DisplayConfusionRelative.TupleLength())>0)).TupleAnd(int(hv_DisplayConfusionRelative!=-1));
        //Display pie charts precision.
        hv_DisplayPieChartPrecision = hv_Value.TupleFind("pie_charts_precision");
        hv_DisplayPieChartPrecision = HTuple(int((hv_DisplayPieChartPrecision.TupleLength())>0)).TupleAnd(int(hv_DisplayPieChartPrecision!=-1));
        //Display pie charts recall.
        hv_DisplayPieChartRecall = hv_Value.TupleFind("pie_charts_recall");
        hv_DisplayPieChartRecall = HTuple(int((hv_DisplayPieChartRecall.TupleLength())>0)).TupleAnd(int(hv_DisplayPieChartRecall!=-1));
        //
        if (0 != (int((((((hv_DisplayMeasures.TupleConcat(hv_DisplayConfusionAbsolute)).TupleConcat(hv_DisplayConfusionRelative)).TupleConcat(hv_DisplayPieChartPrecision)).TupleConcat(hv_DisplayPieChartRecall)).TupleSum())!=(hv_Value.TupleLength()))))
        {
          throw HException("'display_mode' not supported.");
        }
      }
    }
    //Set MeasureColor (only for display_mode 'measures').
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[1]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'measure_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'measure_color' must be a valid color string");
      }
      hv_MeasureColor = hv_Value;
    }
    //Set color for row and column names.
    if (0 != (HTuple(hv_KeyExists[2])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[2]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'row_col_names_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'row_col_names_color' must be a valid color string");
      }
      hv_RowColNameColor = hv_Value;
    }
    //Set value for displaying column width.
    if (0 != (HTuple(hv_KeyExists[3])))
    {
      GetDictTuple(hv_GenParam, "display_column_width", &hv_DisplayColumnWidthTmp);
      if (0 != (HTuple(int((hv_DisplayColumnWidthTmp.TupleLength())!=1)).TupleOr(int(((HTuple("equal").Append("minimal")).TupleFind(hv_DisplayColumnWidthTmp))==-1))))
      {
        throw HException("Invalid value for 'display_column_width'");
      }
      else
      {
        hv_DisplayColumnWidth = hv_DisplayColumnWidthTmp;
      }
    }
    //Set display_color (only for confusion matrix).
    if (0 != (HTuple(hv_KeyExists[4])))
    {
      GetDictTuple(hv_GenParam, "display_color", &hv_DisplayColor);
      if (0 != (HTuple(int((hv_DisplayColor.TupleLength())!=1)).TupleOr(int(((HTuple("true").Append("false")).TupleFind(hv_DisplayColor))==-1))))
      {
        throw HException("Invalid value for 'display_color'");
      }
      else
      {
        if (0 != (int(hv_DisplayColor==HTuple("true"))))
        {
          hv_DisplayColor = 1;
        }
        else
        {
          hv_DisplayColor = 0;
        }
      }
    }
    //Set font (only available for 'measures' and confusion matrices).
    if (0 != (HTuple(hv_KeyExists[5])))
    {
      GetDictTuple(hv_GenParam, "font", &hv_Font);
    }
    //Set font size (only available for 'measures' and confusion matrices).
    if (0 != (HTuple(hv_KeyExists[6])))
    {
      GetDictTuple(hv_GenParam, "font_size", &hv_FontSize);
      if (0 != (HTuple(int(hv_FontSize<8)).TupleOr(int(hv_FontSize>64))))
      {
        throw HException(HTuple("Font size has to be in range of [8,64]"));
      }
    }
  }
  //
  //Check EvalParam and get the class names.
  try
  {
    GetDictParam(hv_EvalParam, "key_exists", (HTuple("class_names").Append("class_ids")), 
        &hv_KeysExist);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException("EvalParam has to be a dictionary");
  }
  if (0 != ((hv_KeysExist.TupleSum()).TupleNot()))
  {
    throw HException("EvalParam must contain at least one of the keys 'class_names' or 'class_ids'");
  }
  else if (0 != (HTuple(hv_KeysExist[0]).TupleNot()))
  {
    //If class names are not given, use class IDs instead.
    GetDictTuple(hv_EvalParam, "class_ids", &hv_ClassIDs);
    hv_ClassNames = "class_id_"+hv_ClassIDs;
  }
  else
  {
    //Get the class names from the EvalParam dict.
    GetDictTuple(hv_EvalParam, "class_names", &hv_ClassNames);
  }
  //
  //Cut class names for better visualization and get mapping between class IDs and class names.
  if (0 != (int(hv_ClassNames!=HTuple())))
  {
    //Cut class names.
    hv_MaxChars = 14;
    {
    HTuple end_val135 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val135 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val135, step_val135); hv_Index += step_val135)
    {
      hv_Str = HTuple(hv_ClassNames[hv_Index]);
      TupleIsString(hv_Str, &hv_IsString);
      if (0 != hv_IsString)
      {
        TupleStrlen(hv_Str, &hv_Length);
        if (0 != (int(hv_Length>hv_MaxChars)))
        {
          hv_SubStr = (hv_Str.TupleSubstr(0,hv_MaxChars-3))+"...";
          hv_ClassNames[hv_Index] = hv_SubStr;
        }
      }
    }
    }
    //Generate mapping.
    GetDictTuple(hv_EvalParam, "class_ids", &hv_ClassIDs);
    TupleGenConst(hv_ClassIDs.TupleMax(), -1, &hv_ClassIDsToNamesMapping);
    hv_ClassIDsToNamesMapping[hv_ClassIDs] = HTuple::TupleGenSequence(0,(hv_ClassIDs.TupleLength())-1,1);
  }
  //
  //Sanity check for EvaluationResult.
  try
  {
    GetDictParam(hv_EvaluationResult, "keys", HTuple(), &hv_Keys);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException("EvaluationResult has to be a dictionary");
  }
  hv_AllowedKeyEntries = "class_id_"+hv_ClassIDs;
  hv_AllowedKeyEntries = hv_AllowedKeyEntries.TupleConcat((((HTuple("absolute_confusion_matrix").Append("relative_confusion_matrix")).Append("global")).Append("evaluated_samples")));
  if (0 != (int((hv_Keys.TupleDifference(hv_AllowedKeyEntries))!=HTuple())))
  {
    throw HException("EvaluationResult only supports the following key entries: "+hv_AllowedKeyEntries);
  }
  //
  //Check if requested display modes are available.
  GetDictParam(hv_EvaluationResult, "key_exists", (HTuple("absolute_confusion_matrix").Append("relative_confusion_matrix")), 
      &hv_KeysExist);
  if (0 != (hv_DisplayConfusionAbsolute.TupleAnd(HTuple(hv_KeysExist[0]).TupleNot())))
  {
    throw HException("Key 'absolute_confusion_matrix' in EvaluationResult is needed to display absolute confusion matrix.\n Please run evaluate_dl_model with this key.");
  }
  if (0 != (hv_DisplayConfusionRelative.TupleAnd(HTuple(hv_KeysExist[1]).TupleNot())))
  {
    throw HException("Key 'relative_confusion_matrix' in EvaluationResult is needed to display relative confusion matrix.\n Please run evaluate_dl_model with this key.");
  }
  //
  //Display measures.
  if (0 != hv_DisplayMeasures)
  {
    //
    //For each entry in EvaluationResult except *_confusion_matrix, a row containing the measures is displayed.
    GetDictParam(hv_EvaluationResult, "keys", HTuple(), &hv_KeyClasses);
    hv_KeyClasses = hv_KeyClasses.TupleDifference(((HTuple("absolute_confusion_matrix").Append("relative_confusion_matrix")).Append("evaluated_samples")));
    if (0 != (int((hv_KeyClasses.TupleLength())==0)))
    {
      throw HException("To display 'measures' an evaluation for at least one class is needed");
    }
    if (0 != (int(hv_ClassNames!=HTuple())))
    {
      //Match class names for better readability.
      TupleGenConst(hv_KeyClasses.TupleLength(), "global", &hv_RowNames);
      hv_Indices = (hv_KeyClasses.TupleNotEqualElem("global")).TupleFind(1);
      if (0 != (int(hv_Indices!=-1)))
      {
        TupleRegexpMatch(HTuple(hv_KeyClasses[hv_Indices]), "class_id_(.*)", &hv_Matches);
        hv_Matches = hv_Matches.TupleNumber();
        hv_RowNames[hv_Indices] = HTuple(hv_ClassNames[HTuple(hv_ClassIDsToNamesMapping[hv_Matches.TupleInt()])]);
      }
    }
    else
    {
      TupleRegexpReplace(hv_KeyClasses, (HTuple("_").Append("replace_all")), " ", 
          &hv_RowNames);
    }
    //
    //Get all measures that can be displayed.
    GetDictTuple(hv_EvaluationResult, HTuple(hv_KeyClasses[0]), &hv_EvaluatedClass);
    GetDictParam(hv_EvaluatedClass, "keys", HTuple(), &hv_KeyEvaluations);
    TupleRegexpReplace(hv_KeyEvaluations, (HTuple("mean_").Append("replace_all")), 
        "", &hv_KeyEvaluations);
    //Throw away unneeded keys.
    TupleRegexpSelect(hv_KeyEvaluations, HTuple("top([0-9]{1,2})_error"), &hv_TopKErrors);
    hv_KeyEvaluations = hv_KeyEvaluations.TupleIntersection(hv_TopKErrors.TupleConcat(((HTuple("precision").Append("recall")).Append("f_score"))));
    //Sort the entries as follows: ['topK_error', 'precision', 'recall', 'f_score']
    TupleRegexpMatch(hv_KeyEvaluations, "top.*", &hv_Matches);
    TupleStrlen(hv_Matches, &hv_MatchesLength);
    hv_Indices = (hv_MatchesLength.TupleGreaterElem(0)).TupleFind(1);
    if (0 != (int(hv_Indices!=-1)))
    {
      hv_OffSet = HTuple::TupleGenSequence(0,(hv_KeyEvaluations.TupleLength())-1,1).TupleDifference(hv_Indices);
      hv_KeyEvaluations = HTuple(hv_KeyEvaluations[hv_Indices]).TupleConcat(HTuple(hv_KeyEvaluations[hv_OffSet]));
    }
    hv_FScoreIndex = (hv_KeyEvaluations.TupleEqualElem("f_score")).TupleFind(1);
    if (0 != (int(hv_FScoreIndex!=-1)))
    {
      TupleRemove(hv_KeyEvaluations, hv_FScoreIndex, &hv_KeyEvaluations);
      hv_KeyEvaluations = hv_KeyEvaluations.TupleConcat("f_score");
    }
    //Check if any valid keys are still available.
    if (0 != (int((hv_KeyEvaluations.TupleLength())==0)))
    {
      throw HException("To display 'measures' at least one evaluation measure is needed");
    }
    hv_ColumnNames = hv_KeyEvaluations;
    //
    //Fill matrix
    CreateMatrix(hv_KeyClasses.TupleLength(), hv_KeyEvaluations.TupleLength(), 0, 
        &hv_MatrixID);
    {
    HTuple end_val223 = (hv_KeyClasses.TupleLength())-1;
    HTuple step_val223 = 1;
    for (hv_RowIndex=0; hv_RowIndex.Continue(end_val223, step_val223); hv_RowIndex += step_val223)
    {
      GetDictTuple(hv_EvaluationResult, HTuple(hv_KeyClasses[hv_RowIndex]), &hv_Dict);
      {
      HTuple end_val225 = (hv_KeyEvaluations.TupleLength())-1;
      HTuple step_val225 = 1;
      for (hv_ColumnIndex=0; hv_ColumnIndex.Continue(end_val225, step_val225); hv_ColumnIndex += step_val225)
      {
        try
        {
          GetDictTuple(hv_Dict, HTuple(hv_KeyEvaluations[hv_ColumnIndex]), &hv_Value);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          GetDictTuple(hv_Dict, "mean_"+HTuple(hv_KeyEvaluations[hv_ColumnIndex]), 
              &hv_Value);
        }
        SetValueMatrix(hv_MatrixID, hv_RowIndex, hv_ColumnIndex, hv_Value);
      }
      }
    }
    }
    //
    //Set generic parameters for dev_display_matrix.
    CreateDict(&hv_GenParam);
    SetDictTuple(hv_GenParam, "title", "Measures");
    SetDictTuple(hv_GenParam, "number_format", "0.3f");
    SetDictTuple(hv_GenParam, "display_column_width", hv_DisplayColumnWidth);
    SetDictTuple(hv_GenParam, "display_color", 1);
    SetDictTuple(hv_GenParam, "value_colors", hv_MeasureColor);
    SetDictTuple(hv_GenParam, "row_col_names_color", hv_RowColNameColor);
    //
    //Check if there is already a window handle.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", &hv_WindowExists);
    if (0 != hv_WindowExists)
    {
      GetDictTuple(hv_WindowHandleDict, "window_measures", &hv_WindowHandleMeasures);
      HDevWindowStack::SetActive(hv_WindowHandleMeasures);
    }
    else
    {
      SetWindowAttr("background_color","black");
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleMeasures);
      HDevWindowStack::Push(hv_WindowHandleMeasures);
      SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
    }
    //
    //Display.
    set_display_font(hv_WindowHandleMeasures, hv_FontSize, hv_Font, "false", "false");
    dev_display_matrix(hv_MatrixID, hv_ColumnNames, hv_RowNames, hv_WindowHandleMeasures, 
        hv_GenParam);
  }
  //
  //Visualize confusion matrix.
  if (0 != (hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)))
  {
    //
    //Set general generic parameters for dev_display_matrix.
    CreateDict(&hv_GenParam);
    SetDictTuple(hv_GenParam, "display_column_with", hv_DisplayColumnWidth);
    SetDictTuple(hv_GenParam, "display_color", hv_DisplayColor);
    SetDictTuple(hv_GenParam, "row_col_names_color", hv_RowColNameColor);
    SetDictTuple(hv_GenParam, "axis_titles", (HTuple("Ground truth").Append("Predicted")));
    if (0 != hv_DisplayColor)
    {
      //Display off-diagonal values in red.
      hv_ValueColors = HTuple((hv_ClassIDs.TupleLength())*(hv_ClassIDs.TupleLength()),"#ff4500");
      //Display diagonal values in green.
      hv_DiagonalColor = "#00ff00";
      TupleGenSequence(0, (hv_ClassIDs.TupleLength())-1, 1, &hv_Seq);
      hv_DiagonalIndices = ((hv_ClassIDs.TupleLength())*hv_Seq)+hv_Seq;
      hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
      SetDictTuple(hv_GenParam, "value_colors", hv_ValueColors);
    }
    //
    //Set row and column names.
    if (0 != (int(hv_ClassNames!=HTuple())))
    {
      hv_RowColumnNames = hv_ClassNames;
    }
    else
    {
      hv_RowColumnNames = "class_id_"+hv_ClassIDs;
    }
    //
    //Display confusion matrix.
    hv_Booleans.Clear();
    hv_Booleans.Append(hv_DisplayConfusionAbsolute);
    hv_Booleans.Append(hv_DisplayConfusionRelative);
    hv_Strings.Clear();
    hv_Strings[0] = "absolute";
    hv_Strings[1] = "relative";
    hv_KapitalStrings.Clear();
    hv_KapitalStrings[0] = "Absolute";
    hv_KapitalStrings[1] = "Relative";
    {
    HTuple end_val290 = (hv_Booleans.TupleLength())-1;
    HTuple step_val290 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val290, step_val290); hv_Index += step_val290)
    {
      if (0 != (HTuple(hv_Booleans[hv_Index]).TupleNot()))
      {
        continue;
      }
      GetDictTuple(hv_EvaluationResult, HTuple(hv_Strings[hv_Index])+"_confusion_matrix", 
          &hv_ConfusionMatrix);
      SetDictTuple(hv_GenParam, "title", HTuple(hv_KapitalStrings[hv_Index])+" confusion matrix");
      //Convert relative matrix values to percent.
      if (0 != (int(HTuple(hv_Strings[hv_Index])==HTuple("relative"))))
      {
        CopyMatrix(hv_ConfusionMatrix, &hv_ConfusionMatrix);
        GetFullMatrix(hv_ConfusionMatrix, &hv_ValuesRelative);
        SetFullMatrix(hv_ConfusionMatrix, 100*hv_ValuesRelative);
      }
      //Calculate proper number format.
      MaxMatrix(hv_ConfusionMatrix, "full", &hv_MatrixMaxID);
      GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
      if (0 != (int(hv_MaxValue>0)))
      {
        hv_NumberFormat = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
      }
      else
      {
        hv_NumberFormat = "1.0f";
      }
      SetDictTuple(hv_GenParam, "number_format", hv_NumberFormat);
      //
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", ("window_"+HTuple(hv_Strings[hv_Index]))+"_confusion_matrix", 
          &hv_WindowExists);
      if (0 != (hv_WindowExists.TupleNot()))
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleConfusion);
        HDevWindowStack::Push(hv_WindowHandleConfusion);
        SetDictTuple(hv_WindowHandleDict, ("window_"+HTuple(hv_Strings[hv_Index]))+"_confusion_matrix", 
            hv_WindowHandleConfusion);
      }
      else
      {
        GetDictTuple(hv_WindowHandleDict, ("window_"+HTuple(hv_Strings[hv_Index]))+"_confusion_matrix", 
            &hv_WindowHandleConfusion);
      }
      //
      //Display.
      set_display_font(hv_WindowHandleConfusion, hv_FontSize, hv_Font, "false", "false");
      dev_display_matrix(hv_ConfusionMatrix, hv_RowColumnNames, hv_RowColumnNames, 
          hv_WindowHandleConfusion, hv_GenParam);
    }
    }
  }
  //
  // Visualization of precision pie charts.
  if (0 != hv_DisplayPieChartPrecision)
  {
    //
    //Check if there is already a window handle.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_precision", 
        &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandlePrecision);
      HDevWindowStack::Push(hv_WindowHandlePrecision);
      SetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision", hv_WindowHandlePrecision);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision", &hv_WindowHandlePrecision);
    }
    //Display.
    dev_display_classification_evaluation_class_pie_chart(hv_WindowHandlePrecision, 
        hv_EvaluationResult, hv_ClassIDs, "precision");
  }
  //
  // Visualization of recall pie charts.
  if (0 != hv_DisplayPieChartRecall)
  {
    //
    //Check if there is already a window handle.
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_recall", &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandlePrecision);
      HDevWindowStack::Push(hv_WindowHandlePrecision);
      SetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall", hv_WindowHandlePrecision);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall", &hv_WindowHandlePrecision);
    }
    //Display.
    dev_display_classification_evaluation_class_pie_chart(hv_WindowHandlePrecision, 
        hv_EvaluationResult, hv_ClassIDs, "recall");
  }
  //
  //Rearrange windows.
  //Pie charts (if present) are plotted at the left, the rest at the right side.
  GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_WindowKeys);
  hv_DisplayBooleans.Clear();
  hv_DisplayBooleans.Append(hv_DisplayPieChartPrecision);
  hv_DisplayBooleans.Append(hv_DisplayPieChartRecall);
  hv_DisplayBooleans.Append(hv_DisplayMeasures);
  hv_DisplayBooleans.Append(hv_DisplayConfusionAbsolute);
  hv_DisplayBooleans.Append(hv_DisplayConfusionRelative);
  hv_WindowHandleKeyNames.Clear();
  hv_WindowHandleKeyNames[0] = "window_pie_charts_precision";
  hv_WindowHandleKeyNames[1] = "window_pie_charts_recall";
  hv_WindowHandleKeyNames[2] = "window_measures";
  hv_WindowHandleKeyNames[3] = "window_absolute_confusion_matrix";
  hv_WindowHandleKeyNames[4] = "window_relative_confusion_matrix";
  hv_Row = 0;
  hv_Column = 0;
  hv_MaxColumn = 0;
  if (0 != (int((hv_WindowKeys.TupleLength())>=1)))
  {
    {
    HTuple end_val366 = (hv_DisplayBooleans.TupleLength())-1;
    HTuple step_val366 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val366, step_val366); hv_Index += step_val366)
    {
      if (0 != (int(hv_Index==2)))
      {
        hv_Row = 0;
        hv_Column = hv_MaxColumn+8;
      }
      if (0 != (HTuple(hv_DisplayBooleans[hv_Index])))
      {
        GetDictTuple(hv_WindowHandleDict, HTuple(hv_WindowHandleKeyNames[hv_Index]), 
            &hv_WindowHandle);
        GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_Width, &hv_Height);
        HDevWindowStack::SetActive(hv_WindowHandle);
        if (HDevWindowStack::IsOpen())
          SetWindowExtents(HDevWindowStack::GetActive(),hv_Row, hv_Column, hv_Width, 
              hv_Height);
        hv_Row = (hv_Row+hv_Height)+55;
        hv_MaxColumn = hv_MaxColumn.TupleMax2(hv_Width);
      }
    }
    }
  }
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Display pie charts for prediction or recall of an classification evaluation. 
void dev_display_classification_evaluation_class_pie_chart (HTuple hv_WindowHandle, 
    HTuple hv_EvaluationResult, HTuple hv_ClassIDs, HTuple hv_Mode)
{

  // Local iconic variables
  HObject  ho_Image;

  // Local control variables
  HTuple  hv_FlushValue, hv_CenterRowOverall, hv_CenterColOverall;
  HTuple  hv_RadiusOverall, hv_MaxClassChartsPerRow, hv_RadiusClass;
  HTuple  hv_ChartRowDistance, hv_ChartColDistance, hv_StartRow;
  HTuple  hv_StartCol, hv_KeysToPlot, hv_KeyExists, hv_NumClassCharts;
  HTuple  hv_Measures, hv_MeanValue, hv_ValuesPerClass, hv_MainTitle;
  HTuple  hv_ClassTitles, hv_Keys, hv_ClassIDsStr, hv_Index;
  HTuple  hv_Value, hv_WindowWidth, hv_WindowHeight, hv_Colors;
  HTuple  hv_GenParamPieChart, hv_Description, hv_PercentStr;
  HTuple  hv_CenterRow, hv_CenterCol;

  //
  //This procedure plots pie charts for precision and recall.
  //More detailed, the mean over all classes that have been used for
  //evaluation and the values for each class are plotted.
  //
  //Switch off automatic flushing to make visualization smooth.
  GetWindowParam(hv_WindowHandle, "flush", &hv_FlushValue);
  SetWindowParam(hv_WindowHandle, "flush", "false");
  //Drawing parameters.
  //Overall pie-chart.
  hv_CenterRowOverall = 150;
  hv_CenterColOverall = 150;
  hv_RadiusOverall = 100;
  //Per-class pie-chart.
  hv_MaxClassChartsPerRow = 10;
  hv_RadiusClass = 40;
  hv_ChartRowDistance = 3*hv_RadiusClass;
  hv_ChartColDistance = 2.5*hv_RadiusClass;
  hv_StartRow = (hv_CenterRowOverall+(1.5*hv_RadiusOverall))+(1.5*hv_RadiusClass);
  hv_StartCol = 1.5*hv_RadiusClass;
  //
  //Get values.
  hv_KeysToPlot = "global";
  GetDictParam(hv_EvaluationResult, "key_exists", "global", &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    hv_KeysToPlot = "global";
    hv_NumClassCharts = hv_ClassIDs.TupleLength();
    GetDictTuple(hv_EvaluationResult, "global", &hv_Measures);
    GetDictTuple(hv_Measures, "mean_"+hv_Mode, &hv_MeanValue);
    GetDictTuple(hv_Measures, hv_Mode+"_per_class", &hv_ValuesPerClass);
    hv_MainTitle = "Mean "+hv_Mode;
    hv_ClassTitles = "Class id "+hv_ClassIDs;
  }
  else
  {
    //Search for evaluated classes.
    GetDictParam(hv_EvaluationResult, "keys", HTuple(), &hv_Keys);
    TupleRegexpSelect(hv_Keys, "class_id", &hv_KeysToPlot);
    TupleRegexpMatch(hv_KeysToPlot, "class_id_(.*)", &hv_ClassIDsStr);
    hv_ClassIDs = hv_ClassIDsStr.TupleNumber();
    if (0 != (int((hv_ClassIDs.TupleLength())==1)))
    {
      //We do not need to plot the small pie charts for each class.
      hv_NumClassCharts = 0;
      hv_MainTitle = (hv_Mode+" for class id ")+HTuple(hv_ClassIDs[0]);
      hv_ClassTitles = HTuple();
    }
    else
    {
      hv_NumClassCharts = hv_ClassIDs.TupleLength();
      hv_MainTitle = "Mean "+hv_Mode;
      hv_ClassTitles = "Class id "+hv_ClassIDs;
    }
    hv_ValuesPerClass = HTuple();
    {
    HTuple end_val49 = (hv_ClassIDs.TupleLength())-1;
    HTuple step_val49 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val49, step_val49); hv_Index += step_val49)
    {
      GetDictTuple(hv_EvaluationResult, HTuple(hv_KeysToPlot[hv_Index]), &hv_Measures);
      GetDictTuple(hv_Measures, hv_Mode, &hv_Value);
      hv_ValuesPerClass = hv_ValuesPerClass.TupleConcat(hv_Value);
    }
    }
    hv_MeanValue = hv_ValuesPerClass.TupleMean();
  }
  //
  //Open Window and set font.
  hv_WindowWidth = HTuple(550).TupleMax2((((hv_NumClassCharts.TupleMin2(hv_MaxClassChartsPerRow))-1)*hv_ChartColDistance)+(2*hv_StartCol));
  hv_WindowHeight = (3*hv_RadiusOverall)+(((((hv_NumClassCharts.TupleReal())/hv_MaxClassChartsPerRow).TupleCeil())*3)*hv_RadiusClass);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),0, 0, hv_WindowWidth, hv_WindowHeight);
  GenImageConst(&ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  set_display_font(hv_WindowHandle, 15, "mono", "true", "false");
  //
  //Draw the pie-chart.
  hv_Colors.Clear();
  hv_Colors[0] = "green";
  hv_Colors[1] = "red";
  CreateDict(&hv_GenParamPieChart);
  SetDictTuple(hv_GenParamPieChart, "title", hv_MainTitle);
  dev_display_pie_chart(hv_WindowHandle, hv_MeanValue.TupleConcat(1.0-hv_MeanValue), 
      hv_CenterRowOverall, hv_CenterColOverall, hv_RadiusOverall, hv_Colors, hv_GenParamPieChart);
  //
  //Write description for pie chart.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Results: ", "image", 20, (hv_CenterColOverall+hv_RadiusOverall)+20, 
        "white", "box", "false");
  if (0 != (int(hv_Mode==HTuple("precision"))))
  {
    hv_Description.Clear();
    hv_Description[0] = "precision (TP/(TP+FP))";
    hv_Description[1] = "false positives";
  }
  else if (0 != (int(hv_Mode==HTuple("recall"))))
  {
    hv_Description.Clear();
    hv_Description[0] = "recall (TP/(TP+FN))";
    hv_Description[1] = "false negatives";
  }
  else
  {
    throw HException("Mode not supported: "+hv_Mode);
  }
  hv_PercentStr = (((hv_MeanValue.TupleConcat(1.0-hv_MeanValue))*100).TupleString(".1f"))+"";
  {
  HTuple end_val83 = (hv_Description.TupleLength())-1;
  HTuple step_val83 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val83, step_val83); hv_Index += step_val83)
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),(HTuple(hv_PercentStr[hv_Index])+"%: ")+HTuple(hv_Description[hv_Index]), 
          "image", 30+((hv_Index+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
          HTuple(hv_Colors[hv_Index]), "box", "false");
  }
  }
  //
  //Per class pie charts.
  {
  HTuple end_val88 = hv_NumClassCharts-1;
  HTuple step_val88 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val88, step_val88); hv_Index += step_val88)
  {
    //Get the position of the class-pie-chart.
    hv_CenterRow = hv_StartRow+((((hv_Index.TupleReal())/hv_MaxClassChartsPerRow).TupleFloor())*hv_ChartRowDistance);
    hv_CenterCol = hv_StartCol+((hv_Index%hv_MaxClassChartsPerRow)*hv_ChartColDistance);
    SetDictTuple(hv_GenParamPieChart, "title", HTuple(hv_ClassTitles[hv_Index]));
    dev_display_pie_chart(hv_WindowHandle, HTuple(hv_ValuesPerClass[hv_Index]).TupleConcat(1.0-HTuple(hv_ValuesPerClass[hv_Index])), 
        hv_CenterRow, hv_CenterCol, hv_RadiusClass, hv_Colors, hv_GenParamPieChart);
  }
  }
  //
  //Flush buffer and reset value for 'flush'.
  FlushBuffer(hv_WindowHandle);
  SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display a map of the confidences. 
void dev_display_confidence_regions (HObject ho_ImageConfidence, HTuple hv_DrawTransparency, 
    HTuple *hv_Colors)
{

  // Local iconic variables
  HObject  ho_Region;

  // Local control variables
  HTuple  hv_NumColors, hv_WeightsColorsAlpha, hv_ColorIndex;
  HTuple  hv_Threshold, hv_MinGray, hv_MaxGray;

  //
  //This procedure displays a map of the confidences
  //given in ImageConfidence as regions.
  //DrawTransparency determines the alpha value of the colors.
  //The used colors are returned.
  //
  //Define colors.
  hv_NumColors = 20;
  get_distinct_colors(hv_NumColors, 0, 0, 100, &(*hv_Colors));
  hv_WeightsColorsAlpha = (*hv_Colors)+hv_DrawTransparency;
  hv_ColorIndex = 0;
  //
  //Threshold the image according to
  //the number of colors and
  //display resulting regions.
  {
  HTuple end_val15 = hv_NumColors-1;
  HTuple step_val15 = 1;
  for (hv_ColorIndex=0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex += step_val15)
  {
    hv_Threshold = hv_ColorIndex*(1.0/hv_NumColors);
    hv_MinGray = hv_Threshold;
    hv_MaxGray = hv_Threshold+(1/hv_NumColors);
    Threshold(ho_ImageConfidence, &ho_Region, hv_Threshold, hv_Threshold+(1.0/hv_NumColors));
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),HTuple(hv_WeightsColorsAlpha[hv_ColorIndex]));
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Region, HDevWindowStack::GetActive());
  }
  }
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display the confusion matrix for the evaluation results of a model with type detection. 
void dev_display_detection_confusion_matrix (HTuple hv_WindowHandles, HTuple hv_IoUEvaluationResult, 
    HTuple hv_ClassIDs, HTuple hv_GenParam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayAbsoluteMatrix, hv_DisplayRelativeMatrix;
  HTuple  hv_DisplayColor, hv_DisplayColumnWidth, hv_GenParamKeys;
  HTuple  hv_KeyExists, hv_ValueTmp, hv_DisplayColumnWidthTmp;
  HTuple  hv_CalculateRelativeMatrix, hv_ConfusionMatrix;
  HTuple  hv_NumRows, hv_NumColumns, hv_Values, hv_ConfusionMatrixRelative;
  HTuple  hv_C, hv_RowValues, hv_NumTPAndFN, hv_ValueColors;
  HTuple  hv_DiagonalColor, hv_Seq, hv_DiagonalIndices, hv_ClassStrings;
  HTuple  hv_FPStrings, hv_ColumnNames, hv_RowNames, hv_MatrixMaxID;
  HTuple  hv_MaxValue, hv_NumberFormat, hv_ValuesRelative;

  //
  //This procedure displays the detection confusion matrix
  //given in IoUEvaluationResult.
  //Thereby, the matrix can be displayed with absolute or
  //relative values.
  //
  //Set generic parameter default values.
  hv_DisplayAbsoluteMatrix = 1;
  hv_DisplayRelativeMatrix = 0;
  hv_DisplayColor = 1;
  hv_DisplayColumnWidth = "equal";
  //
  //Parse generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "display_color";
    hv_GenParamKeys[1] = "display_relative_matrix";
    hv_GenParamKeys[2] = "display_absolute_matrix";
    hv_GenParamKeys[3] = "display_column_width";
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //DisplayColor
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      GetDictTuple(hv_GenParam, "display_color", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_color'");
      }
      else
      {
        hv_DisplayColor = hv_ValueTmp;
      }
    }
    //DisplayRelativeMatrix
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, "display_relative_matrix", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_relative_matrix'");
      }
      else
      {
        hv_DisplayRelativeMatrix = hv_ValueTmp;
      }
    }
    //DisplayAbsoluteMatrix
    if (0 != (HTuple(hv_KeyExists[2])))
    {
      GetDictTuple(hv_GenParam, "display_absolute_matrix", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_absolute_matrix'");
      }
      else
      {
        hv_DisplayAbsoluteMatrix = hv_ValueTmp;
      }
    }
    if (0 != (HTuple(hv_KeyExists[3])))
    {
      GetDictTuple(hv_GenParam, "display_column_width", &hv_DisplayColumnWidthTmp);
      if (0 != (HTuple(int((hv_DisplayColumnWidthTmp.TupleLength())!=1)).TupleOr(int(((HTuple("equal").Append("minimal")).TupleFind(hv_DisplayColumnWidthTmp))==-1))))
      {
        throw HException("Invalid value for 'display_column_width'");
      }
      else
      {
        hv_DisplayColumnWidth = hv_DisplayColumnWidthTmp;
      }
    }
  }
  //
  if (0 != (HTuple(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayAbsoluteMatrix)).TupleNot()))
  {
    throw HException("At least one of 'display_absolute_matrix' and 'display_relative_matrix' should be true");
  }
  if (0 != (int((hv_DisplayRelativeMatrix+hv_DisplayAbsoluteMatrix)!=(hv_WindowHandles.TupleLength()))))
  {
    throw HException("Wrong number of WindowHandles");
  }
  if (0 != (hv_DisplayRelativeMatrix.TupleOr(hv_DisplayColor)))
  {
    hv_CalculateRelativeMatrix = 1;
  }
  else
  {
    hv_CalculateRelativeMatrix = 0;
  }
  //
  //Calculate the confusion matrix with absolute values
  //and the confusion matrix with relative errors.
  //We start with an empty matrix
  //and add the number of matching labels.
  GetDictTuple(hv_IoUEvaluationResult, "detection_confusion_matrix", &hv_ConfusionMatrix);
  GetSizeMatrix(hv_ConfusionMatrix, &hv_NumRows, &hv_NumColumns);
  GetFullMatrix(hv_ConfusionMatrix, &hv_Values);
  //
  if (0 != hv_CalculateRelativeMatrix)
  {
    //Calculate the relative matrix.
    CopyMatrix(hv_ConfusionMatrix, &hv_ConfusionMatrixRelative);
    //For each class:
    {
    HTuple end_val77 = (hv_ClassIDs.TupleLength())-1;
    HTuple step_val77 = 1;
    for (hv_C=0; hv_C.Continue(end_val77, step_val77); hv_C += step_val77)
    {
      //Get the total number of predictions and calculate the relative values.
      GetValueMatrix(hv_ConfusionMatrix, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
          &hv_RowValues);
      if (0 != (int((hv_RowValues.TupleSum())>0)))
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
            (hv_RowValues.TupleReal())/(hv_RowValues.TupleSum()));
      }
      else
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
            hv_RowValues.TupleReal());
      }
      //Get the total number of ground truth and calculate relative false negatives.
      GetValueMatrix(hv_ConfusionMatrix, hv_C.TupleConcat(hv_ClassIDs.TupleLength()), 
          hv_C.TupleConcat(hv_C), &hv_NumTPAndFN);
      if (0 != (int((hv_NumTPAndFN.TupleSum())>0)))
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, hv_ClassIDs.TupleLength(), hv_C, 
            (HTuple(hv_NumTPAndFN[1]).TupleReal())/(hv_NumTPAndFN.TupleSum()));
      }
      else
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, hv_ClassIDs.TupleLength(), hv_C, 
            HTuple(hv_NumTPAndFN[1]).TupleReal());
      }
    }
    }
  }
  //
  //Set color for displayed confusion matrix.
  hv_ValueColors = HTuple(hv_Values.TupleLength(),"#666666");
  if (0 != hv_DisplayColor)
  {
    //Display off-diagonal values in red.
    hv_ValueColors = HTuple(hv_Values.TupleLength(),"#ff4500");
    //Display diagonal values in green.
    hv_DiagonalColor = "#00ff00";
    TupleGenSequence(0, (hv_ClassIDs.TupleLength())-1, 1, &hv_Seq);
    hv_DiagonalIndices = (hv_NumColumns*hv_Seq)+hv_Seq;
    hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
  }
  //
  //Display the matrix.
  //
  //Collect column and row names.
  hv_ClassStrings = "class_"+hv_ClassIDs;
  hv_FPStrings.Clear();
  hv_FPStrings[0] = "FP bg";
  hv_FPStrings[1] = "FP loc";
  hv_FPStrings[2] = "FP dup";
  hv_FPStrings[3] = "FP mult";
  hv_ColumnNames.Clear();
  hv_ColumnNames.Append(hv_ClassStrings);
  hv_ColumnNames.Append(hv_FPStrings);
  hv_RowNames.Clear();
  hv_RowNames.Append(hv_ClassStrings);
  hv_RowNames.Append("FN");
  //
  //Create GenParam for matrix display.
  CreateDict(&hv_GenParam);
  SetDictTuple(hv_GenParam, "display_column_width", hv_DisplayColumnWidth);
  SetDictTuple(hv_GenParam, "display_color", hv_DisplayColor);
  //The last 4 values are meaningless and therefore not displayed.
  SetDictTuple(hv_GenParam, "idxs_no_display", HTuple::TupleGenSequence((hv_Values.TupleLength())-4,(hv_Values.TupleLength())-1,1));
  SetDictTuple(hv_GenParam, "axis_titles", (HTuple("Ground truth").Append("Predicted")));
  SetDictTuple(hv_GenParam, "value_colors", hv_ValueColors);
  if (0 != hv_DisplayAbsoluteMatrix)
  {
    //Display absolute matrix.
    //Calculate proper number format.
    MaxMatrix(hv_ConfusionMatrix, "full", &hv_MatrixMaxID);
    GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
    if (0 != (int(hv_MaxValue>0)))
    {
      hv_NumberFormat = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
    }
    else
    {
      hv_NumberFormat = "1.0f";
    }
    SetDictTuple(hv_GenParam, "number_format", hv_NumberFormat);
    //Set title.
    SetDictTuple(hv_GenParam, "title", HTuple("Detection confusion matrix, absolute"));
    dev_display_matrix(hv_ConfusionMatrix, hv_ColumnNames, hv_RowNames, HTuple(hv_WindowHandles[0]), 
        hv_GenParam);
  }
  if (0 != hv_DisplayRelativeMatrix)
  {
    //Display relative matrix.
    //Convert relative matrix values to percent.
    GetFullMatrix(hv_ConfusionMatrixRelative, &hv_ValuesRelative);
    SetFullMatrix(hv_ConfusionMatrixRelative, 100*hv_ValuesRelative);
    //Set number format.
    hv_NumberFormat = "2.1f";
    SetDictTuple(hv_GenParam, "number_format", hv_NumberFormat);
    //Set title.
    SetDictTuple(hv_GenParam, "title", HTuple("Detection confusion matrix, relative [%]"));
    dev_display_matrix(hv_ConfusionMatrixRelative, hv_ColumnNames, hv_RowNames, HTuple(hv_WindowHandles[hv_DisplayAbsoluteMatrix]), 
        hv_GenParam);
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Visualize the results of a detailed evaluation for a model of type detection. 
void dev_display_detection_detailed_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayPieChartsPrecision, hv_DisplayPieChartsRecall;
  HTuple  hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative;
  HTuple  hv_BaseWindowRow, hv_BaseWindowColumn, hv_DetailedEvaluation;
  HTuple  hv_AvailableIoUThresholds, hv_MaxNumDetections;
  HTuple  hv_AreaRanges, hv_ClassIDs, hv_IoUThreshold, hv_AreaRangeName;
  HTuple  hv_MaxNumDetStr, hv_MaxNumEvaluationResult, hv_AreaEvaluationResult;
  HTuple  hv_IoUEvaluationResult, hv_GenParamKeys, hv_Keys;
  HTuple  hv_IndexKeys, hv_KeyExists, hv_Value, hv_Exception;
  HTuple  hv_WindowExists, hv_WindowHandlePieChartsPrecision;
  HTuple  hv_WindowHandlePieChartsRecall, hv_WindowHandlesConfusion;
  HTuple  hv_WindowHandleConfusionAbsolute, hv_WindowHandleConfusionRelative;
  HTuple  hv_ColConfusion, hv_RowConfusion, hv_WidthConf;
  HTuple  hv_HeightConf, hv__, hv_Width, hv_Height, hv_Row;
  HTuple  hv_Column;

  //
  //This procedure visualizes the detailed evaluation results for a model of type detection.
  //
  //Set the default values.
  hv_DisplayPieChartsPrecision = 1;
  hv_DisplayPieChartsRecall = 0;
  hv_DisplayConfusionAbsolute = 0;
  hv_DisplayConfusionRelative = 0;
  //
  //Default settings for window placement.
  hv_BaseWindowRow = 0;
  hv_BaseWindowColumn = 0;
  //
  //Get some evaluation parameters.
  GetDictTuple(hv_EvalParam, "detailed_evaluation", &hv_DetailedEvaluation);
  if (0 != (hv_DetailedEvaluation.TupleNot()))
  {
    throw HException("detailed_evaluation has to be set to true for this visualization");
  }
  GetDictTuple(hv_EvalParam, "iou_threshold", &hv_AvailableIoUThresholds);
  GetDictTuple(hv_EvalParam, "max_num_detections", &hv_MaxNumDetections);
  GetDictTuple(hv_EvalParam, "area_ranges", &hv_AreaRanges);
  GetDictTuple(hv_EvalParam, "class_ids", &hv_ClassIDs);
  //
  //Use the first value under IoU threshold, MaxNumDetections and area-range.
  hv_IoUThreshold = ((const HTuple&)hv_AvailableIoUThresholds)[0];
  hv_MaxNumDetections = ((const HTuple&)hv_MaxNumDetections)[0];
  GetDictTuple(hv_AreaRanges, "name", &hv_AreaRangeName);
  hv_AreaRangeName = ((const HTuple&)hv_AreaRangeName)[0];
  //Get detailed evaluation results.
  hv_MaxNumDetStr = ""+hv_MaxNumDetections;
  if (0 != (int(hv_MaxNumDetections==-1)))
  {
    hv_MaxNumDetStr = "all";
  }
  //
  //Get the detailed evaluation results for the first IoU-threshold, although it might be changed below depending on generic parameters.
  GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, &hv_MaxNumEvaluationResult);
  GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_AreaRangeName, &hv_AreaEvaluationResult);
  GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+((""+hv_IoUThreshold).TupleRegexpReplace("\\.","")), 
      &hv_IoUEvaluationResult);
  //
  //Handle the generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "display_mode";
    hv_GenParamKeys[1] = "window_row";
    hv_GenParamKeys[2] = "window_column";
    hv_GenParamKeys[3] = "max_num_detections";
    hv_GenParamKeys[4] = "area_range_name";
    hv_GenParamKeys[5] = "iou_threshold";
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_Keys);
    {
    HTuple end_val43 = (hv_Keys.TupleLength())-1;
    HTuple step_val43 = 1;
    for (hv_IndexKeys=0; hv_IndexKeys.Continue(end_val43, step_val43); hv_IndexKeys += step_val43)
    {
      if (0 != (int((hv_GenParamKeys.TupleFind(HTuple(hv_Keys[hv_IndexKeys])))==-1)))
      {
        throw HException(("Invalid GenParam key '"+HTuple(hv_Keys[hv_IndexKeys]))+"'");
      }
    }
    }
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //Display mode.
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[0]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())==0)))
      {
        throw HException("GenParam key 'display_mode' cannot be an empty tuple");
      }
      else
      {
        //Pie chart precision.
        hv_DisplayPieChartsPrecision = hv_Value.TupleFind("pie_charts_precision");
        hv_DisplayPieChartsPrecision = HTuple(int((hv_DisplayPieChartsPrecision.TupleLength())>0)).TupleAnd(int(hv_DisplayPieChartsPrecision!=-1));
        //Pie chart recall.
        hv_DisplayPieChartsRecall = hv_Value.TupleFind("pie_charts_recall");
        hv_DisplayPieChartsRecall = HTuple(int((hv_DisplayPieChartsRecall.TupleLength())>0)).TupleAnd(int(hv_DisplayPieChartsRecall!=-1));
        //Absolute confusion matrix.
        hv_DisplayConfusionAbsolute = hv_Value.TupleFind("absolute_confusion_matrix");
        hv_DisplayConfusionAbsolute = HTuple(int((hv_DisplayConfusionAbsolute.TupleLength())>0)).TupleAnd(int(hv_DisplayConfusionAbsolute!=-1));
        //Relative confusion matrix.
        hv_DisplayConfusionRelative = hv_Value.TupleFind("relative_confusion_matrix");
        hv_DisplayConfusionRelative = HTuple(int((hv_DisplayConfusionRelative.TupleLength())>0)).TupleAnd(int(hv_DisplayConfusionRelative!=-1));
        if (0 != (HTuple(HTuple(HTuple(hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)).TupleOr(hv_DisplayConfusionAbsolute)).TupleOr(hv_DisplayConfusionRelative)).TupleNot()))
        {
          throw HException("'display_mode' not supported.");
        }
      }
    }
    //BaseWindowRow.
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[1]), &hv_Value);
      if (0 != (HTuple(int((hv_Value.TupleLength())==1)).TupleAnd(int(hv_Value>=0))))
      {
        hv_BaseWindowRow = hv_Value;
      }
      else
      {
        throw HException("Invalid GenParam 'window_row'.");
      }
    }
    //BaseWindowColumn.
    if (0 != (HTuple(hv_KeyExists[2])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[2]), &hv_Value);
      if (0 != (HTuple(int((hv_Value.TupleLength())==1)).TupleAnd(int(hv_Value>=0))))
      {
        hv_BaseWindowColumn = hv_Value;
      }
      else
      {
        throw HException("Invalid GenParam 'window_column'.");
      }
    }
    //MaxNumDetections.
    if (0 != (HTuple(hv_KeyExists[3])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[3]), &hv_Value);
      hv_MaxNumDetStr = ""+hv_Value;
      if (0 != (int(hv_Value==-1)))
      {
        hv_MaxNumDetStr = "all";
      }
      try
      {
        GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, 
            &hv_MaxNumEvaluationResult);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid GenParam 'max_num_detections'");
      }
      hv_MaxNumDetections = hv_Value;
    }
    //AreaRange.
    if (0 != (HTuple(hv_KeyExists[4])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[4]), &hv_Value);
      try
      {
        GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_Value, &hv_AreaEvaluationResult);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid GenParam 'area_range_name'");
      }
      hv_AreaRangeName = hv_Value;
    }
    //IoUThreshold.
    if (0 != (HTuple(hv_KeyExists[5])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[5]), &hv_Value);
      try
      {
        GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+((""+hv_Value).TupleRegexpReplace("\\.","")), 
            &hv_IoUEvaluationResult);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid GenParam 'iou_threshold'");
      }
      hv_IoUThreshold = hv_Value;
    }
  }
  //
  //Check that the WindowHandleDict is of type dictionary.
  try
  {
    GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_Keys);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    if (0 != (int(HTuple(hv_Exception[0])==1401)))
    {
      throw HException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
    }
    else
    {
      throw HException(hv_Exception);
    }
  }
  //
  //Update the IoUEvaluationResult in case MaxNumDetections, AreaRange or IoUThreshold have changed.
  GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, &hv_MaxNumEvaluationResult);
  GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_AreaRangeName, &hv_AreaEvaluationResult);
  GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+((""+hv_IoUThreshold).TupleRegexpReplace("\\.","")), 
      &hv_IoUEvaluationResult);
  SetDictTuple(hv_IoUEvaluationResult, "iou_threshold", hv_IoUThreshold);
  //
  //Generate pie-charts with false positives information.
  if (0 != hv_DisplayPieChartsPrecision)
  {
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_chart_precision", 
        &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",&hv_WindowHandlePieChartsPrecision);
      HDevWindowStack::Push(hv_WindowHandlePieChartsPrecision);
      SetDictTuple(hv_WindowHandleDict, "window_pie_chart_precision", hv_WindowHandlePieChartsPrecision);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_chart_precision", &hv_WindowHandlePieChartsPrecision);
    }
    dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsPrecision, 
        hv_IoUEvaluationResult, hv_ClassIDs, "precision", hv_BaseWindowRow, hv_BaseWindowColumn);
  }
  //
  //Generate pie-charts with false negatives information.
  if (0 != hv_DisplayPieChartsRecall)
  {
    GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_chart_recall", &hv_WindowExists);
    if (0 != (hv_WindowExists.TupleNot()))
    {
      SetWindowAttr("background_color","black");
      OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",&hv_WindowHandlePieChartsRecall);
      HDevWindowStack::Push(hv_WindowHandlePieChartsRecall);
      SetDictTuple(hv_WindowHandleDict, "window_pie_chart_recall", hv_WindowHandlePieChartsRecall);
    }
    else
    {
      GetDictTuple(hv_WindowHandleDict, "window_pie_chart_recall", &hv_WindowHandlePieChartsRecall);
    }
    dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsRecall, hv_IoUEvaluationResult, 
        hv_ClassIDs, "recall", hv_BaseWindowRow, hv_BaseWindowColumn);
  }
  //
  //Visualize detection confusion matrix.
  if (0 != (hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)))
  {
    hv_WindowHandlesConfusion = HTuple();
    CreateDict(&hv_GenParam);
    SetDictTuple(hv_GenParam, "display_relative_matrix", hv_DisplayConfusionRelative);
    SetDictTuple(hv_GenParam, "display_absolute_matrix", hv_DisplayConfusionAbsolute);
    SetDictTuple(hv_GenParam, "display_color", 1);
    if (0 != hv_DisplayConfusionAbsolute)
    {
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_absolute_confusion_matrix", 
          &hv_WindowExists);
      if (0 != (hv_WindowExists.TupleNot()))
      {
        SetWindowAttr("background_color","black");
        OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",&hv_WindowHandleConfusionAbsolute);
        HDevWindowStack::Push(hv_WindowHandleConfusionAbsolute);
        SetDictTuple(hv_WindowHandleDict, "window_absolute_confusion_matrix", hv_WindowHandleConfusionAbsolute);
      }
      else
      {
        GetDictTuple(hv_WindowHandleDict, "window_absolute_confusion_matrix", &hv_WindowHandleConfusionAbsolute);
      }
      hv_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(hv_WindowHandleConfusionAbsolute);
    }
    if (0 != hv_DisplayConfusionRelative)
    {
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_relative_confusion_matrix", 
          &hv_WindowExists);
      if (0 != (hv_WindowExists.TupleNot()))
      {
        SetWindowAttr("background_color","black");
        OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",&hv_WindowHandleConfusionRelative);
        HDevWindowStack::Push(hv_WindowHandleConfusionRelative);
        SetDictTuple(hv_WindowHandleDict, "window_relative_confusion_matrix", hv_WindowHandleConfusionRelative);
      }
      else
      {
        GetDictTuple(hv_WindowHandleDict, "window_relative_confusion_matrix", &hv_WindowHandleConfusionRelative);
      }
      hv_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(hv_WindowHandleConfusionRelative);
    }
    dev_display_detection_confusion_matrix(hv_WindowHandlesConfusion, hv_IoUEvaluationResult, 
        hv_ClassIDs, hv_GenParam);
    hv_WindowHandleDict = hv_WindowHandleDict.TupleConcat(hv_WindowHandlesConfusion);
  }
  //
  //Rearrange windows.
  //If all four windows are used we display the pie-charts to the left,
  //while to the right the confusion matrices are shown below each other.
  //Else, if the pie-charts are not displayed, we display the confusion matrices next to each other.
  if (0 != (int((hv_WindowHandleDict.TupleLength())>=1)))
  {
    hv_ColConfusion.Clear();
    hv_ColConfusion.Append(hv_BaseWindowColumn);
    hv_ColConfusion.Append(hv_BaseWindowColumn);
    hv_RowConfusion.Clear();
    hv_RowConfusion.Append(hv_BaseWindowRow);
    hv_RowConfusion.Append(hv_BaseWindowRow);
    hv_WidthConf = -1;
    hv_HeightConf = -1;
    if (0 != (hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)))
    {
      if (0 != hv_DisplayPieChartsPrecision)
      {
        GetWindowExtents(hv_WindowHandlePieChartsPrecision, &hv__, &hv__, &hv_Width, 
            &hv_Height);
        HDevWindowStack::SetActive(hv_WindowHandlePieChartsPrecision);
        if (HDevWindowStack::IsOpen())
          SetWindowExtents(HDevWindowStack::GetActive(),hv_BaseWindowRow, hv_BaseWindowColumn, 
              hv_Width, hv_Height);
      }
      else
      {
        GetWindowExtents(hv_WindowHandlePieChartsRecall, &hv__, &hv__, &hv_Width, 
            &hv_Height);
        if (0 != (hv_DisplayPieChartsPrecision.TupleNot()))
        {
          HDevWindowStack::SetActive(hv_WindowHandlePieChartsRecall);
          if (HDevWindowStack::IsOpen())
            SetWindowExtents(HDevWindowStack::GetActive(),hv_BaseWindowRow, hv_BaseWindowColumn, 
                hv_Width, hv_Height);
        }
      }
      hv_ColConfusion = (hv_ColConfusion+hv_Width)+8;
      if (0 != (hv_DisplayPieChartsPrecision.TupleAnd(hv_DisplayPieChartsRecall)))
      {
        HDevWindowStack::SetActive(hv_WindowHandlePieChartsRecall);
        if (HDevWindowStack::IsOpen())
          SetWindowExtents(HDevWindowStack::GetActive(),(hv_BaseWindowRow+hv_Height)+55, 
              hv_BaseWindowColumn, hv_Width, hv_Height);
      }
    }
    if (0 != hv_DisplayConfusionAbsolute)
    {
      GetWindowExtents(hv_WindowHandleConfusionAbsolute, &hv_Row, &hv_Column, &hv_WidthConf, 
          &hv_HeightConf);
      HDevWindowStack::SetActive(hv_WindowHandleConfusionAbsolute);
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),HTuple(hv_RowConfusion[0]), 
            HTuple(hv_ColConfusion[0]), hv_WidthConf, hv_HeightConf);
      if (0 != (hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)))
      {
        hv_RowConfusion[1] = (HTuple(hv_RowConfusion[1])+hv_HeightConf)+55;
      }
      else
      {
        hv_ColConfusion[1] = (HTuple(hv_ColConfusion[1])+hv_WidthConf)+8;
      }
    }
    if (0 != hv_DisplayConfusionRelative)
    {
      HDevWindowStack::SetActive(hv_WindowHandleConfusionRelative);
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),HTuple(hv_RowConfusion[1]), 
            HTuple(hv_ColConfusion[1]), hv_WidthConf, hv_HeightConf);
    }
  }
  //
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display a pie-chart for the evaluation results of one class or all classes together. 
void dev_display_detection_eval_class_pie_chart (HTuple hv_WindowHandle, HTuple hv_ClassEvaluationResult, 
    HTuple hv_CenterRow, HTuple hv_Mode, HTuple hv_CenterColumn, HTuple hv_Radius, 
    HTuple hv_Colors, HTuple hv_Title, HTuple *hv_Ratios)
{

  // Local iconic variables
  HObject  ho_ContCircle, ho_SectorFP;

  // Local control variables
  HTuple  hv_Keys, hv_Numbers, hv_K, hv_Num, hv_NumTotal;
  HTuple  hv_ColorsPieChart, hv_GenParamPieChart, hv_NumFP;
  HTuple  hv_FullCircleAngle, hv_Row, hv_Col, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_ContourStyle;

  //This procedure displays the evaluation results
  //in the dictionary ClassEvaluationResult as a pie-chart.
  //Thereby, the procedure plots one pie-chart
  //for a specific class or all classes together.
  //
  //num_fp has to be handled separately.
  if (0 != (int(hv_Mode==HTuple("precision"))))
  {
    hv_Keys.Clear();
    hv_Keys[0] = "num_tp";
    hv_Keys[1] = "num_fp_class";
    hv_Keys[2] = "num_fp_background";
    hv_Keys[3] = "num_fp_localization";
    hv_Keys[4] = "num_fp_duplicate";
    hv_Keys[5] = "num_fp_multiple";
  }
  else
  {
    hv_Keys.Clear();
    hv_Keys[0] = "num_tp";
    hv_Keys[1] = "num_fn";
  }
  hv_Numbers = HTuple(hv_Keys.TupleLength(),0);
  {
  HTuple end_val12 = (hv_Keys.TupleLength())-1;
  HTuple step_val12 = 1;
  for (hv_K=0; hv_K.Continue(end_val12, step_val12); hv_K += step_val12)
  {
    GetDictTuple(hv_ClassEvaluationResult, HTuple(hv_Keys[hv_K]), &hv_Num);
    hv_Numbers[hv_K] = hv_Num;
  }
  }
  hv_NumTotal = hv_Numbers.TupleSum();
  hv_ColorsPieChart = hv_Colors;
  if (0 != (int(hv_NumTotal==0)))
  {
    //No predictions available, we print a full gray circle.
    (*hv_Ratios) = 1.0;
    hv_ColorsPieChart = "gray";
  }
  else
  {
    (*hv_Ratios) = (hv_Numbers.TupleReal())/hv_NumTotal;
  }
  //
  //Draw the pie-chart.
  CreateDict(&hv_GenParamPieChart);
  if (0 != (int(hv_Title!=HTuple(""))))
  {
    SetDictTuple(hv_GenParamPieChart, "title", hv_Title);
  }
  dev_display_pie_chart(hv_WindowHandle, (*hv_Ratios), hv_CenterRow, hv_CenterColumn, 
      hv_Radius, hv_ColorsPieChart, hv_GenParamPieChart);
  //
  //Highlight total number of false positives.
  if (0 != (int(hv_NumTotal>0)))
  {
    //Add ratio of all false positives to output if there are any detections.
    GetDictTuple(hv_ClassEvaluationResult, "num_fp", &hv_NumFP);
    (*hv_Ratios) = (*hv_Ratios).TupleConcat((hv_NumFP.TupleReal())/hv_NumTotal);
  }
  hv_FullCircleAngle = 2*3.14159;
  GenCircleContourXld(&ho_ContCircle, hv_CenterRow, hv_CenterColumn, hv_Radius+2, 
      HTuple((*hv_Ratios)[0])*hv_FullCircleAngle, hv_FullCircleAngle, "positive", 
      1);
  GetContourXld(ho_ContCircle, &hv_Row, &hv_Col);
  GenContourPolygonXld(&ho_SectorFP, (hv_CenterRow.TupleConcat(hv_Row)).TupleConcat(hv_CenterRow), 
      (hv_CenterColumn.TupleConcat(hv_Col)).TupleConcat(hv_CenterColumn));
  //Rotate.
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_CenterRow, hv_CenterColumn, 
      &hv_HomMat2DRotate);
  AffineTransContourXld(ho_SectorFP, &ho_SectorFP, hv_HomMat2DRotate);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),HTuple(hv_ColorsPieChart[(hv_ColorsPieChart.TupleLength())-1]));
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),3);
  GetContourStyle(hv_WindowHandle, &hv_ContourStyle);
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),"stroke");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_SectorFP, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),hv_ContourStyle);
  return;
}

// Chapter: Deep Learning / Object Detection and Instance Segmentation
// Short Description: Display the evaluation results as pie-charts. 
void dev_display_detection_evaluation_pie_charts (HTuple hv_WindowHandle, HTuple hv_IoUEvaluationResult, 
    HTuple hv_ClassIDs, HTuple hv_Mode, HTuple hv_BaseWindowRow, HTuple hv_BaseWindowColumn)
{

  // Local iconic variables
  HObject  ho_Image;

  // Local control variables
  HTuple  hv_FlushValue, hv_CenterRowOverall, hv_CenterColOverall;
  HTuple  hv_RadiusOverall, hv_ClassChartsPerRow, hv_RadiusClass;
  HTuple  hv_ChartRowDistance, hv_ChartColDistance, hv_StartRow;
  HTuple  hv_StartCol, hv_WindowWidth, hv_WindowHeight, hv_NumColors;
  HTuple  hv_Colors, hv_ColorsFP, hv_Ratios, hv_Descriptions;
  HTuple  hv_IoUThreshold, hv_PercentStr, hv_IndexDescription;
  HTuple  hv_C, hv_CenterRow, hv_CenterCol, hv_ClassEvaluationResult;

  //Display the detailed evaluation results for TP and FP as pie-charts.
  //
  //Switch off automatic flushing to make visualization smooth.
  GetWindowParam(hv_WindowHandle, "flush", &hv_FlushValue);
  SetWindowParam(hv_WindowHandle, "flush", "false");
  //Drawing parameters.
  //Overall pie-chart.
  hv_CenterRowOverall = 150;
  hv_CenterColOverall = 150;
  hv_RadiusOverall = 100;
  //Per-class pie-chart.
  hv_ClassChartsPerRow = 10;
  hv_RadiusClass = 40;
  hv_ChartRowDistance = 3*hv_RadiusClass;
  hv_ChartColDistance = 2.5*hv_RadiusClass;
  hv_StartRow = (hv_CenterRowOverall+(1.5*hv_RadiusOverall))+(1.5*hv_RadiusClass);
  hv_StartCol = 1.5*hv_RadiusClass;
  //
  //Open Window and set font.
  hv_WindowWidth = HTuple(600).TupleMax2((((HTuple(hv_ClassIDs.TupleLength()).TupleMin2(hv_ClassChartsPerRow))-1)*hv_ChartColDistance)+(2*hv_StartCol));
  hv_WindowHeight = (3*hv_RadiusOverall)+(((((HTuple(hv_ClassIDs.TupleLength()).TupleReal())/hv_ClassChartsPerRow).TupleCeil())*3)*hv_RadiusClass);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),hv_BaseWindowRow, hv_BaseWindowColumn, 
        hv_WindowWidth, hv_WindowHeight);
  GenImageConst(&ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  set_display_font(hv_WindowHandle, 15, "mono", "true", "false");
  //
  //Generate different red colors for false positive categories.
  if (0 != (int(hv_Mode==HTuple("precision"))))
  {
    hv_NumColors = 7;
  }
  else
  {
    hv_NumColors = 2;
  }
  hv_Colors = HTuple(hv_NumColors,"");
  hv_Colors[0] = "green";
  hv_Colors[hv_NumColors-1] = "red";
  get_distinct_colors(hv_NumColors-1, 0, 10, 45, &hv_ColorsFP);
  hv_Colors[HTuple::TupleGenSequence(1,hv_NumColors-2,1)] = hv_ColorsFP.TupleSelectRange(1,(hv_ColorsFP.TupleLength())-1);
  //
  dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_IoUEvaluationResult, 
      hv_CenterRowOverall, hv_Mode, hv_CenterColOverall, hv_RadiusOverall, hv_Colors, 
      "All classes", &hv_Ratios);
  //
  //Write descriptions for overall pie-chart.
  if (0 != (int((hv_Ratios.TupleLength())>1)))
  {
    if (0 != (int(hv_Mode==HTuple("precision"))))
    {
      hv_Descriptions.Clear();
      hv_Descriptions[0] = "true positives";
      hv_Descriptions[1] = "false positives: wrong class";
      hv_Descriptions[2] = "false positives: background";
      hv_Descriptions[3] = "false positives: bad localization";
      hv_Descriptions[4] = "false positives: duplicate";
      hv_Descriptions[5] = "false positives: multiple reasons";
      hv_Descriptions[6] = "false positives: total";
    }
    else
    {
      hv_Descriptions.Clear();
      hv_Descriptions[0] = "recall (TP / (TP + FN))";
      hv_Descriptions[1] = "false negatives";
    }
    GetDictTuple(hv_IoUEvaluationResult, "iou_threshold", &hv_IoUThreshold);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"Results @ IoU: "+hv_IoUThreshold, "image", 
          20, (hv_CenterColOverall+hv_RadiusOverall)+20, "white", "box", "false");
    hv_PercentStr = ((hv_Ratios*100).TupleString(".1f"))+"";
    {
    HTuple end_val52 = (hv_Descriptions.TupleLength())-2;
    HTuple step_val52 = 1;
    for (hv_IndexDescription=0; hv_IndexDescription.Continue(end_val52, step_val52); hv_IndexDescription += step_val52)
    {
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),(HTuple(hv_PercentStr[hv_IndexDescription])+"%: ")+HTuple(hv_Descriptions[hv_IndexDescription]), 
            "image", 30+((hv_IndexDescription+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
            HTuple(hv_Colors[hv_IndexDescription]), "box", "false");
    }
    }
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),(HTuple(hv_PercentStr[hv_IndexDescription])+"%: ")+HTuple(hv_Descriptions[hv_IndexDescription]), 
          "image", 30+((hv_IndexDescription+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
          HTuple(hv_Colors[hv_IndexDescription]), "box", "false");
  }
  else
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),"There are no predictions", "image", 
          30, (hv_CenterColOverall+hv_RadiusOverall)+20, "white", "box", "false");
  }
  //
  //
  //Per-class pie-charts.
  //
  {
  HTuple end_val63 = (hv_ClassIDs.TupleLength())-1;
  HTuple step_val63 = 1;
  for (hv_C=0; hv_C.Continue(end_val63, step_val63); hv_C += step_val63)
  {
    //Get the position of the class-pie-chart.
    hv_CenterRow = hv_StartRow+((((hv_C.TupleReal())/hv_ClassChartsPerRow).TupleFloor())*hv_ChartRowDistance);
    hv_CenterCol = hv_StartCol+((hv_C%hv_ClassChartsPerRow)*hv_ChartColDistance);
    GetDictTuple(hv_IoUEvaluationResult, "class_"+HTuple(hv_ClassIDs[hv_C]), &hv_ClassEvaluationResult);
    dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_ClassEvaluationResult, 
        hv_CenterRow, hv_Mode, hv_CenterCol, hv_RadiusClass, hv_Colors, "Class "+HTuple(hv_ClassIDs[hv_C]), 
        &hv_Ratios);
  }
  }
  //
  //Flush buffer and reset value for 'flush'.
  FlushBuffer(hv_WindowHandle);
  SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Visualize 3D data for a sample. 
void dev_display_dl_3d_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
    HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables
  HObject  ho_Image, ho_Dummy;

  // Local control variables
  HTuple  hv_Params, hv_GenParamNames, hv_ParamIndex;
  HTuple  hv_GenParamName, hv_KeyExists, hv_SampleKeys, hv_MetaInfoExists;
  HTuple  hv_PrevWindowCoordinates, hv_PointCloudWindowExists;
  HTuple  hv_Keys, hv_LastWindowName, hv_MetaInformation;
  HTuple  hv_WidthImage, hv_HeightImage, hv_CurrentWindowHandle;
  HTuple  hv_WindowImageRatio, hv_Flush, hv___Tmp_Ctrl_Dict_Init_1;
  HTuple  hv___Tmp_Ctrl_Dict_Init_2, hv___Tmp_Ctrl_Type;

  //
  //This procedure displays 3D visualizations of the content of
  //the provided DLSample and/or DLResult depending on the
  //input string KeysForDisplay.
  //
  //Please note that a blocking window is opened showing a 3D
  //point cloud. The window has a continue button that has to
  //be pressed to end the blocking.
  //
  //The visualization can be adapted with GenParam.
  //
  //** Set the default values: ***
  CreateDict(&hv_Params);
  //
  //Define the screen width when a new window row is started.
  SetDictTuple(hv_Params, "threshold_width", 1024);
  //Since potentially a lot of windows are opened,
  //scale the windows consistently.
  SetDictTuple(hv_Params, "scale_windows", 0.8);
  //Set a font and a font size.
  SetDictTuple(hv_Params, "font", "mono");
  SetDictTuple(hv_Params, "font_size", 14);
  //
  //By default, display a description on the bottom.
  SetDictTuple(hv_Params, "display_bottom_desc", 1);
  //Define parameter values specifically for point cloud and
  //gripping pose visualization.
  SetDictTuple(hv_Params, "arrow_thickness", 0.005);
  SetDictTuple(hv_Params, "arrow_length", 0.1);
  SetDictTuple(hv_Params, "sample_point_cloud", "false");
  SetDictTuple(hv_Params, "point_cloud_sample_distance", 10);
  SetDictTuple(hv_Params, "point_cloud_color", HTuple());
  SetDictTuple(hv_Params, "show_normals", "false");
  SetDictTuple(hv_Params, "normal_color", HTuple());
  //** Set user-defined values: ***
  //
  //Overwrite default values by given generic parameters.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamNames);
    {
    HTuple end_val39 = (hv_GenParamNames.TupleLength())-1;
    HTuple step_val39 = 1;
    for (hv_ParamIndex=0; hv_ParamIndex.Continue(end_val39, step_val39); hv_ParamIndex += step_val39)
    {
      hv_GenParamName = HTuple(hv_GenParamNames[hv_ParamIndex]);
      GetDictParam(hv_Params, "key_exists", hv_GenParamName, &hv_KeyExists);
      if (0 != (hv_KeyExists.TupleNot()))
      {
        throw HException(("Unknown generic parameter: "+hv_GenParamName)+".");
      }
      GetDictParam(hv_GenParam, "key_data_type", hv_GenParamName, &hv___Tmp_Ctrl_Type);
      if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
      {
        SetDictObject(hv_GenParam.TupleGetDictObject(hv_GenParamName), hv_Params, 
            hv_GenParamName);
      }
      else
      {
        SetDictTuple(hv_Params, hv_GenParamName, hv_GenParam.TupleGetDictTuple(hv_GenParamName));
      }
    }
    }
  }
  //
  //Nothing to do if nothing should be displayed.
  if (0 != (int((hv_KeysForDisplay.TupleLength())==0)))
  {
    return;
  }
  //
  //Check allowed keys.
  if (0 != (HTuple(int((hv_KeysForDisplay.TupleLength())!=1)).TupleOr(int(HTuple(hv_KeysForDisplay[0])!=HTuple("gripping_point_cloud")))))
  {
    throw HException("Only 'gripping_point_cloud' display is currently supported.");
  }
  //
  //Check if all information to display the object model
  //are present.
  GetDictParam(hv_DLSample, "keys", HTuple(), &hv_SampleKeys);
  get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
  get_dl_sample_image(&ho_Dummy, hv_SampleKeys, hv_DLSample, "x");
  get_dl_sample_image(&ho_Dummy, hv_SampleKeys, hv_DLSample, "y");
  get_dl_sample_image(&ho_Dummy, hv_SampleKeys, hv_DLSample, "z");
  CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
  SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
  if (0 != ((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1)).TupleTestEqualDictItem("show_normals","comp")))
  {
    get_dl_sample_image(&ho_Dummy, hv_SampleKeys, hv_DLSample, "normals");
  }
  hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
  //
  //Get or open next window.
  //
  //For better usage, add meta information about the window
  //handles in WindowHandleDict if necessary.
  GetDictParam(hv_WindowHandleDict, "key_exists", "meta_information", &hv_MetaInfoExists);
  if (0 != (hv_MetaInfoExists.TupleNot()))
  {
    CreateDict(&hv___Tmp_Ctrl_Dict_Init_2);
    SetDictTuple(hv_WindowHandleDict, "meta_information", hv___Tmp_Ctrl_Dict_Init_2);
    hv___Tmp_Ctrl_Dict_Init_2 = HTuple::TupleConstant("HNULL");
  }
  //If there is not already a 'gripping_point_cloud' window in the
  //WindowHandleDict we query the coordinates of the last
  //window to position the window.
  hv_PrevWindowCoordinates.Clear();
  hv_PrevWindowCoordinates[0] = 0;
  hv_PrevWindowCoordinates[1] = 0;
  hv_PrevWindowCoordinates[2] = 0;
  hv_PrevWindowCoordinates[3] = 0;
  //
  GetDictParam(hv_WindowHandleDict, "key_exists", "gripping_point_cloud", &hv_PointCloudWindowExists);
  if (0 != (hv_PointCloudWindowExists.TupleNot()))
  {
    GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_Keys);
    if (0 != (int((hv_Keys.TupleLength())>=2)))
    {
      //If we have one window we will also have the
      //cooresponding meta information, hence at least
      //two keys. If we have less than two keys we
      //assume that there is no window yet.
      hv_LastWindowName = ((const HTuple&)hv_Keys)[(hv_Keys.TupleLength())-1];
      hv_MetaInformation = hv_WindowHandleDict.TupleGetDictTuple("meta_information");
      hv_PrevWindowCoordinates = hv_MetaInformation.TupleGetDictTuple(hv_LastWindowName+"_window_coordinates");
    }
  }
  GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
  get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
      hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
      0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
      hv_PrevWindowCoordinates, hv_WindowHandleDict, "gripping_point_cloud", &hv_CurrentWindowHandle, 
      &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
  //
  //Display the point cloud together with the 3D gripping
  //pose.
  GetWindowParam(hv_CurrentWindowHandle, "flush", &hv_Flush);
  SetWindowParam(hv_CurrentWindowHandle, "flush", "true");
  visualize_point_cloud_and_gripping_pose(hv_DLSample, hv_DLResult, hv_Params, hv_CurrentWindowHandle);
  SetWindowParam(hv_CurrentWindowHandle, "flush", hv_Flush);
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Visualize different images, annotations and inference results for a sample. 
void dev_display_dl_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
    HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables
  HObject  ho_Image, ho_Domain, ho_GrippingMapImageResult;
  HObject  ho_Cross, ho_GrippingMapGroundTruth, ho_X, ho_Y;
  HObject  ho_Z, ho_AnomalyImage, ho_AnomalyRegion, ho_ConfidenceImage;
  HObject  ho_HeatmapScene, ho_ScoreMaps, ho_CharacterScoreMap;
  HObject  ho_LinkScoreMap, ho_OrientationSinScoreMap, ho_OrientationCosScoreMap;
  HObject  ho_ScoreMap, ho_OrientationScoreMap, ho_PredictionColorFrame;
  HObject  ho_ImageHeatmap, ho_PredictionSymbol, ho_CrossLineH;
  HObject  ho_CrossLineV, ho_ImageConfidence, ho_SegmentationImagGroundTruth;
  HObject  ho_SegmentationImageResult, ho_ImageAbsDiff, ho_DiffRegion;
  HObject  ho_ImageWeight;

  // Local control variables
  HTuple  hv_Params, hv_GenParamNames, hv_ParamIndex;
  HTuple  hv_GenParamName, hv_KeyExists, hv_SampleKeys, hv_ResultKeys;
  HTuple  hv_ImageIDExists, hv_ImageID, hv_ImageIDString;
  HTuple  hv_ImageIDStringBraces, hv_ImageIDStringCapital;
  HTuple  hv_IsOCRDetection, hv_AdditionalGreenClassNames;
  HTuple  hv_KeyIndex, hv_OcrResult, hv_MaxClassIdSample;
  HTuple  hv_EmptySample, hv_MaxClassIdResult, hv_EmptyResult;
  HTuple  hv_MaxClassId, hv_ClassNames, hv_ClassIDs, hv_ClassNameKey;
  HTuple  hv_ClassIdKey, hv_ResultClassNames, hv_ResultClassIds;
  HTuple  hv_SortIndices, hv_UniqueClassIds, hv_UniqueClassNames;
  HTuple  hv_Colors, hv_ClassesLegend, hv_InvalidInput, hv_ClassKeys;
  HTuple  hv_ClassKeysExist, hv_DLDatasetInfoKeys, hv_Index;
  HTuple  hv_PrevWindowCoordinates, hv_Keys, hv_Exception;
  HTuple  hv_MetaInfoExists, hv_FlushValues, hv_WindowHandleKeys;
  HTuple  hv_WindowHandles, hv_WindowIndex, hv_FlushValue;
  HTuple  hv_WidthImage, hv_HeightImage, hv_CurrentWindowHandle;
  HTuple  hv_WindowImageRatio, hv_ColorsGrippingGroundTruth;
  HTuple  hv_ImageClassIDs, hv_GrippingPointsExists, hv_Rows;
  HTuple  hv_Columns, hv_AnomalyImages, hv_PossibleKeysForDisplay;
  HTuple  hv_AddDisplayKey, hv_AnomalyLabelGroundTruth, hv_AnomalyLabelIDGroundTruth;
  HTuple  hv_AnomalyResultPostfix, hv_AnomalyScore, hv_AnomalyClassID;
  HTuple  hv_AnomalyClassThresholdDisplay, hv_AnomalyRegionThresholdDisplay;
  HTuple  hv_WindowHandleName, hv_AnomalyRegionGroundTruthExists;
  HTuple  hv_Text, hv_PredictionColor, hv_LineColors, hv_ResultColorOffset;
  HTuple  hv_AnomalyRegionExists, hv_AnomalyImageKey, hv_AnomalyScoreKey;
  HTuple  hv_AnomalyResultKey, hv_AnomalyRegionKey, hv_DisplayDirectionTemp;
  HTuple  hv_BboxLabelIndex, hv_BboxConfidences, hv_TextConf;
  HTuple  hv_BboxClassIndex, hv_BboxColorsBoth, hv_BboxClassLabelIndexUniq;
  HTuple  hv_BboxIDs, hv_BboxColors, hv_BboxIDsUniq, hv_BboxColorsResults;
  HTuple  hv_BboxClassIndexUniq, hv_ClassificationLabelIDGroundTruth;
  HTuple  hv_ClassificationLabelIDResult, hv_PredictionText;
  HTuple  hv_BoarderOffset, hv_MetaInfo, hv_WindowImageRatioHeight;
  HTuple  hv_WindowImageRatioWidth, hv_BoarderOffsetRow, hv_BoarderOffsetCol;
  HTuple  hv_MarginBottom, hv_WindowCoordinates, hv_CurrentWindowHeight;
  HTuple  hv__, hv_MaxHeight, hv_SelectedHeatmapMethod, hv_DictHeatmap;
  HTuple  hv_MethodName, hv_HeatmapKeys, hv_HeatmapImageName;
  HTuple  hv_TargetClassID, hv_Confidences, hv_MaxDeviation;
  HTuple  hv_ClassificationLabelNameResult, hv_TargetClassConfidence;
  HTuple  hv_ClassificationLabelNamesGroundTruth, hv_ShowGT;
  HTuple  hv_ShowResult, hv_NumLines, hv_Type, hv_GTWordKeyExists;
  HTuple  hv_HeightWindow, hv_HeightMarginBottom, hv_Size;
  HTuple  hv_Length, hv_Row, hv_Column, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DCompose, hv_PredictionForegroundColor;
  HTuple  hv_PredictionBackgroundColor, hv_Spaces, hv_ConfidenceColors;
  HTuple  hv_ColorsResults, hv_GroundTruthIDs, hv_ResultIDs;
  HTuple  hv_ImageClassIDsUniq, hv_ImageClassIDsIndices, hv_ImageClassIDsIndex;
  HTuple  hv_StringSegExcludeClassIDs, hv_StringIndex, hv_Min;
  HTuple  hv_Max, hv_Range, hv_ColorsSegmentation, hv_DrawMode;
  HTuple  hv_Width, hv_MinWeight, hv_WeightsColors, hv_Indices;
  HTuple  hv_WindowHandleKeysNew, hv___Tmp_Ctrl_Dict_Init_1;
  HTuple  hv___Tmp_Ctrl_Dict_Init_2, hv___Tmp_Ctrl_Dict_Init_3;
  HTuple  hv___Tmp_Ctrl_Dict_Init_4, hv___Tmp_Ctrl_Dict_Init_5;
  HTuple  hv___Tmp_Ctrl_Dict_Init_6, hv___Tmp_Ctrl_Dict_Init_7;
  HTuple  hv___Tmp_Ctrl_1, hv___Tmp_Ctrl_Type;

  //
  //This procedure displays the content of the provided DLSample and/or DLResult
  //depending on the input string KeysForDisplay.
  //DLDatasetInfo is a dictionary containing the information about the dataset.
  //The visualization can be adapted with GenParam.
  //
  //** Set the default values: ***
  CreateDict(&hv_Params);
  //
  //Define the screen width when a new window row is started.
  SetDictTuple(hv_Params, "threshold_width", 1024);
  //Since potentially a lot of windows are opened,
  //scale the windows consistently.
  SetDictTuple(hv_Params, "scale_windows", 0.8);
  //Set a font and a font size.
  SetDictTuple(hv_Params, "font", "mono");
  SetDictTuple(hv_Params, "font_size", 14);
  //
  SetDictTuple(hv_Params, "line_width", 2);
  SetDictTuple(hv_Params, "map_transparency", "cc");
  SetDictTuple(hv_Params, "map_color_bar_width", 140);
  //
  //Define parameter values specifically for 3d_gripping_point_detection
  SetDictTuple(hv_Params, "gripping_point_color", "#00FF0099");
  SetDictTuple(hv_Params, "gripping_point_size", 6);
  SetDictTuple(hv_Params, "region_color", "#FF000040");
  SetDictTuple(hv_Params, "gripping_point_map_color", "#83000080");
  SetDictTuple(hv_Params, "gripping_point_background_color", "#00007F80");
  //
  //Define parameter values specifically for anomaly detection
  //and Global Context Anomaly Detection.
  SetDictTuple(hv_Params, "anomaly_region_threshold", -1);
  SetDictTuple(hv_Params, "anomaly_classification_threshold", -1);
  SetDictTuple(hv_Params, "anomaly_region_label_color", "#40e0d0");
  SetDictTuple(hv_Params, "anomaly_color_transparency", "40");
  SetDictTuple(hv_Params, "anomaly_region_result_color", "#ff0000c0");
  //
  //Define segmentation-specific parameter values.
  SetDictTuple(hv_Params, "segmentation_max_weight", 0);
  SetDictTuple(hv_Params, "segmentation_draw", "fill");
  SetDictTuple(hv_Params, "segmentation_transparency", "aa");
  SetDictTuple(hv_Params, "segmentation_exclude_class_ids", HTuple());
  //
  //Define bounding box-specific parameter values.
  SetDictTuple(hv_Params, "bbox_label_color", HTuple("#000000")+"99");
  SetDictTuple(hv_Params, "bbox_display_confidence", 1);
  SetDictTuple(hv_Params, "bbox_text_color", "#eeeeee");
  //
  //By default, display a description on the bottom.
  SetDictTuple(hv_Params, "display_bottom_desc", 1);
  //
  //By default, show a legend with class IDs.
  SetDictTuple(hv_Params, "display_legend", 1);
  //
  //By default, show the anomaly ground truth regions.
  SetDictTuple(hv_Params, "display_ground_truth_anomaly_regions", 1);
  //
  //By default, show class IDs and color frames for classification ground truth/results.
  SetDictTuple(hv_Params, "display_classification_ids", 1);
  SetDictTuple(hv_Params, "display_classification_color_frame", 1);
  //
  //By default, show class labels for detection ground truth/results.
  SetDictTuple(hv_Params, "display_labels", 1);
  //
  //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
  SetDictTuple(hv_Params, "display_direction", 1);
  //
  //By default, use color scheme 'Jet' for the heatmap display.
  SetDictTuple(hv_Params, "heatmap_color_scheme", "jet");
  //** Set user-defined values: ***
  //
  //Overwrite default values by given generic parameters.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamNames);
    {
    HTuple end_val74 = (hv_GenParamNames.TupleLength())-1;
    HTuple step_val74 = 1;
    for (hv_ParamIndex=0; hv_ParamIndex.Continue(end_val74, step_val74); hv_ParamIndex += step_val74)
    {
      hv_GenParamName = HTuple(hv_GenParamNames[hv_ParamIndex]);
      GetDictParam(hv_Params, "key_exists", hv_GenParamName, &hv_KeyExists);
      if (0 != (hv_KeyExists.TupleNot()))
      {
        throw HException(("Unknown generic parameter: "+hv_GenParamName)+".");
      }
      GetDictParam(hv_GenParam, "key_data_type", hv_GenParamName, &hv___Tmp_Ctrl_Type);
      if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
      {
        SetDictObject(hv_GenParam.TupleGetDictObject(hv_GenParamName), hv_Params, 
            hv_GenParamName);
      }
      else
      {
        SetDictTuple(hv_Params, hv_GenParamName, hv_GenParam.TupleGetDictTuple(hv_GenParamName));
      }
    }
    }
  }
  //
  if (0 != (HTuple(int((hv_DLSample.TupleLength())>1)).TupleOr(int((hv_DLResult.TupleLength())>1))))
  {
    throw HException("Only a single dictionary for DLSample and DLResult is allowed");
  }
  //
  //Get the dictionary keys.
  GetDictParam(hv_DLSample, "keys", HTuple(), &hv_SampleKeys);
  if (0 != (int(hv_DLResult!=HTuple())))
  {
    GetDictParam(hv_DLResult, "keys", HTuple(), &hv_ResultKeys);
  }
  //
  //Get image ID if it is available.
  GetDictParam(hv_DLSample, "key_exists", "image_id", &hv_ImageIDExists);
  if (0 != hv_ImageIDExists)
  {
    GetDictTuple(hv_DLSample, "image_id", &hv_ImageID);
    hv_ImageIDString = "image ID "+hv_ImageID;
    hv_ImageIDStringBraces = ("(image ID "+hv_ImageID)+")";
    hv_ImageIDStringCapital = "Image ID "+hv_ImageID;
  }
  else
  {
    hv_ImageIDString = "";
    hv_ImageIDStringBraces = hv_ImageIDString;
    hv_ImageIDStringCapital = hv_ImageIDString;
  }
  //
  //** Convert a Deep OCR Detection result to an Object Detection result if necessary ***
  //
  hv_IsOCRDetection = 0;
  hv_AdditionalGreenClassNames = HTuple();
  hv_KeyIndex = 0;
  {
  HTuple end_val117 = (hv_KeysForDisplay.TupleLength())-1;
  HTuple step_val117 = 1;
  for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val117, step_val117); hv_KeyIndex += step_val117)
  {
    //Check if Deep OCR Detection case
    TupleStrstr(HTuple(hv_KeysForDisplay[hv_KeyIndex]), "ocr_detection", &hv_IsOCRDetection);
    hv_IsOCRDetection = int(hv_IsOCRDetection==0);
    if (0 != hv_IsOCRDetection)
    {
      //Turn off labels
      SetDictTuple(hv_Params, "bbox_display_confidence", 0);
      SetDictTuple(hv_Params, "display_labels", 0);
      //Mark the class 'word' as green
      hv_AdditionalGreenClassNames = "word";
      if (0 != (int(hv_DLResult!=HTuple())))
      {
        hv_OcrResult = hv_DLResult;
        convert_ocr_detection_result_to_object_detection(hv_OcrResult, &hv_DLResult);
        GetDictParam(hv_DLResult, "keys", HTuple(), &hv_ResultKeys);
        break;
      }
    }
  }
  }
  //
  //Check if DLDatasetInfo is valid.
  //
  if (0 != (int(hv_DLDatasetInfo==HTuple())))
  {
    dev_display_dl_data_get_max_class_id(hv_DLSample, &hv_MaxClassIdSample, &hv_EmptySample);
    dev_display_dl_data_get_max_class_id(hv_DLResult, &hv_MaxClassIdResult, &hv_EmptyResult);
    hv_MaxClassId = hv_MaxClassIdSample.TupleMax2(hv_MaxClassIdResult);
    if (0 != (hv_EmptySample.TupleAnd(hv_EmptyResult)))
    {
      hv_MaxClassId = 1;
    }
    if (0 != (int(hv_MaxClassId==-1)))
    {
      hv_MaxClassId = 1000;
    }
    if (0 != hv_IsOCRDetection)
    {
      hv_ClassNames.Clear();
      hv_ClassNames[0] = "word";
      hv_ClassNames[1] = "char";
      hv_ClassNames[2] = "ignore";
      TupleGenSequence(0, (hv_ClassNames.TupleLength())-1, 1, &hv_ClassIDs);
    }
    else
    {
      TupleGenSequence(0, hv_MaxClassId, 1, &hv_ClassIDs);
      TupleGenConst(hv_MaxClassId+1, "unknown", &hv_ClassNames);
    }
    //Try to get the class names from the result dictionary.
    //This works only for detection and classification results.
    if (0 != (int(hv_DLResult!=HTuple())))
    {
      TupleRegexpSelect(hv_ResultKeys, ".*class_name.*", &hv_ClassNameKey);
      TupleRegexpSelect(hv_ResultKeys, ".*class_id.*", &hv_ClassIdKey);
      if (0 != (HTuple(int((hv_ClassNameKey.TupleLength())==1)).TupleAnd(int((hv_ClassIdKey.TupleLength())==1))))
      {
        GetDictTuple(hv_DLResult, hv_ClassNameKey, &hv_ResultClassNames);
        GetDictTuple(hv_DLResult, hv_ClassIdKey, &hv_ResultClassIds);
        TupleSortIndex(hv_ResultClassIds, &hv_SortIndices);
        TupleUniq(HTuple(hv_ResultClassIds[hv_SortIndices]), &hv_UniqueClassIds);
        TupleUniq(HTuple(hv_ResultClassNames[hv_SortIndices]), &hv_UniqueClassNames);
        hv_ClassNames[hv_UniqueClassIds] = hv_UniqueClassNames;
      }
    }
    get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, &hv_Colors);
    hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
    hv_InvalidInput = 0;
  }
  else
  {
    //Check if DLDatasetInfo contains necessary keys.
    hv_ClassKeys.Clear();
    hv_ClassKeys[0] = "class_names";
    hv_ClassKeys[1] = "class_ids";
    GetHandleParam(hv_DLDatasetInfo, "key_exists", hv_ClassKeys, &hv_ClassKeysExist);
    if (0 != (int((hv_ClassKeysExist.TupleMin())==0)))
    {
      //In that case we expect that the class names and ids are never used.
    }
    else
    {
      GetHandleParam(hv_DLDatasetInfo, "keys", HTuple(), &hv_DLDatasetInfoKeys);
      {
      HTuple end_val180 = (hv_ClassKeys.TupleLength())-1;
      HTuple step_val180 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val180, step_val180); hv_Index += step_val180)
      {
        if (0 != (int((hv_DLDatasetInfoKeys.TupleFindFirst(HTuple(hv_ClassKeys[hv_Index])))==-1)))
        {
          throw HException(("Key "+HTuple(hv_ClassKeys[hv_Index]))+" is missing in DLDatasetInfo.");
        }
      }
      }
      //
      //Get the general dataset information, if available.
      GetHandleTuple(hv_DLDatasetInfo, "class_names", &hv_ClassNames);
      GetHandleTuple(hv_DLDatasetInfo, "class_ids", &hv_ClassIDs);
      //
      //Define distinct colors for the classes.
      get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, &hv_Colors);
      //
      hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
    }
  }
  //
  //** Set window parameters: ***
  //
  //Set previous window coordinates.
  hv_PrevWindowCoordinates.Clear();
  hv_PrevWindowCoordinates[0] = 0;
  hv_PrevWindowCoordinates[1] = 0;
  hv_PrevWindowCoordinates[2] = 0;
  hv_PrevWindowCoordinates[3] = 0;
  //
  //Check that the WindowHandleDict is of type dictionary.
  try
  {
    GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_Keys);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    if (0 != (int(HTuple(hv_Exception[0])==1401)))
    {
      throw HException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
    }
    else
    {
      throw HException(hv_Exception);
    }
  }
  //For better usage, add meta information about the window handles in WindowHandleDict.
  GetDictParam(hv_WindowHandleDict, "key_exists", "meta_information", &hv_MetaInfoExists);
  if (0 != (hv_MetaInfoExists.TupleNot()))
  {
    CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
    SetDictTuple(hv_WindowHandleDict, "meta_information", hv___Tmp_Ctrl_Dict_Init_1);
    hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
  }
  //
  //For each window, set 'flush' to 'false' to avoid flickering.
  hv_FlushValues = HTuple();
  GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_WindowHandleKeys);
  {
  HTuple end_val223 = (hv_WindowHandleKeys.TupleLength())-1;
  HTuple step_val223 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val223, step_val223); hv_Index += step_val223)
  {
    //Only consider the WindowHandleKeys that are needed for the current visualization.
    hv_KeyIndex = hv_KeysForDisplay.TupleFind(HTuple(hv_WindowHandleKeys[hv_Index]));
    if (0 != (HTuple(int(hv_KeyIndex!=-1)).TupleAnd(int(hv_KeyIndex!=HTuple()))))
    {
      GetDictTuple(hv_WindowHandleDict, HTuple(hv_WindowHandleKeys[hv_Index]), &hv_WindowHandles);
      {
      HTuple end_val228 = (hv_WindowHandles.TupleLength())-1;
      HTuple step_val228 = 1;
      for (hv_WindowIndex=0; hv_WindowIndex.Continue(end_val228, step_val228); hv_WindowIndex += step_val228)
      {
        GetWindowParam(HTuple(hv_WindowHandles[hv_WindowIndex]), "flush", &hv_FlushValue);
        hv_FlushValues = hv_FlushValues.TupleConcat(hv_FlushValue);
        SetWindowParam(HTuple(hv_WindowHandles[hv_WindowIndex]), "flush", "false");
      }
      }
    }
  }
  }
  //
  //** Display the data: ***
  //
  //Display data dictionaries.
  hv_KeyIndex = 0;
  while (0 != (int(hv_KeyIndex<(hv_KeysForDisplay.TupleLength()))))
  {
    //
    //Is it an Deep OCR detection case?
    TupleStrstr(HTuple(hv_KeysForDisplay[hv_KeyIndex]), "ocr_detection", &hv_IsOCRDetection);
    hv_IsOCRDetection = int(hv_IsOCRDetection==0);
    //
    if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("image"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("image_with_domain"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      GetDomain(ho_Image, &ho_Domain);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("region_color"));
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Domain, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("normals"))))
    {
      //
      //Normal image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_confidence"))))
    {
      //
      //Confidence image.
      if (0 != (int(hv_DLResult==HTuple())))
      {
        throw HException("DLResult dict is empty.");
      }
      if (0 != (int((hv_ResultKeys.TupleFind(HTuple(hv_KeysForDisplay[hv_KeyIndex])))!=-1)))
      {
        GetDictObject(&ho_Image, hv_DLResult, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      }
      else
      {
        throw HException(("Image with key '"+HTuple(hv_KeysForDisplay[hv_KeyIndex]))+"' could not be found in DLResult.");
      }
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),"Gripping confidence", "window", "top", 
            "left", "black", "box", "true");
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_map"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Gripping map image result.
      if (0 != (int(hv_DLResult==HTuple())))
      {
        throw HException("DLResult dict is empty.");
      }
      if (0 != (int((hv_ResultKeys.TupleFind("gripping_map"))!=-1)))
      {
        GetDictObject(&ho_GrippingMapImageResult, hv_DLResult, "gripping_map");
      }
      else
      {
        throw HException(HTuple(HTuple("Image with key '")+"gripping_map")+"' could not be found in DLResult.");
      }
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      SetWindowParam(hv_CurrentWindowHandle, "background_color", "#000000");
      if (HDevWindowStack::IsOpen())
        ClearWindow(HDevWindowStack::GetActive());
      GetDomain(ho_GrippingMapImageResult, &ho_Domain);
      ReduceDomain(ho_Image, ho_Domain, &ho_Image);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //Display gripping regions.
      hv_ColorsGrippingGroundTruth.Clear();
      hv_ColorsGrippingGroundTruth.Append(hv_Params.TupleGetDictTuple("gripping_point_map_color"));
      hv_ColorsGrippingGroundTruth.Append(hv_Params.TupleGetDictTuple("gripping_point_background_color"));
      dev_display_segmentation_regions(ho_GrippingMapImageResult, (HTuple(1).Append(0)), 
          hv_ColorsGrippingGroundTruth, HTuple(), &hv_ImageClassIDs);
      //Display gripping points.
      GetDictParam(hv_DLResult, "key_exists", "gripping_points", &hv_GrippingPointsExists);
      if (0 != hv_GrippingPointsExists)
      {
        get_gripping_points_from_dict(hv_DLResult, &hv_Rows, &hv_Columns);
        GenCrossContourXld(&ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple("gripping_point_size"), 
            0.785398);
        if (HDevWindowStack::IsOpen())
          SetLineWidth(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("line_width"));
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("gripping_point_color"));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Cross, HDevWindowStack::GetActive());
      }
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_map_ground_truth"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Gripping map ground truth.
      if (0 != (int((hv_SampleKeys.TupleFind("segmentation_image"))!=-1)))
      {
        GetDictObject(&ho_GrippingMapGroundTruth, hv_DLSample, "segmentation_image");
      }
      else
      {
        throw HException(HTuple(HTuple("Image with key '")+"segmentation_image")+"' could not be found in DLSample.");
      }
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display gripping regions.
      hv_ColorsGrippingGroundTruth.Clear();
      hv_ColorsGrippingGroundTruth.Append(hv_Params.TupleGetDictTuple("gripping_point_map_color"));
      hv_ColorsGrippingGroundTruth.Append(hv_Params.TupleGetDictTuple("gripping_point_background_color"));
      dev_display_segmentation_regions(ho_GrippingMapGroundTruth, hv_ClassIDs, hv_ColorsGrippingGroundTruth, 
          HTuple(), &hv_ImageClassIDs);
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),"Gripping map ground truth", "window", 
            "top", "left", "black", "box", "true");
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("x"))))
    {
      //
      //X.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("xyz"))))
    {
      //
      //XYZ.
      get_dl_sample_image(&ho_X, hv_SampleKeys, hv_DLSample, "x");
      get_dl_sample_image(&ho_Y, hv_SampleKeys, hv_DLSample, "y");
      get_dl_sample_image(&ho_Z, hv_SampleKeys, hv_DLSample, "z");
      Compose3(ho_X, ho_Y, ho_Z, &ho_Image);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("y"))))
    {
      //
      //Y.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("z"))))
    {
      //
      //Z.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, HTuple(hv_KeysForDisplay[hv_KeyIndex]));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_point_cloud"))))
    {
      //
      //In case of 'gripping_point_cloud' provide a window that can be used by the procedure
      //dev_display_dl_3d_data. No actual drawing happens  in this procedure to keep it
      //free from operators not belonging either to the Foundation or Deep Learning
      //license modules.
      GetDictParam(hv_DLSample, "keys", HTuple(), &hv_SampleKeys);
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Do nothing here and draw later
      //
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_both"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_both_local")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_both_global")))))
    {
      //
      //In case of 'anomaly_both', also plot 'anomaly_both_local'
      //and 'anomaly_both_global', if available.
      TupleRegexpSelect(hv_ResultKeys, ".*anomaly_image.*", &hv_AnomalyImages);
      if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_both"))))
      {
        TupleRegexpReplace(hv_AnomalyImages, "image", "both", &hv_PossibleKeysForDisplay);
        hv_AddDisplayKey = 0;
        {
        HTuple end_val464 = (hv_PossibleKeysForDisplay.TupleLength())-1;
        HTuple step_val464 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val464, step_val464); hv_Index += step_val464)
        {
          if (0 != (int((hv_KeysForDisplay.TupleFindFirst(HTuple(hv_PossibleKeysForDisplay[hv_Index])))==-1)))
          {
            hv_KeysForDisplay = hv_KeysForDisplay.TupleConcat(HTuple(hv_PossibleKeysForDisplay[hv_Index]));
            hv_AddDisplayKey = 1;
          }
        }
        }
        //
        //Display not possible for 'anomaly_both' if key 'anomaly_image' is missing.
        if (0 != (HTuple(int((hv_PossibleKeysForDisplay.TupleFindFirst(HTuple(hv_KeysForDisplay[hv_KeyIndex])))==-1)).TupleAnd(hv_AddDisplayKey)))
        {
          hv_KeyIndex += 1;
          continue;
        }
      }
      //
      //Get image and ground truth.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, &hv_AnomalyLabelGroundTruth, 
          &hv_AnomalyLabelIDGroundTruth);
      //
      //Get the anomaly results either by applying the specified thresholds or out of DLResult.
      TupleRegexpMatch(HTuple(hv_KeysForDisplay[hv_KeyIndex]), "anomaly_both(.*)", 
          &hv_AnomalyResultPostfix);
      get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult, hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), 
          hv_Params.TupleGetDictTuple("anomaly_region_threshold"), hv_AnomalyResultPostfix, 
          &hv_AnomalyScore, &hv_AnomalyClassID, &hv_AnomalyClassThresholdDisplay, 
          &hv_AnomalyRegionThresholdDisplay);
      //
      //Get open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      hv_WindowHandleName = HTuple(hv_KeysForDisplay[hv_KeyIndex]);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleName, &hv_CurrentWindowHandle, 
          &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualize image, ground truth (if available), and result regions.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      hv_AnomalyRegionGroundTruthExists = "false";
      if (0 != (hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")))
      {
        dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, hv_CurrentWindowHandle, 
            hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple("anomaly_region_label_color"), 
            hv_Params.TupleGetDictTuple("anomaly_color_transparency"), &hv_AnomalyRegionGroundTruthExists);
      }
      //
      //Display anomaly regions defined by the specified threshold or out of DLResult.
      CreateDict(&hv___Tmp_Ctrl_Dict_Init_2);
      SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", -1);
      if (0 != (HTuple(((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2)).TupleTestEqualDictItem("anomaly_region_threshold","comp")).TupleNot()).TupleOr(int((hv_ResultKeys.TupleFind("anomaly_region"+hv_AnomalyResultPostfix))!=-1))))
      {
        dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
            hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple("anomaly_region_result_color"));
      }
      hv___Tmp_Ctrl_Dict_Init_2 = HTuple::TupleConstant("HNULL");
      //
      hv_Text = "GT and detected anomalies "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Get prediction color.
      hv_PredictionColor = "white";
      if (0 != (int(hv_AnomalyLabelIDGroundTruth==hv_AnomalyClassID)))
      {
        hv_PredictionColor = "green";
      }
      else if (0 != (int(hv_AnomalyClassID!=-1)))
      {
        hv_PredictionColor = "red";
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        hv_Text[hv_Text.TupleLength()] = "Ground truth ";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        hv_Text[hv_Text.TupleLength()] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
        if (0 != (HTuple(HTuple(int(hv_AnomalyRegionGroundTruthExists==HTuple("false"))).TupleAnd(int(hv_AnomalyLabelIDGroundTruth==1))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))))
        {
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "No segmentation ground truth found";
        }
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        hv_Text[hv_Text.TupleLength()] = "Results ";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        if (0 != (int(hv_AnomalyClassID==1)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'nok'";
        }
        else if (0 != (int(hv_AnomalyClassID==0)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'ok'";
        }
        else
        {
          hv_Text[hv_Text.TupleLength()] = "No classification result found";
        }
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_3);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", -1);
        if (0 != (((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3)).TupleTestEqualDictItem("anomaly_region_threshold","comp")).TupleAnd(int((hv_ResultKeys.TupleFind("anomaly_region"+hv_AnomalyResultPostfix))==-1))))
        {
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "No segmentation result found";
        }
        hv___Tmp_Ctrl_Dict_Init_3 = HTuple::TupleConstant("HNULL");
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = (("anomaly_score"+hv_AnomalyResultPostfix)+": ")+(hv_AnomalyScore.TupleString(".3f"));
        hv_Text[hv_Text.TupleLength()] = "";
        if (0 != (HTuple(int(hv_AnomalyClassThresholdDisplay!=-1)).TupleOr(int(hv_AnomalyRegionThresholdDisplay!=-1))))
        {
          hv_Text[hv_Text.TupleLength()] = "---------------";
          hv_Text[hv_Text.TupleLength()] = "Thresholds ";
          hv_Text[hv_Text.TupleLength()] = "---------------";
        }
        //
        if (0 != (int(hv_AnomalyClassThresholdDisplay!=-1)))
        {
          hv_Text[hv_Text.TupleLength()] = "Classification: "+(hv_AnomalyClassThresholdDisplay.TupleString(".3f"));
          hv_Text[hv_Text.TupleLength()] = "";
        }
        if (0 != (int(hv_AnomalyRegionThresholdDisplay!=-1)))
        {
          hv_Text[hv_Text.TupleLength()] = "Segmentation: "+(hv_AnomalyRegionThresholdDisplay.TupleString(".3f"));
          hv_Text[hv_Text.TupleLength()] = "";
        }
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleName, 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        TupleGenConst(hv_Text.TupleLength(), "white", &hv_LineColors);
        hv_ResultColorOffset = 10;
        if (0 != (HTuple(HTuple(int(hv_AnomalyRegionGroundTruthExists==HTuple("false"))).TupleAnd(int(hv_AnomalyLabelIDGroundTruth==1))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))))
        {
          hv_ResultColorOffset += 2;
        }
        hv_LineColors[hv_ResultColorOffset] = hv_PredictionColor;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_LineColors, "box", "false");
      }
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_ground_truth"))))
    {
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, &hv_AnomalyLabelGroundTruth, 
          &hv_AnomalyLabelIDGroundTruth);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      hv_AnomalyRegionExists = "false";
      if (0 != (hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")))
      {
        //Show the ground truth region.
        dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, hv_CurrentWindowHandle, 
            hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple("anomaly_region_label_color"), 
            hv_Params.TupleGetDictTuple("anomaly_color_transparency"), &hv_AnomalyRegionExists);
      }
      //
      hv_Text = "Ground truth anomalies "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
        if (0 != (HTuple(HTuple(int(hv_AnomalyRegionExists==HTuple("false"))).TupleAnd(int(hv_AnomalyLabelIDGroundTruth==1))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))))
        {
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "No 'anomaly_ground_truth' exists!";
        }
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              "white", "box", "false");
      }
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_image"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_image_local")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_image_global")))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get the anomaly results either by applying the specified thresholds or out of DLResult.
      hv_AnomalyImageKey = HTuple(hv_KeysForDisplay[hv_KeyIndex]);
      TupleRegexpMatch(hv_AnomalyImageKey, "anomaly_image(.*)", &hv_AnomalyResultPostfix);
      get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult, hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), 
          hv_Params.TupleGetDictTuple("anomaly_region_threshold"), hv_AnomalyResultPostfix, 
          &hv_AnomalyScore, &hv_AnomalyClassID, &hv_AnomalyClassThresholdDisplay, 
          &hv_AnomalyRegionThresholdDisplay);
      //
      //Read in input image.
      GetDictObject(&ho_Image, hv_DLSample, "image");
      //Add the anomaly image to the input image.
      add_colormap_to_image(ho_AnomalyImage, ho_Image, &ho_AnomalyImage, hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_AnomalyImage, HDevWindowStack::GetActive());
      hv_Text = hv_AnomalyImageKey;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      TupleRegexpReplace(hv_AnomalyImageKey, "image", "score", &hv_AnomalyScoreKey);
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text[hv_Text.TupleLength()] = "";
        if (0 != (int(hv_AnomalyClassID==1)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'nok'";
        }
        else if (0 != (int(hv_AnomalyClassID==0)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'ok'";
        }
        else
        {
          hv_Text[hv_Text.TupleLength()] = "No classification result found";
        }
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = (hv_AnomalyScoreKey+": ")+(hv_AnomalyScore.TupleString(".3f"));
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              "white", "box", "false");
      }
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_result"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_result_local")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("anomaly_result_global")))))
    {
      //
      //Get image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get the anomaly results either by applying the specified thresholds or out of DLResult.
      hv_AnomalyResultKey = HTuple(hv_KeysForDisplay[hv_KeyIndex]);
      TupleRegexpMatch(hv_AnomalyResultKey, "anomaly_result(.*)", &hv_AnomalyResultPostfix);
      get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult, hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), 
          hv_Params.TupleGetDictTuple("anomaly_region_threshold"), hv_AnomalyResultPostfix, 
          &hv_AnomalyScore, &hv_AnomalyClassID, &hv_AnomalyClassThresholdDisplay, 
          &hv_AnomalyRegionThresholdDisplay);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display anomaly regions defined by the specified threshold or out of DLResult.
      TupleRegexpReplace(hv_AnomalyResultKey, "result", "region", &hv_AnomalyRegionKey);
      CreateDict(&hv___Tmp_Ctrl_Dict_Init_4);
      SetDictTuple(hv___Tmp_Ctrl_Dict_Init_4, "comp", -1);
      if (0 != (HTuple(((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_4)).TupleTestEqualDictItem("anomaly_region_threshold","comp")).TupleNot()).TupleOr(int((hv_ResultKeys.TupleFind(hv_AnomalyRegionKey))!=-1))))
      {
        dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
            hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple("anomaly_region_result_color"));
      }
      hv___Tmp_Ctrl_Dict_Init_4 = HTuple::TupleConstant("HNULL");
      //
      TupleRegexpReplace(hv_AnomalyResultKey, "result", "score", &hv_AnomalyScoreKey);
      //
      hv_Text = "Detected anomalies "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        hv_Text[hv_Text.TupleLength()] = "Results ";
        hv_Text[hv_Text.TupleLength()] = "---------------";
        if (0 != (int(hv_AnomalyClassID==1)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'nok'";
        }
        else if (0 != (int(hv_AnomalyClassID==0)))
        {
          hv_Text[hv_Text.TupleLength()] = hv_AnomalyClassID+" : 'ok'";
        }
        else
        {
          hv_Text[hv_Text.TupleLength()] = "No classification result found";
        }
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_5);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_5, "comp", -1);
        if (0 != (((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_5)).TupleTestEqualDictItem("anomaly_region_threshold","comp")).TupleAnd(int((hv_ResultKeys.TupleFind(hv_AnomalyRegionKey))==-1))))
        {
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "No segmentation result found";
        }
        hv___Tmp_Ctrl_Dict_Init_5 = HTuple::TupleConstant("HNULL");
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = (hv_AnomalyScoreKey+": ")+(hv_AnomalyScore.TupleString(".3f"));
        hv_Text[hv_Text.TupleLength()] = "";
        if (0 != (HTuple(int(hv_AnomalyClassThresholdDisplay!=-1)).TupleOr(int(hv_AnomalyRegionThresholdDisplay!=-1))))
        {
          hv_Text[hv_Text.TupleLength()] = "---------------";
          hv_Text[hv_Text.TupleLength()] = "Thresholds ";
          hv_Text[hv_Text.TupleLength()] = "---------------";
        }
        //
        if (0 != (int(hv_AnomalyClassThresholdDisplay!=-1)))
        {
          hv_Text[hv_Text.TupleLength()] = "Classification: "+(hv_AnomalyClassThresholdDisplay.TupleString(".3f"));
          hv_Text[hv_Text.TupleLength()] = "";
        }
        if (0 != (int(hv_AnomalyRegionThresholdDisplay!=-1)))
        {
          hv_Text[hv_Text.TupleLength()] = "Segmentation: "+(hv_AnomalyRegionThresholdDisplay.TupleString(".3f"));
          hv_Text[hv_Text.TupleLength()] = "";
        }
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              "white", "box", "false");
      }
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_heatmap"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get gripping points
      get_gripping_points_from_dict(hv_DLResult, &hv_Rows, &hv_Columns);
      //
      //Confidence image.
      if (0 != (int((hv_ResultKeys.TupleFind("gripping_confidence"))!=-1)))
      {
        GetDictObject(&ho_ConfidenceImage, hv_DLResult, "gripping_confidence");
      }
      else
      {
        throw HException("Image with key 'gripping_confidence' could not be found in DLResult.");
      }
      add_colormap_to_image(ho_ConfidenceImage, ho_Image, &ho_HeatmapScene, hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_HeatmapScene, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),"Gripping heatmap", "window", "top", 
            "left", "black", "box", "true");
      //
      GenCrossContourXld(&ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple("gripping_point_size"), 
          0.785398);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("line_width"));
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("gripping_point_color"));
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Cross, HDevWindowStack::GetActive());
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("gripping_points"))))
    {
      //
      //Image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get gripping points
      get_gripping_points_from_dict(hv_DLResult, &hv_Rows, &hv_Columns);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      FullDomain(ho_Image, &ho_Image);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_ImageIDStringCapital, "window", 
              "bottom", "left", "white", "box", "false");
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),"Gripping points", "window", "top", 
            "left", "black", "box", "true");
      //
      GenCrossContourXld(&ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple("gripping_point_size"), 
          0.785398);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("line_width"));
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("gripping_point_color"));
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Cross, HDevWindowStack::GetActive());
      //
    }
    else if (0 != (HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("bbox_both"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_both")))))
    {
      //
      //Ground truth and result bounding boxes on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (0 != hv_IsOCRDetection)
      {
        FullDomain(ho_Image, &ho_Image);
      }
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Visualization.
      //
      hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple("display_direction");
      if (0 != ((hv_Params.TupleGetDictTuple("display_direction")).TupleAnd(hv_IsOCRDetection)))
      {
        hv_DisplayDirectionTemp = -1;
      }
      dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple("line_width"), 
          hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple("bbox_label_color"), 
          hv_WindowImageRatio, hv_Params.TupleGetDictTuple("bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
          hv_DisplayDirectionTemp, hv_CurrentWindowHandle, &hv_BboxLabelIndex);
      if (0 != (int((hv_ResultKeys.TupleFind("bbox_confidence"))!=-1)))
      {
        GetDictTuple(hv_DLResult, "bbox_confidence", &hv_BboxConfidences);
      }
      else
      {
        throw HException("Result data could not be found in DLResult.");
      }
      if (0 != (hv_Params.TupleGetDictTuple("bbox_display_confidence")))
      {
        hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(".2f")))+")";
      }
      else
      {
        hv_TextConf = HTuple(hv_BboxConfidences.TupleLength(),"");
      }
      dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_Params.TupleGetDictTuple("line_width"), 
          hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple("bbox_label_color"), 
          hv_WindowImageRatio, "bottom", hv_Params.TupleGetDictTuple("bbox_text_color"), 
          hv_Params.TupleGetDictTuple("display_labels"), hv_DisplayDirectionTemp, 
          hv_CurrentWindowHandle, &hv_BboxClassIndex);
      hv_Text = "Ground truth and results "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      hv_Text = "Ground truth and";
      hv_Text[hv_Text.TupleLength()] = "results "+hv_ImageIDStringBraces;
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_BboxColorsBoth.Clear();
        hv_BboxColorsBoth[0] = "white";
        hv_BboxColorsBoth[1] = "white";
        if (0 != (int(((hv_BboxClassIndex.TupleLength())+(hv_BboxLabelIndex.TupleLength()))>0)))
        {
          hv_BboxClassLabelIndexUniq = ((hv_BboxClassIndex.TupleConcat(hv_BboxLabelIndex)).TupleSort()).TupleUniq();
          hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_BboxClassLabelIndexUniq]));
          hv_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(HTuple(hv_Colors[hv_BboxClassLabelIndexUniq]));
        }
        else
        {
          hv_Text = hv_Text.TupleConcat("No ground truth nor results present.");
        }
        //
        //Get or open next child window.
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_BboxColorsBoth, "box", "false");
      }
    }
    else if (0 != (HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("bbox_ground_truth"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_ground_truth")))))
    {
      //
      //Sample bounding boxes on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (0 != hv_IsOCRDetection)
      {
        FullDomain(ho_Image, &ho_Image);
      }
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display smaller arrow for ocr_detection
      hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple("display_direction");
      if (0 != ((hv_Params.TupleGetDictTuple("display_direction")).TupleAnd(hv_IsOCRDetection)))
      {
        hv_DisplayDirectionTemp = -1;
      }
      //
      dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple("line_width"), 
          hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple("bbox_label_color"), 
          hv_WindowImageRatio, hv_Params.TupleGetDictTuple("bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
          hv_DisplayDirectionTemp, hv_CurrentWindowHandle, &hv_BboxIDs);
      hv_Text = "Ground truth "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_BboxColors = "white";
        if (0 != (hv_BboxIDs.TupleLength()))
        {
          hv_BboxIDsUniq = (hv_BboxIDs.TupleSort()).TupleUniq();
          hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_BboxIDsUniq]));
          hv_BboxColors = hv_BboxColors.TupleConcat(HTuple(hv_Colors[hv_BboxIDsUniq]));
        }
        else
        {
          hv_Text = hv_Text.TupleConcat("No ground truth present.");
        }
        //
        //Get or open next child window.
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_BboxColors, "box", "false");
      }
    }
    else if (0 != (HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("bbox_result"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_result")))))
    {
      //
      //Result bounding boxes on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (0 != hv_IsOCRDetection)
      {
        FullDomain(ho_Image, &ho_Image);
      }
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display smaller arrow for ocr_detection
      hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple("display_direction");
      if (0 != ((hv_Params.TupleGetDictTuple("display_direction")).TupleAnd(hv_IsOCRDetection)))
      {
        hv_DisplayDirectionTemp = -1;
      }
      //
      if (0 != (int((hv_ResultKeys.TupleFind("bbox_confidence"))!=-1)))
      {
        GetDictTuple(hv_DLResult, "bbox_confidence", &hv_BboxConfidences);
      }
      else
      {
        throw HException("Result data could not be found in DLResult.");
      }
      if (0 != (hv_Params.TupleGetDictTuple("bbox_display_confidence")))
      {
        hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(".2f")))+")";
      }
      else
      {
        hv_TextConf = HTuple(hv_BboxConfidences.TupleLength(),"");
      }
      dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_Params.TupleGetDictTuple("line_width"), 
          hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple("bbox_label_color"), 
          hv_WindowImageRatio, "top", hv_Params.TupleGetDictTuple("bbox_text_color"), 
          hv_Params.TupleGetDictTuple("display_labels"), hv_DisplayDirectionTemp, 
          hv_CurrentWindowHandle, &hv_BboxClassIndex);
      hv_Text = "Result "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_BboxColorsResults = "white";
        if (0 != (int((hv_BboxClassIndex.TupleLength())>0)))
        {
          hv_BboxClassIndexUniq = (hv_BboxClassIndex.TupleSort()).TupleUniq();
          hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_BboxClassIndexUniq]));
          hv_BboxColorsResults = hv_BboxColorsResults.TupleConcat(HTuple(hv_Colors[hv_BboxClassIndexUniq]));
        }
        else
        {
          hv_Text = hv_Text.TupleConcat("No results present.");
        }
        //
        //Get or open next child window.
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_BboxColorsResults, "box", "false");
      }
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_character"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_link")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_orientation")))))
    {
      //
      //Extract score maps
      ho_ScoreMaps = hv_OcrResult.TupleGetDictObject("score_maps");
      Decompose4(ho_ScoreMaps, &ho_CharacterScoreMap, &ho_LinkScoreMap, &ho_OrientationSinScoreMap, 
          &ho_OrientationCosScoreMap);
      //
      //Select score map to display
      if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_character"))))
      {
        ho_ScoreMap = ho_CharacterScoreMap;
        hv_Text = "Character score "+hv_ImageIDStringBraces;
      }
      else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_link"))))
      {
        ho_ScoreMap = ho_LinkScoreMap;
        hv_Text = "Link score "+hv_ImageIDStringBraces;
      }
      else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_detection_score_map_orientation"))))
      {
        Compose2(ho_OrientationSinScoreMap, ho_OrientationCosScoreMap, &ho_OrientationScoreMap
            );
        ho_ScoreMap = ho_OrientationScoreMap;
        hv_Text = HTuple("Orientation (sin,cos) ")+hv_ImageIDStringBraces;
      }
      //Get or open next window.
      GetImageSize(ho_ScoreMap, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Make sure the minimum and maximum gray values of the score map image
      //are 0 and 1, respectively. This is necessary to get the correct color
      //range from the 'jet' color map.
      SetGrayval(ho_ScoreMap, HTuple(0).TupleConcat(hv_HeightImage-1), HTuple(0).TupleConcat(hv_WidthImage-1), 
          (HTuple(0).Append(1)));
      //
      //Display the score maps using the 'jet' color map.
      SetLut(hv_CurrentWindowHandle, "jet");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ScoreMap, HDevWindowStack::GetActive());
      //
      //Display text
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("classification_both"))))
    {
      //
      //Ground truth and result classification image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      get_classification_ground_truth(hv_SampleKeys, hv_DLSample, &hv_ClassificationLabelIDGroundTruth);
      get_classification_result(hv_ResultKeys, hv_DLResult, &hv_ClassificationLabelIDResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Get prediction color.
      hv_PredictionColor = "white";
      if (0 != (int(hv_ClassificationLabelIDGroundTruth==hv_ClassificationLabelIDResult)))
      {
        hv_PredictionText = "Correct";
        hv_PredictionColor = "green";
      }
      else
      {
        hv_PredictionText = "Wrong";
        hv_PredictionColor = "red";
      }
      //
      //Generate prediction color frame and show image.
      if (0 != (hv_Params.TupleGetDictTuple("display_classification_color_frame")))
      {
        //Create a frame with line width 7 that is completely displayed in the window.
        hv_BoarderOffset = 7/2.;
        GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
        GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height", 
            &hv_WindowImageRatioHeight);
        GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width", 
            &hv_WindowImageRatioWidth);
        hv_BoarderOffsetRow = hv_BoarderOffset/hv_WindowImageRatioHeight;
        hv_BoarderOffsetCol = hv_BoarderOffset/hv_WindowImageRatioWidth;
        GenContourPolygonXld(&ho_PredictionColorFrame, ((((hv_BoarderOffsetRow-0.5).TupleConcat(hv_BoarderOffsetRow-0.5)).TupleConcat((hv_HeightImage+0.5)-hv_BoarderOffsetRow)).TupleConcat((hv_HeightImage+0.5)-hv_BoarderOffsetRow)).TupleConcat(hv_BoarderOffsetRow-0.5), 
            ((((hv_BoarderOffsetCol-0.5).TupleConcat((hv_WidthImage+0.5)-hv_BoarderOffsetCol)).TupleConcat((hv_WidthImage+0.5)-hv_BoarderOffsetCol)).TupleConcat(hv_BoarderOffsetCol-0.5)).TupleConcat(hv_BoarderOffsetCol-0.5));
        if (HDevWindowStack::IsOpen())
          SetLineWidth(HDevWindowStack::GetActive(),7);
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_PredictionColor);
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Image, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          DispObj(ho_PredictionColorFrame, HDevWindowStack::GetActive());
      }
      else
      {
        if (HDevWindowStack::IsOpen())
          DispObj(ho_Image, HDevWindowStack::GetActive());
      }
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_classification_ids")))
      {
        GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
        GetDictTuple(hv_MetaInfo, HTuple(hv_KeysForDisplay[hv_KeyIndex])+"_margin_bottom", 
            &hv_MarginBottom);
        GetDictTuple(hv_MetaInfo, HTuple(hv_KeysForDisplay[hv_KeyIndex])+"_window_coordinates", 
            &hv_WindowCoordinates);
        hv_CurrentWindowHeight = HTuple(hv_WindowCoordinates[3])-HTuple(hv_WindowCoordinates[0]);
        GetFontExtents(hv_CurrentWindowHandle, &hv__, &hv__, &hv__, &hv_MaxHeight);
        hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              "white", "box", "false");
        hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
        if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
        {
          if (HDevWindowStack::IsOpen())
            DispText(HDevWindowStack::GetActive(),hv_Text, "window", hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), 
                "left", "white", "box", "false");
        }
        else
        {
          if (HDevWindowStack::IsOpen())
            DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
                "white", "box", "false");
        }
      }
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = "Result/GT classification "+hv_ImageIDStringBraces;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
        hv_Text[hv_Text.TupleLength()] = HTuple(hv_ClassesLegend[hv_ClassificationLabelIDGroundTruth]);
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "Result class ID";
        if (0 != (int(hv_ClassificationLabelIDResult==HTuple())))
        {
          hv_Text[hv_Text.TupleLength()] = "No classification result is given!";
        }
        else
        {
          hv_Text[hv_Text.TupleLength()] = HTuple(hv_ClassesLegend[hv_ClassificationLabelIDResult]);
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "";
          hv_Text[hv_Text.TupleLength()] = "Prediction ";
          hv_Text[hv_Text.TupleLength()] = hv_PredictionText;
        }
        //
        //Get or open next child window.
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        TupleGenConst(hv_Text.TupleLength(), "white", &hv_LineColors);
        hv_LineColors[1] = HTuple(hv_Colors[hv_ClassificationLabelIDGroundTruth]);
        if (0 != (int(hv_ClassificationLabelIDResult!=HTuple())))
        {
          hv_LineColors[5] = HTuple(hv_Colors[hv_ClassificationLabelIDResult]);
          hv_LineColors[9] = hv_PredictionColor;
        }
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_LineColors, "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("classification_ground_truth"))))
    {
      //
      //Ground truth classification image and class label.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      get_classification_ground_truth(hv_SampleKeys, hv_DLSample, &hv_ClassificationLabelIDGroundTruth);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_classification_ids")))
      {
        hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              "white", "box", "false");
      }
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = "Ground truth classification "+hv_ImageIDStringBraces;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
        hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_ClassificationLabelIDGroundTruth]));
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              HTuple("white").TupleConcat(HTuple(hv_Colors[hv_ClassificationLabelIDGroundTruth])), 
              "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("classification_result"))))
    {
      //
      //Ground truth classification image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      get_classification_result(hv_ResultKeys, hv_DLResult, &hv_ClassificationLabelIDResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display the class IDs.
      if (0 != (hv_Params.TupleGetDictTuple("display_classification_ids")))
      {
        GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
        GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom", &hv_MarginBottom);
        GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates", &hv_WindowCoordinates);
        hv_CurrentWindowHeight = HTuple(hv_WindowCoordinates[3])-HTuple(hv_WindowCoordinates[0]);
        GetFontExtents(hv_CurrentWindowHandle, &hv__, &hv__, &hv__, &hv_MaxHeight);
        hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
        if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
        {
          if (HDevWindowStack::IsOpen())
            DispText(HDevWindowStack::GetActive(),hv_Text, "window", hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), 
                "left", "white", "box", "false");
        }
        else
        {
          if (HDevWindowStack::IsOpen())
            DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
                "white", "box", "false");
        }
      }
      //
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = "Result classification "+hv_ImageIDStringBraces;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_Text = "Result class ID "+hv_ImageIDStringBraces;
        if (0 != (int(hv_ClassificationLabelIDResult==HTuple())))
        {
          hv_Text[hv_Text.TupleLength()] = "No classification result is given!";
        }
        else
        {
          hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_ClassificationLabelIDResult]));
        }
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              HTuple("white").TupleConcat(HTuple(hv_Colors[hv_ClassificationLabelIDResult])), 
              "box", "false");
      }
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("heatmap_grad_cam"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("heatmap_guided_grad_cam")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("heatmap_confidence_based")))))
    {
      //
      //Display the heatmap image (method 'heatmap_grad_cam', 'heatmap_guided_grad_cam',
      //or 'heatmap_confidence_based') in the selected color scheme.
      //Retrieve heatmap image, inferred image, and inference results.
      hv_SelectedHeatmapMethod = HTuple(hv_KeysForDisplay[hv_KeyIndex]);
      if (0 != (HTuple(HTuple(int((hv_ResultKeys.TupleFind("heatmap_grad_cam"))!=-1)).TupleOr(int((hv_ResultKeys.TupleFind("heatmap_guided_grad_cam"))!=-1))).TupleOr(int((hv_ResultKeys.TupleFind("heatmap_confidence_based"))!=-1))))
      {
        if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_grad_cam"))))
        {
          GetDictTuple(hv_DLResult, "heatmap_grad_cam", &hv_DictHeatmap);
          hv_MethodName = "Grad-CAM";
        }
        else if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_guided_grad_cam"))))
        {
          GetDictTuple(hv_DLResult, "heatmap_guided_grad_cam", &hv_DictHeatmap);
          hv_MethodName = "Guided-Grad-CAM";
        }
        else
        {
          GetDictTuple(hv_DLResult, "heatmap_confidence_based", &hv_DictHeatmap);
          hv_MethodName = "Confidence based";
        }
        GetDictParam(hv_DictHeatmap, "keys", HTuple(), &hv_HeatmapKeys);
        //
        if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_guided_grad_cam"))))
        {
          hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect("guided_grad_cam_image_class_[0-9]*");
          hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch("guided_grad_cam_image_class_([0-9]+)$");
        }
        else
        {
          hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect("heatmap_image_class_[0-9]*");
          hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch("heatmap_image_class_([0-9]+)$");
        }
        GetDictObject(&ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
      }
      else
      {
        throw HException("Heatmap image could not be found in DLResult.");
      }
      //
      //Only for the Grad-Cam heatmap the input image is shown.
      if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_grad_cam"))))
      {
        //Read in input image.
        GetDictObject(&ho_Image, hv_DLSample, "image");
        //Add the heatmap to the input image.
        add_colormap_to_image(ho_ImageHeatmap, ho_Image, &ho_ImageHeatmap, hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
      }
      //
      //Get or open next window.
      GetImageSize(ho_ImageHeatmap, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ImageHeatmap, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = "Classification heatmap "+hv_ImageIDStringBraces;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        GetDictTuple(hv_DLResult, "classification_class_names", &hv_ClassNames);
        GetDictTuple(hv_DLResult, "classification_class_ids", &hv_ClassIDs);
        GetDictTuple(hv_DLResult, "classification_confidences", &hv_Confidences);
        if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_confidence_based"))))
        {
          GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation", &hv_MaxDeviation);
        }
        hv_ClassificationLabelNameResult = ((const HTuple&)hv_ClassNames)[0];
        hv_ClassificationLabelIDResult = ((const HTuple&)hv_ClassIDs)[0];
        hv_TargetClassConfidence = HTuple(hv_Confidences[hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber())]);
        hv_Text = "--------- ";
        hv_Text[hv_Text.TupleLength()] = "Image ";
        hv_Text[hv_Text.TupleLength()] = "--------- ";
        hv_Text[hv_Text.TupleLength()] = "";
        if (0 != (int((hv_SampleKeys.TupleFind("image_label_id"))!=-1)))
        {
          GetDictTuple(hv_DLSample, "image_label_id", &hv_ClassificationLabelIDGroundTruth);
          GetDictTuple(hv_DLDatasetInfo, "class_names", &hv_ClassificationLabelNamesGroundTruth);
          //Get prediction color.
          if (0 != (int(hv_ClassificationLabelIDGroundTruth==hv_ClassificationLabelIDResult)))
          {
            hv_PredictionColor = "green";
          }
          else
          {
            hv_PredictionColor = "red";
          }
          hv_Text[hv_Text.TupleLength()] = "Ground truth class: ";
          hv_Text[hv_Text.TupleLength()] = HTuple(hv_ClassificationLabelNamesGroundTruth[hv_ClassificationLabelIDGroundTruth]);
          hv_Text[hv_Text.TupleLength()] = "";
        }
        hv_Text[hv_Text.TupleLength()] = "Predicted class: ";
        hv_Text[hv_Text.TupleLength()] = hv_ClassificationLabelNameResult;
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "Confidence: "+(HTuple(hv_Confidences[0]).TupleString(".2f"));
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "--------- ";
        hv_Text[hv_Text.TupleLength()] = "Heatmap ";
        hv_Text[hv_Text.TupleLength()] = "--------- ";
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "Method: "+hv_MethodName;
        hv_Text[hv_Text.TupleLength()] = "Target class: "+hv_TargetClassID;
        hv_Text[hv_Text.TupleLength()] = "";
        hv_Text[hv_Text.TupleLength()] = "Target class confidence: "+(hv_TargetClassConfidence.TupleString(".2f"));
        if (0 != (int(hv_SelectedHeatmapMethod==HTuple("heatmap_confidence_based"))))
        {
          hv_Text[hv_Text.TupleLength()] = "Maximum deviation: "+(hv_MaxDeviation.TupleString(".2f"));
        }
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        TupleGenConst(hv_Text.TupleLength(), "white", &hv_LineColors);
        if (0 != (int((hv_SampleKeys.TupleFind("image_label_id"))!=-1)))
        {
          hv_LineColors[8] = hv_PredictionColor;
        }
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              hv_LineColors, "box", "false");
      }
    }
    else if (0 != (HTuple(HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_ground_truth"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_result")))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_both")))))
    {
      //
      //OCR Recognition.
      hv_ShowGT = HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_both"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_ground_truth")));
      hv_ShowResult = HTuple(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_both"))).TupleOr(int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("ocr_recognition_result")));
      hv_NumLines = hv_ShowGT+hv_ShowResult;
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_NumLines*(hv_Params.TupleGetDictTuple("display_bottom_desc")), hv_WidthImage, 
          hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      FullDomain(ho_Image, &ho_Image);
      GetImageType(ho_Image, &hv_Type);
      if (0 != (int(hv_Type==HTuple("real"))))
      {
        //We assume that real images have been preprocessed
        //to the range -1,1 already. Hence, we need to rescale
        //them back to a visible range in byte.
        ScaleImage(ho_Image, &ho_Image, 255.0/2, 127);
        ConvertImageType(ho_Image, &ho_Image, "byte");
      }
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = HTuple();
        //Ground truth.
        if (0 != hv_ShowGT)
        {
          hv_Text[hv_Text.TupleLength()] = (("Ground truth: \""+(hv_DLSample.TupleGetDictTuple("word")))+"\" ")+hv_ImageIDStringBraces;
        }
        //Result.
        if (0 != hv_ShowResult)
        {
          GetDictParam(hv_DLSample, "key_exists", "word", &hv_GTWordKeyExists);
          if (0 != hv_GTWordKeyExists)
          {
            GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
            GetDictTuple(hv_MetaInfo, HTuple(hv_KeysForDisplay[hv_KeyIndex])+"_window_coordinates", 
                &hv_WindowCoordinates);
            GetDictTuple(hv_MetaInfo, HTuple(hv_KeysForDisplay[hv_KeyIndex])+"_margin_bottom", 
                &hv_MarginBottom);
            hv_HeightWindow = ((const HTuple&)hv_WindowCoordinates)[3];
            hv_HeightMarginBottom = (hv_HeightImage*hv_MarginBottom)/(hv_HeightWindow-hv_MarginBottom);
            hv_Size = hv_HeightMarginBottom/2;
            hv_Length = hv_Size/2;
            hv_Row = hv_HeightImage+(hv_HeightMarginBottom/2);
            hv_Column = hv_WidthImage-(1.5*hv_Size);
            HomMat2dIdentity(&hv_HomMat2DIdentity);
            HomMat2dRotate(hv_HomMat2DIdentity, HTuple(45).TupleRad(), 0, 0, &hv_HomMat2DRotate);
            HomMat2dTranslate(hv_HomMat2DRotate, hv_Row, hv_Column, &hv_HomMat2DCompose);
            if (0 != ((hv_DLResult.TupleConcat(hv_DLSample)).TupleTestEqualDictItem("word","word")))
            {
              hv_PredictionForegroundColor = "green";
              hv_PredictionBackgroundColor = "#008000";
              GenContourPolygonXld(&ho_PredictionSymbol, (-0.75*hv_Length).TupleConcat((HTuple(0).Append(0))), 
                  ((-hv_Length).TupleConcat(-hv_Length)).TupleConcat(hv_Length));
            }
            else
            {
              hv_PredictionForegroundColor = "red";
              hv_PredictionBackgroundColor = "#800000";
              GenContourPolygonXld(&ho_CrossLineH, (HTuple(0).Append(0)), (-hv_Length).TupleConcat(hv_Length));
              GenContourPolygonXld(&ho_CrossLineV, (-hv_Length).TupleConcat(hv_Length), 
                  (HTuple(0).Append(0)));
              ConcatObj(ho_CrossLineH, ho_CrossLineV, &ho_PredictionSymbol);
            }
            AffineTransContourXld(ho_PredictionSymbol, &ho_PredictionSymbol, hv_HomMat2DCompose);
            SetWindowParam(hv_CurrentWindowHandle, "background_color", hv_PredictionBackgroundColor);
            if (HDevWindowStack::IsOpen())
              ClearWindow(HDevWindowStack::GetActive());
            if (HDevWindowStack::IsOpen())
              DispObj(ho_Image, HDevWindowStack::GetActive());
            if (HDevWindowStack::IsOpen())
              SetLineWidth(HDevWindowStack::GetActive(),5);
            if (HDevWindowStack::IsOpen())
              SetColor(HDevWindowStack::GetActive(),hv_PredictionForegroundColor);
            if (HDevWindowStack::IsOpen())
              DispObj(ho_PredictionSymbol, HDevWindowStack::GetActive());
          }
          else
          {
            hv_PredictionForegroundColor = "white";
          }
          if (0 != hv_ShowGT)
          {
            hv_Spaces = "    ";
          }
          else
          {
            hv_Spaces = "";
          }
          hv_Text[hv_Text.TupleLength()] = ((("Deep OCR:"+hv_Spaces)+" \"")+(hv_DLResult.TupleGetDictTuple("word")))+"\"";
        }
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_confidence"))))
    {
      //
      //Segmentation confidences.
      get_confidence_image(&ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
      //
      //Get or open next window.
      GetImageSize(ho_ImageConfidence, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ImageConfidence, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"Confidence image "+hv_ImageIDStringBraces, 
              "window", "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_confidence_map"))))
    {
      //
      //Segmentation confidence map on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_confidence_image(&ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          hv_Params.TupleGetDictTuple("map_color_bar_width"), hv_Params.TupleGetDictTuple("scale_windows"), 
          hv_Params.TupleGetDictTuple("threshold_width"), hv_PrevWindowCoordinates, 
          hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), &hv_CurrentWindowHandle, 
          &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      dev_display_confidence_regions(ho_ImageConfidence, hv_Params.TupleGetDictTuple("map_transparency"), 
          &hv_ConfidenceColors);
      dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"), 
          hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"Confidence map "+hv_ImageIDStringBraces, 
              "window", "bottom", "left", "white", "box", "false");
      }
      //
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_image_both"))))
    {
      //
      //Ground truth and result segmentation on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);
      get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, hv_DLResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display regions.
      hv_ColorsResults = hv_Colors+(hv_Params.TupleGetDictTuple("segmentation_transparency"));
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),2);
      dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
          hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
          &hv_GroundTruthIDs);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),6);
      dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, hv_ColorsResults, 
          hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), &hv_ResultIDs);
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"fill");
      hv_Text = "Ground truth and result segmentation "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_ImageClassIDsUniq = ((hv_GroundTruthIDs.TupleConcat(hv_ResultIDs)).TupleSort()).TupleUniq();
        //Get Indices according to image class IDs.
        TupleGenConst(hv_ImageClassIDsUniq.TupleLength(), 0, &hv_ImageClassIDsIndices);
        {
        HTuple end_val1378 = (hv_ImageClassIDsUniq.TupleLength())-1;
        HTuple step_val1378 = 1;
        for (hv_ImageClassIDsIndex=0; hv_ImageClassIDsIndex.Continue(end_val1378, step_val1378); hv_ImageClassIDsIndex += step_val1378)
        {
          hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(HTuple(hv_ImageClassIDsUniq[hv_ImageClassIDsIndex]));
        }
        }
        hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_ImageClassIDsIndices]));
        hv_Text[(hv_Text.TupleLength())+1] = HTuple("- thicker line: result, thinner lines: ground truth");
        hv_Text[hv_Text.TupleLength()] = "  (you may have to zoom in for a more detailed view)";
        hv_StringSegExcludeClassIDs = "";
        {
        HTuple end_val1385 = ((hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids")).TupleLength())-1;
        HTuple step_val1385 = 1;
        for (hv_StringIndex=0; hv_StringIndex.Continue(end_val1385, step_val1385); hv_StringIndex += step_val1385)
        {
          if (0 != (int(hv_StringIndex==(((hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids")).TupleLength())-1))))
          {
            hv_StringSegExcludeClassIDs += HTuple((hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"))[hv_StringIndex]);
          }
          else
          {
            hv_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs+HTuple((hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"))[hv_StringIndex]))+HTuple(", ");
          }
        }
        }
        CreateDict(&hv___Tmp_Ctrl_Dict_Init_6);
        SetDictTuple(hv___Tmp_Ctrl_Dict_Init_6, "comp", HTuple());
        if (0 != (((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_6)).TupleTestEqualDictItem("segmentation_exclude_class_ids","comp")).TupleNot()))
        {
          hv_Text[hv_Text.TupleLength()] = ("- (excluded classID(s) "+hv_StringSegExcludeClassIDs)+" from visualization)";
        }
        hv___Tmp_Ctrl_Dict_Init_6 = HTuple::TupleConstant("HNULL");
        //
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              (HTuple("white").TupleConcat(HTuple(hv_Colors[hv_ImageClassIDsIndices]))).TupleConcat(((HTuple("white").Append("white")).Append("white"))), 
              "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_image_diff"))))
    {
      //
      //Difference of ground truth and result segmentation on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);
      get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, hv_DLResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult, &ho_ImageAbsDiff, 
          1);
      MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0, &hv_Min, &hv_Max, 
          &hv_Range);
      if (0 != (int(hv_Min!=hv_Max)))
      {
        Threshold(ho_ImageAbsDiff, &ho_DiffRegion, 0.00001, hv_Max);
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),"#ff0000"+(hv_Params.TupleGetDictTuple("segmentation_transparency")));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_DiffRegion, HDevWindowStack::GetActive());
      }
      else
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"No difference found.", "window", 
              "top", "left", "black", HTuple(), HTuple());
      }
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        hv_Text = "Difference of ground truth and result segmentation "+hv_ImageIDStringBraces;
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_image_ground_truth"))))
    {
      //
      //Ground truth segmentation image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display segmentation regions.
      hv_ColorsSegmentation = hv_Colors+(hv_Params.TupleGetDictTuple("segmentation_transparency"));
      GetDraw(hv_CurrentWindowHandle, &hv_DrawMode);
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("segmentation_draw"));
      GetLineWidth(hv_CurrentWindowHandle, &hv_Width);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("line_width"));
      dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
          hv_ColorsSegmentation, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
          &hv_ImageClassIDs);
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),hv_DrawMode);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Width.TupleInt());
      hv_Text = "Ground truth segmentation "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_ImageClassIDsUniq = (hv_ImageClassIDs.TupleSort()).TupleUniq();
        //Get Indices according to image class IDs.
        TupleGenConst(hv_ImageClassIDsUniq.TupleLength(), 0, &hv_ImageClassIDsIndices);
        {
        HTuple end_val1460 = (hv_ImageClassIDsUniq.TupleLength())-1;
        HTuple step_val1460 = 1;
        for (hv_ImageClassIDsIndex=0; hv_ImageClassIDsIndex.Continue(end_val1460, step_val1460); hv_ImageClassIDsIndex += step_val1460)
        {
          hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(HTuple(hv_ImageClassIDsUniq[hv_ImageClassIDsIndex]));
        }
        }
        hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_ImageClassIDsIndices]));
        //
        //Get or open next child window
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              HTuple("white").TupleConcat(HTuple(hv_Colors[hv_ImageClassIDsIndices])), 
              "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_image_result"))))
    {
      //
      //Result segmentation on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, hv_DLResult);
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      //
      //Display result segmentation regions.
      hv_ColorsResults = hv_Colors+(hv_Params.TupleGetDictTuple("segmentation_transparency"));
      GetDraw(hv_CurrentWindowHandle, &hv_DrawMode);
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("segmentation_draw"));
      GetLineWidth(hv_CurrentWindowHandle, &hv_Width);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Params.TupleGetDictTuple("line_width"));
      dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, hv_ColorsResults, 
          hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), &hv_ImageClassIDs);
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),hv_DrawMode);
      if (HDevWindowStack::IsOpen())
        SetLineWidth(HDevWindowStack::GetActive(),hv_Width.TupleInt());
      hv_Text = "Result segmentation "+hv_ImageIDStringBraces;
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "bottom", "left", 
              "white", "box", "false");
      }
      //
      //Display the legend.
      if (0 != (hv_Params.TupleGetDictTuple("display_legend")))
      {
        hv_ImageClassIDsUniq = (hv_ImageClassIDs.TupleSort()).TupleUniq();
        //Get Indices according to image class IDs.
        TupleGenConst(hv_ImageClassIDsUniq.TupleLength(), 0, &hv_ImageClassIDsIndices);
        {
        HTuple end_val1501 = (hv_ImageClassIDsUniq.TupleLength())-1;
        HTuple step_val1501 = 1;
        for (hv_ImageClassIDsIndex=0; hv_ImageClassIDsIndex.Continue(end_val1501, step_val1501); hv_ImageClassIDsIndex += step_val1501)
        {
          hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(HTuple(hv_ImageClassIDsUniq[hv_ImageClassIDsIndex]));
        }
        }
        hv_Text = hv_Text.TupleConcat(HTuple(hv_ClassesLegend[hv_ImageClassIDsIndices]));
        //
        //Get or open next child window.
        get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
            hv_Text, hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
            &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", 
              HTuple("white").TupleConcat(HTuple(hv_Colors[hv_ImageClassIDsIndices])), 
              "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_weight"))))
    {
      //
      //Weight image.
      get_weight_image(&ho_ImageWeight, hv_SampleKeys, hv_DLSample);
      //
      //Get or open next window.
      GetImageSize(ho_ImageWeight, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple("threshold_width"), 
          hv_PrevWindowCoordinates, hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), 
          &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ImageWeight, HDevWindowStack::GetActive());
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"Weight image "+hv_ImageIDStringBraces, 
              "window", "bottom", "left", "white", "box", "false");
      }
    }
    else if (0 != (int(HTuple(hv_KeysForDisplay[hv_KeyIndex])==HTuple("segmentation_weight_map"))))
    {
      //
      //Weight map on image.
      get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, "image");
      get_weight_image(&ho_ImageWeight, hv_SampleKeys, hv_DLSample);
      //
      CreateDict(&hv___Tmp_Ctrl_Dict_Init_7);
      SetDictTuple(hv___Tmp_Ctrl_Dict_Init_7, "comp", 0);
      if (0 != ((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_7)).TupleTestEqualDictItem("segmentation_max_weight","comp")))
      {
        //Calculate SegMaxWeight if not given in GenParam.
        MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, &hv_MinWeight, &hv___Tmp_Ctrl_1, 
            &hv_Range);
        SetDictTuple(hv_Params, "segmentation_max_weight", hv___Tmp_Ctrl_1);
      }
      hv___Tmp_Ctrl_Dict_Init_7 = HTuple::TupleConstant("HNULL");
      //
      //Get or open next window.
      GetImageSize(ho_Image, &hv_WidthImage, &hv_HeightImage);
      get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple("font_size"), 
          hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, hv_HeightImage, 
          hv_Params.TupleGetDictTuple("map_color_bar_width"), hv_Params.TupleGetDictTuple("scale_windows"), 
          hv_Params.TupleGetDictTuple("threshold_width"), hv_PrevWindowCoordinates, 
          hv_WindowHandleDict, HTuple(hv_KeysForDisplay[hv_KeyIndex]), &hv_CurrentWindowHandle, 
          &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      //
      //Visualization.
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
      dev_display_weight_regions(ho_ImageWeight, hv_Params.TupleGetDictTuple("map_transparency"), 
          hv_Params.TupleGetDictTuple("segmentation_max_weight"), &hv_WeightsColors);
      dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"), 
          hv_WeightsColors, hv_Params.TupleGetDictTuple("segmentation_max_weight"), 
          hv_WindowImageRatio, hv_CurrentWindowHandle);
      if (0 != (hv_Params.TupleGetDictTuple("display_bottom_desc")))
      {
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),"Weight map "+hv_ImageIDStringBraces, 
              "window", "bottom", "left", "white", "box", "false");
      }
    }
    else
    {
      //Reset flush buffer of existing windows before throwing an exception.
      GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_WindowHandleKeys);
      {
      HTuple end_val1552 = (hv_WindowHandleKeys.TupleLength())-1;
      HTuple step_val1552 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val1552, step_val1552); hv_Index += step_val1552)
      {
        //Only consider the WindowHandleKeys that are needed for the current visualization.
        hv_Indices = hv_KeysForDisplay.TupleFind(HTuple(hv_WindowHandleKeys[hv_Index]));
        if (0 != (HTuple(int(hv_Indices!=-1)).TupleAnd(int(hv_Indices!=HTuple()))))
        {
          GetDictTuple(hv_WindowHandleDict, HTuple(hv_WindowHandleKeys[hv_Index]), 
              &hv_WindowHandles);
          {
          HTuple end_val1557 = (hv_WindowHandles.TupleLength())-1;
          HTuple step_val1557 = 1;
          for (hv_WindowIndex=0; hv_WindowIndex.Continue(end_val1557, step_val1557); hv_WindowIndex += step_val1557)
          {
            //Reset values of windows that have been changed temporarily.
            SetWindowParam(HTuple(hv_WindowHandles[hv_WindowIndex]), "flush", HTuple(hv_FlushValues[hv_Index]));
          }
          }
        }
      }
      }
      throw HException("Key for display unknown: "+HTuple(hv_KeysForDisplay[hv_KeyIndex]));
    }
    //
    hv_KeyIndex += 1;
  }
  //
  //Display results.
  GetDictParam(hv_WindowHandleDict, "keys", HTuple(), &hv_WindowHandleKeysNew);
  {
  HTuple end_val1571 = (hv_WindowHandleKeysNew.TupleLength())-1;
  HTuple step_val1571 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val1571, step_val1571); hv_Index += step_val1571)
  {
    //Only consider the WindowHandleKeys that are needed for the current visualization.
    hv_KeyIndex = hv_KeysForDisplay.TupleFind(HTuple(hv_WindowHandleKeysNew[hv_Index]));
    if (0 != (HTuple(int(hv_KeyIndex!=-1)).TupleAnd(int(hv_KeyIndex!=HTuple()))))
    {
      GetDictTuple(hv_WindowHandleDict, HTuple(hv_WindowHandleKeysNew[hv_Index]), 
          &hv_WindowHandles);
      {
      HTuple end_val1576 = (hv_WindowHandles.TupleLength())-1;
      HTuple step_val1576 = 1;
      for (hv_WindowIndex=0; hv_WindowIndex.Continue(end_val1576, step_val1576); hv_WindowIndex += step_val1576)
      {
        //Display content of window handle.
        if (0 != (int((hv_WindowHandleKeys.TupleLength())==(hv_WindowHandleKeysNew.TupleLength()))))
        {
          //Reset values of windows that have been changed temporarily.
          if (0 != (int(HTuple(hv_FlushValues[hv_WindowIndex])==HTuple("true"))))
          {
            FlushBuffer(HTuple(hv_WindowHandles[hv_WindowIndex]));
          }
          SetWindowParam(HTuple(hv_WindowHandles[hv_WindowIndex]), "flush", HTuple(hv_FlushValues[hv_WindowIndex]));
        }
        else
        {
          //Per default, 'flush' of new windows should be set to 'true'.
          FlushBuffer(HTuple(hv_WindowHandles[hv_WindowIndex]));
          SetWindowParam(HTuple(hv_WindowHandles[hv_WindowIndex]), "flush", "true");
        }
      }
      }
    }
  }
  }
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Close all windows whose handle is contained in the dictionary WindowHandleDict. 
void dev_display_dl_data_close_windows (HTuple hv_WindowHandleDict)
{

  //
  //This procedure closes all window handles
  //that are contained in the dictionary WindowHandleDict.
  //
  dev_close_window_dict(hv_WindowHandleDict);
  //
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Try to guess the maximum class id based on the given sample/result. 
void dev_display_dl_data_get_max_class_id (HTuple hv_DLSample, HTuple *hv_MaxClassId, 
    HTuple *hv_Empty)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Keys, hv_Matches, hv_Length, hv_Greatereq;
  HTuple  hv_Indices, hv_LengthAll, hv_KeyIndex, hv_Key, hv_KeyType;
  HTuple  hv_Tuple, hv_MaxTuple, hv_Exception;

  (*hv_MaxClassId) = -1;
  (*hv_Empty) = 0;
  try
  {
    GetDictParam(hv_DLSample, "keys", HTuple(), &hv_Keys);
    //Find keys that end on '_id'. (They contain ids!)
    TupleRegexpMatch(hv_Keys, "_id", &hv_Matches);
    TupleStrlen(hv_Matches, &hv_Length);
    TupleGreaterEqualElem(hv_Length, 1, &hv_Greatereq);
    TupleFind(hv_Greatereq, 1, &hv_Indices);
    if (0 != (int(hv_Indices>-1)))
    {
      //Find the maximum given class id.
      hv_LengthAll = 0;
      {
      HTuple end_val12 = (hv_Indices.TupleLength())-1;
      HTuple step_val12 = 1;
      for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val12, step_val12); hv_KeyIndex += step_val12)
      {
        hv_Key = HTuple(hv_Keys[HTuple(hv_Indices[hv_KeyIndex])]);
        //Skip image_id.
        if (0 != (int(hv_Key==HTuple("image_id"))))
        {
          continue;
        }
        GetDictParam(hv_DLSample, "key_data_type", hv_Key, &hv_KeyType);
        if (0 != (int(hv_KeyType!=HTuple("tuple"))))
        {
          continue;
        }
        GetDictTuple(hv_DLSample, hv_Key, &hv_Tuple);
        hv_LengthAll += hv_Tuple.TupleLength();
        if (0 != (int((hv_Tuple.TupleLength())==0)))
        {
          continue;
        }
        TupleMax(hv_Tuple, &hv_MaxTuple);
        if (0 != (int(hv_MaxTuple>(*hv_MaxClassId))))
        {
          (*hv_MaxClassId) = hv_MaxTuple;
        }
      }
      }
      if (0 != (int(hv_LengthAll==0)))
      {
        (*hv_Empty) = 1;
      }
    }
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    //Ignore any exception.
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Visualize for a given number of samples the raw image, ground truth annotation, and inferred results. 
void dev_display_dl_data_tiled (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_NumSamples, 
    HTuple hv_Split, HTuple hv_GenParam, HTuple hv_WindowHandle, HTuple *hv_WindowHandleOut)
{

  // Local iconic variables
  HObject  ho_FinalRows, ho_SampleImages, ho_SampleImage;
  HObject  ho_FirstChannel, ho_ImageScaled, ho_ImageConverted;
  HObject  ho_TiledImageRow, ho_TiledImage, ho_Domain, ho_RegionComplement;
  HObject  ho_InstanceMasks, ho_InstanceMask, ho_ResInstanceMasks;
  HObject  ho_Image, ho_ImageCleared, ho_Regions, ho_TiledResult;

  // Local control variables
  HTuple  hv_BackGroundColor, hv_SpacingRow, hv_SpacingCol;
  HTuple  hv_WindowRow, hv_WindowCol, hv_WindowWidth, hv_WindowHeight;
  HTuple  hv_IncludeImage, hv_IncludeGroundTruth, hv_IncludeResults;
  HTuple  hv_Keys, hv_Index, hv_Key, hv_Value, hv_ModelType;
  HTuple  hv_Samples, hv_AnomalyLabelExists, hv_OCRLabelExists;
  HTuple  hv_ClassificationLabelExists, hv_DetectionLabelExists;
  HTuple  hv_SegmentationLabelExists, hv_XYZExists, hv_OCRDetectionLabelExists;
  HTuple  hv_DLSamples, hv_SampleIndices, hv_DLResult, hv_ClassIdsExist;
  HTuple  hv_ClassIDs, hv_BackGroundClass, hv_RGB, hv_Scale;
  HTuple  hv_Shift, hv_KeyExists, hv_DLDatasetPreprocessParam;
  HTuple  hv_NormType, hv_KeyMinExists, hv_KeyMaxExists, hv_ImageRangeMin;
  HTuple  hv_ImageRangeMax, hv_Channels, hv_Width, hv_Height;
  HTuple  hv_Crop, hv_OffsetRow, hv_TiledWidth, hv_TiledHeight;
  HTuple  hv_NumResult, hv_PredictionsCorrect, hv_ImageConfidences;
  HTuple  hv_ResClassIndices, hv_ResClasses, hv_ImageIDs;
  HTuple  hv_ImageLabelIDs, hv_IndexResult, hv_ImageConfidence;
  HTuple  hv_ResClassIndex, hv_ResClass, hv_ImageID, hv_ImageLabelID;
  HTuple  hv_PredictionCorrect, hv_TextImageRows, hv_TextImageColumns;
  HTuple  hv_TextImageWidth, hv_TextImageHeight, hv_TopOffset;
  HTuple  hv_InstanceType, hv_Rect1KeyExists, hv_Rect2KeyExists;
  HTuple  hv_MasksExist, hv_GTLabel, hv_GTCol1, hv_GTRow1;
  HTuple  hv_GTCol2, hv_GTRow2, hv_GTCol, hv_GTRow, hv_GTLength1;
  HTuple  hv_GTLength2, hv_GTPhi, hv_LeftOffset, hv_LabelId;
  HTuple  hv_Col1, hv_Row1, hv_Col2, hv_Row2, hv_Col, hv_Row;
  HTuple  hv_Length1, hv_Length2, hv_Phi, hv_ResConfidence;
  HTuple  hv_ResCol1, hv_ResRow1, hv_ResCol2, hv_ResRow2;
  HTuple  hv_ResCol, hv_ResRow, hv_ResLength1, hv_ResLength2;
  HTuple  hv_ResPhi, hv_CurrentResult, hv_ClassId, hv_Confidence;
  HTuple  hv_ResultMaskExists, hv_ResWords, hv_GTWord, hv_ResWord;
  HTuple  hv_TiledDLSample, hv_CharIndices, hv_TiledDLResult;
  HTuple  hv_Words, hv_DisplayGenParam, hv_IgnoreDirection;
  HTuple  hv_WindowHandleDict, hv_NoInputWindow, hv_Flush;
  HTuple  hv_KeyForDisplay, hv_GTText, hv_PredictionText;
  HTuple  hv__, hv_GTWidth, hv_TextHeight, hv_PredictionWidth;
  HTuple  hv_WindowImageRatio, hv_WindowWidthMax, hv_WindowHeightMax;
  HTuple  hv_Ratio, hv_ImageWidth, hv_ImageHeight, hv_ImageWindowWidthRatio;
  HTuple  hv_ImageWindowHeightRatio, hv_CharWindowWidth, hv_CharWindowHeight;
  HTuple  hv_CharImageWidth, hv_CharImageHeight, hv_ImageRow;
  HTuple  hv_ImageColumn, hv_String, hv_StringWindowWidth;
  HTuple  hv_StringImageWidth;

  //
  //This procedure visualizes samples, their ground truth annotations, and,
  //if not deactivated, the results obtained by applying the model given by DLModelHandle.
  //
  //** Set the default values for all the generic parameters: ***
  //
  hv_BackGroundColor = "#ffffff";
  hv_SpacingRow = 0;
  hv_SpacingCol = 0;
  hv_WindowRow = 0;
  hv_WindowCol = 0;
  hv_WindowWidth = 640;
  hv_WindowHeight = 480;
  //
  //For a model of type '3d_gripping_point detection', 'detection', and 'segmentation', it is displayed:
  //- the plain input images in the first row,
  //- the image and their ground truth annotations in the second row,
  //- the image and their inference results in the third row.
  //
  //For models of type 'classification', it is displayed:
  //- the input image with a prediction box.
  //
  //For models of type 'gc_anomaly_detection' no results are displayed.
  //
  hv_IncludeImage = 1;
  hv_IncludeGroundTruth = 1;
  hv_IncludeResults = 1;
  //
  if (0 != (int((hv_GenParam.TupleLength())==1)))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_Keys);
    {
    HTuple end_val30 = (hv_Keys.TupleLength())-1;
    HTuple step_val30 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val30, step_val30); hv_Index += step_val30)
    {
      hv_Key = HTuple(hv_Keys[hv_Index]);
      GetDictTuple(hv_GenParam, hv_Key, &hv_Value);
      if (0 != (int(hv_Key==HTuple("background_color"))))
      {
        hv_BackGroundColor = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("spacing_row"))))
      {
        hv_SpacingRow = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("spacing_col"))))
      {
        hv_SpacingCol = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("window_width"))))
      {
        hv_WindowWidth = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("window_height"))))
      {
        hv_WindowHeight = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("window_row"))))
      {
        hv_WindowRow = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("window_col"))))
      {
        hv_WindowCol = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("display_input"))))
      {
        hv_IncludeImage = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("display_ground_truth"))))
      {
        hv_IncludeGroundTruth = hv_Value;
      }
      else if (0 != (int(hv_Key==HTuple("display_result"))))
      {
        hv_IncludeResults = hv_Value;
      }
    }
    }
  }
  //
  //If a model was handed over, get model type.
  if (0 != (int(hv_DLModelHandle!=HTuple())))
  {
    GetDlModelParam(hv_DLModelHandle, "type", &hv_ModelType);
    if (0 != (HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(int(hv_ModelType!=HTuple("classification"))).TupleAnd(int(hv_ModelType!=HTuple("detection")))).TupleAnd(int(hv_ModelType!=HTuple("gc_anomaly_detection")))).TupleAnd(int(hv_ModelType!=HTuple("ocr_detection")))).TupleAnd(int(hv_ModelType!=HTuple("ocr_recognition")))).TupleAnd(int(hv_ModelType!=HTuple("segmentation")))).TupleAnd(int(hv_ModelType!=HTuple("3d_gripping_point_detection")))))
    {
      throw HException("Invalid model type");
    }
    if (0 != (int(hv_ModelType==HTuple("gc_anomaly_detection"))))
    {
      hv_IncludeResults = 0;
    }
  }
  else
  {
    //
    //If no model was handed over, results are not displayed.
    hv_IncludeResults = 0;
    //Conclude the model type from the existing keys
    GetDictTuple(hv_DLDataset, "samples", &hv_Samples);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "anomaly_label", &hv_AnomalyLabelExists);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "word", &hv_OCRLabelExists);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "image_label_id", &hv_ClassificationLabelExists);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "bbox_label_id", &hv_DetectionLabelExists);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "segmentation_file_name", &hv_SegmentationLabelExists);
    GetDictParam(HTuple(hv_Samples[0]), "key_exists", "xyz_file_name", &hv_XYZExists);
    if (0 != hv_AnomalyLabelExists)
    {
      hv_ModelType = "gc_anomaly_detction";
    }
    else if (0 != hv_ClassificationLabelExists)
    {
      hv_ModelType = "classification";
    }
    else if (0 != hv_OCRLabelExists)
    {
      GetDictParam(HTuple(hv_Samples[0]), "key_exists", "bbox_label_id", &hv_OCRDetectionLabelExists);
      if (0 != hv_OCRDetectionLabelExists)
      {
        throw HException("The model handle is required for Deep OCR detection.");
      }
      else
      {
        throw HException("The model handle is required for Deep OCR recognition.");
      }
    }
    else if (0 != hv_DetectionLabelExists)
    {
      hv_ModelType = "detection";
    }
    else if (0 != hv_SegmentationLabelExists)
    {
      if (0 != hv_XYZExists)
      {
        hv_ModelType = "3d_gripping_point_detection";
      }
      else
      {
        hv_ModelType = "segmentation";
      }
    }
    else
    {
      throw HException("Cannot conclude model type from DLDataset.");
    }
  }
  //
  //** Generate results for a random subset of NumSamples-many samples: ***
  //
  //Select random samples.
  GetDictTuple(hv_DLDataset, "samples", &hv_DLSamples);
  find_dl_samples(hv_DLSamples, "split", hv_Split, "or", &hv_SampleIndices);
  tuple_shuffle(hv_SampleIndices, &hv_SampleIndices);
  //
  //Make sure that NumSamples is not bigger than the found number of SampleIndices
  hv_NumSamples = hv_NumSamples.TupleMin2(hv_SampleIndices.TupleLength());
  //Calculate the result for the selected samples.
  hv_SampleIndices = hv_SampleIndices.TupleSelectRange(0,hv_NumSamples-1);
  //
  if (0 != hv_IncludeResults)
  {
    read_dl_samples(hv_DLDataset, hv_SampleIndices, &hv_DLSamples);
    ApplyDlModel(hv_DLModelHandle, hv_DLSamples, HTuple(), &hv_DLResult);
    hv_DLResult = hv_DLResult.TupleSelectRange(0,hv_NumSamples-1);
    hv_DLSamples = hv_DLSamples.TupleSelectRange(0,hv_NumSamples-1);
  }
  else
  {
    read_dl_samples(hv_DLDataset, hv_SampleIndices, &hv_DLSamples);
  }
  //
  //** Generate the tiled image and the tiled result data: ***
  //
  GetDictParam(hv_DLDataset, "key_exists", "class_ids", &hv_ClassIdsExist);
  if (0 != hv_ClassIdsExist)
  {
    GetDictTuple(hv_DLDataset, "class_ids", &hv_ClassIDs);
    //For segmentation models, we need a class ID that is not present in class_ids, to
    //mark regions without region visualization.
    hv_BackGroundClass = (hv_ClassIDs.TupleMax())+1;
  }
  hv_RGB.Clear();
  hv_RGB.Append(("0x"+(hv_BackGroundColor.TupleSubstr(1,2))).TupleNumber());
  hv_RGB.Append(("0x"+(hv_BackGroundColor.TupleSubstr(3,4))).TupleNumber());
  hv_RGB.Append(("0x"+(hv_BackGroundColor.TupleSubstr(5,6))).TupleNumber());
  //
  GenEmptyObj(&ho_FinalRows);
  //
  //Generate the tiled sample image.
  //For the visualization it is better to use byte images.
  //The problem is that if you don't convert to bytes the range used to display is dynamic.
  //That means there can be strong fluctuations between several images, especially if there are "outliers" in the images.
  //By default expected range of the input image is [-127,128], but this is not the case for the normalization type 'constant_values'.
  hv_Scale = 1.0;
  hv_Shift = 127.0;
  GetDictParam(hv_DLDataset, "key_exists", "preprocess_param", &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    GetDictTuple(hv_DLDataset, "preprocess_param", &hv_DLDatasetPreprocessParam);
    GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "normalization_type", 
        &hv_KeyExists);
    if (0 != hv_KeyExists)
    {
      GetDictTuple(hv_DLDatasetPreprocessParam, "normalization_type", &hv_NormType);

      GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "image_range_min", 
          &hv_KeyMinExists);
      GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "image_range_min", 
          &hv_KeyMaxExists);
      if (0 != (hv_KeyMinExists.TupleAnd(hv_KeyMaxExists)))
      {
        GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_min", &hv_ImageRangeMin);
        GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_max", &hv_ImageRangeMax);
      }
      else
      {
        if (0 != (int(hv_NormType==HTuple("constant_values"))))
        {
          hv_ImageRangeMin = -2.0;
          hv_ImageRangeMax = 2.0;
        }
        else
        {
          hv_ImageRangeMin = -127.0;
          hv_ImageRangeMax = 128.0;
        }
      }
      if (0 != (int((hv_ImageRangeMax-hv_ImageRangeMin)==0)))
      {
        hv_Scale = 1.0;
      }
      else
      {
        hv_Scale = 255.0/(hv_ImageRangeMax-hv_ImageRangeMin);
      }
      hv_Shift = (-hv_Scale)*hv_ImageRangeMin;
    }
  }
  GenEmptyObj(&ho_SampleImages);
  {
  HTuple end_val173 = hv_NumSamples-1;
  HTuple step_val173 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val173, step_val173); hv_Index += step_val173)
  {
    GetDictObject(&ho_SampleImage, HTuple(hv_DLSamples[hv_Index]), "image");
    CountChannels(ho_SampleImage, &hv_Channels);
    if (0 != (int(hv_Channels!=3)))
    {
      //For any number of channels, that is not three, just use the first channel.
      AccessChannel(ho_SampleImage, &ho_FirstChannel, 1);
      Compose3(ho_FirstChannel, ho_FirstChannel, ho_FirstChannel, &ho_SampleImage
          );
    }
    //Convert the images back to byte.
    ScaleImage(ho_SampleImage, &ho_ImageScaled, hv_Scale, hv_Shift);
    ConvertImageType(ho_ImageScaled, &ho_ImageConverted, "byte");
    //Add the image to the tuple SampleImages.
    ConcatObj(ho_SampleImages, ho_ImageConverted, &ho_SampleImages);
  }
  }
  //Tile the images in a row.
  GetImageSize(ho_SampleImages, &hv_Width, &hv_Height);
  TupleGenConst(hv_Width.TupleLength(), -1, &hv_Crop);
  TupleGenConst(hv_Width.TupleLength(), 0, &hv_OffsetRow);

  if (0 != (HTuple(HTuple(HTuple(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("segmentation")))).TupleOr(int(hv_ModelType==HTuple("ocr_detection")))).TupleOr(int(hv_ModelType==HTuple("ocr_recognition")))).TupleOr(int(hv_ModelType==HTuple("3d_gripping_point_detection")))))
  {
    TileImagesOffset(ho_SampleImages, &ho_TiledImageRow, hv_OffsetRow, (HTuple(0).TupleConcat((hv_Width+hv_SpacingCol).TupleCumul())).TupleSelectRange(0,(hv_Width.TupleLength())-1), 
        hv_Crop, hv_Crop, hv_Crop, hv_Crop, HTuple(((hv_Width+hv_SpacingCol).TupleCumul())[(hv_Width.TupleLength())-1])-hv_SpacingCol, 
        hv_Height.TupleMax());
  }
  //
  //Generate the columns of images for the tiled output.
  if (0 != hv_IncludeImage)
  {
    if (0 != (int(hv_ModelType==HTuple("classification"))))
    {
      throw HException("The key 'display_input' cannot be set for model type classification.");
      return;
    }
    ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
  }
  if (0 != hv_IncludeGroundTruth)
  {
    if (0 != (int(hv_ModelType==HTuple("classification"))))
    {
      throw HException("The key 'display_ground_truth' cannot be set for model type classification.");
      return;
    }
    ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
  }
  if (0 != (HTuple(HTuple(HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("segmentation")))).TupleOr(int(hv_ModelType==HTuple("ocr_detection")))).TupleOr(int(hv_ModelType==HTuple("3d_gripping_point_detection")))))
  {
    if (0 != hv_IncludeResults)
    {
      ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
    }
    GetImageSize(ho_FinalRows, &hv_TiledWidth, &hv_TiledHeight);
    TileImagesOffset(ho_FinalRows, &ho_TiledImage, (HTuple(0).TupleConcat((hv_TiledHeight+hv_SpacingRow).TupleCumul())).TupleSelectRange(0,(hv_TiledHeight.TupleLength())-1), 
        HTuple(hv_TiledHeight.TupleLength(),0), HTuple(hv_TiledHeight.TupleLength(),-1), 
        HTuple(hv_TiledHeight.TupleLength(),-1), HTuple(hv_TiledHeight.TupleLength(),-1), 
        HTuple(hv_TiledHeight.TupleLength(),-1), hv_TiledWidth.TupleMax(), HTuple(((hv_TiledHeight+hv_SpacingRow).TupleCumul())[(hv_TiledHeight.TupleLength())-1])-hv_SpacingRow);
    //Fill up with the background color.
    if (0 != (int(hv_ModelType!=HTuple("3d_gripping_point_detection"))))
    {
      GetDomain(ho_TiledImage, &ho_Domain);
      FullDomain(ho_TiledImage, &ho_TiledImage);
      Complement(ho_Domain, &ho_RegionComplement);
      OverpaintRegion(ho_TiledImage, ho_RegionComplement, hv_RGB, "fill");
    }
  }
  //
  //Generate the tiled data (classification prediction / detection bounding boxes /
  //ocr colored bar / segmentation regions ).
  if (0 != (int(hv_ModelType==HTuple("classification"))))
  {
    //
    //For classification results the image is shown within a colored frame.
    //
    GenEmptyObj(&ho_FinalRows);
    //
    if (0 != hv_IncludeResults)
    {
      TupleLength(hv_DLResult, &hv_NumResult);
      hv_PredictionsCorrect = HTuple();
      hv_ImageConfidences = HTuple();
      hv_ResClassIndices = HTuple();
      hv_ResClasses = HTuple();
      hv_ImageIDs = HTuple();
      hv_ImageLabelIDs = HTuple();
      //
      {
      HTuple end_val243 = hv_NumResult-1;
      HTuple step_val243 = 1;
      for (hv_IndexResult=0; hv_IndexResult.Continue(end_val243, step_val243); hv_IndexResult += step_val243)
      {
        //
        //Get labels and classes.
        GetDictTuple(HTuple(hv_DLResult[hv_IndexResult]), "classification_confidences", 
            &hv_ImageConfidence);
        GetDictTuple(HTuple(hv_DLResult[hv_IndexResult]), "classification_class_ids", 
            &hv_ResClassIndex);
        GetDictTuple(HTuple(hv_DLResult[hv_IndexResult]), "classification_class_names", 
            &hv_ResClass);
        GetDictTuple(HTuple(hv_DLSamples[hv_IndexResult]), "image_id", &hv_ImageID);
        GetDictTuple(HTuple(hv_DLSamples[hv_IndexResult]), "image_label_id", &hv_ImageLabelID);
        //
        //Check whether the actual sample prediction is false or correct.
        hv_PredictionCorrect = int(HTuple(hv_ResClassIndex[0])==hv_ImageLabelID);
        hv_PredictionsCorrect = hv_PredictionsCorrect.TupleConcat(hv_PredictionCorrect);
        hv_ImageConfidences = hv_ImageConfidences.TupleConcat(HTuple(hv_ImageConfidence[0]));
        hv_ResClassIndices = hv_ResClassIndices.TupleConcat(HTuple(hv_ResClassIndex[0]));
        hv_ResClasses = hv_ResClasses.TupleConcat(HTuple(hv_ResClass[0]));
        hv_ImageIDs = hv_ImageIDs.TupleConcat(hv_ImageID);
        hv_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(hv_ImageLabelID);
      }
      }
      //
      //Tile the sample images.
      gen_tiled_classification_image_result(&ho_TiledImageRow, hv_DLSamples, hv_SpacingCol, 
          hv_PredictionsCorrect, hv_ResClasses, &hv_TextImageRows, &hv_TextImageColumns, 
          &hv_TextImageWidth, &hv_TextImageHeight);
      ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
    }
    GetImageSize(ho_FinalRows, &hv_TiledWidth, &hv_TiledHeight);
    ho_TiledImage = ho_TiledImageRow;
    //
  }
  else if (0 != (HTuple(int(hv_ModelType==HTuple("detection"))).TupleOr(int(hv_ModelType==HTuple("ocr_detection")))))
  {
    //
    //For detection results the detected boxes must be moved
    //to the positions of the respective image.
    hv_TopOffset = 0;
    if (0 != hv_IncludeImage)
    {
      hv_TopOffset = (hv_TopOffset+hv_SpacingRow)+HTuple(hv_TiledHeight[0]);
    }
    //Check the detection type.
    if (0 != (HTuple(int((hv_DLModelHandle.TupleLength())>0)).TupleAnd(int(hv_ModelType==HTuple("detection")))))
    {
      GetDlModelParam(hv_DLModelHandle, "instance_type", &hv_InstanceType);
    }
    else
    {
      GetDictParam(HTuple(hv_DLSamples[0]), "key_exists", "bbox_row1", &hv_Rect1KeyExists);
      if (0 != hv_Rect1KeyExists)
      {
        hv_InstanceType = "rectangle1";
      }
      else
      {
        GetDictParam(HTuple(hv_DLSamples[0]), "key_exists", "bbox_phi", &hv_Rect2KeyExists);
        if (0 != hv_Rect2KeyExists)
        {
          hv_InstanceType = "rectangle2";
        }
        else
        {
          throw HException("Not suitable sample keys!");
        }
      }
    }
    //Check if masks exist.
    GetDictParam(HTuple(hv_DLSamples[0]), "key_exists", "mask", &hv_MasksExist);
    if (0 != hv_MasksExist)
    {
      GenEmptyObj(&ho_InstanceMasks);
    }
    //Move the ground truth labels.
    hv_GTLabel = HTuple();
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      hv_GTCol1 = HTuple();
      hv_GTRow1 = HTuple();
      hv_GTCol2 = HTuple();
      hv_GTRow2 = HTuple();
    }
    else
    {
      hv_GTCol = HTuple();
      hv_GTRow = HTuple();
      hv_GTLength1 = HTuple();
      hv_GTLength2 = HTuple();
      hv_GTPhi = HTuple();
    }
    if (0 != hv_IncludeGroundTruth)
    {
      hv_LeftOffset = 0;
      {
      HTuple end_val314 = hv_NumSamples-1;
      HTuple step_val314 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val314, step_val314); hv_Index += step_val314)
      {
        GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_label_id", &hv_LabelId);
        hv_GTLabel = hv_GTLabel.TupleConcat(hv_LabelId);
        if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
        {
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_col1", &hv_Col1);
          hv_GTCol1 = hv_GTCol1.TupleConcat(hv_Col1+hv_LeftOffset);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_row1", &hv_Row1);
          hv_GTRow1 = hv_GTRow1.TupleConcat(hv_Row1+hv_TopOffset);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_col2", &hv_Col2);
          hv_GTCol2 = hv_GTCol2.TupleConcat(hv_Col2+hv_LeftOffset);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_row2", &hv_Row2);
          hv_GTRow2 = hv_GTRow2.TupleConcat(hv_Row2+hv_TopOffset);
        }
        else
        {
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_col", &hv_Col);
          hv_GTCol = hv_GTCol.TupleConcat(hv_Col+hv_LeftOffset);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_row", &hv_Row);
          hv_GTRow = hv_GTRow.TupleConcat(hv_Row+hv_TopOffset);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_length1", &hv_Length1);
          hv_GTLength1 = hv_GTLength1.TupleConcat(hv_Length1);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_length2", &hv_Length2);
          hv_GTLength2 = hv_GTLength2.TupleConcat(hv_Length2);
          GetDictTuple(HTuple(hv_DLSamples[hv_Index]), "bbox_phi", &hv_Phi);
          hv_GTPhi = hv_GTPhi.TupleConcat(hv_Phi);
        }
        if (0 != hv_MasksExist)
        {
          GetDictObject(&ho_InstanceMask, HTuple(hv_DLSamples[hv_Index]), "mask");
          MoveRegion(ho_InstanceMask, &ho_InstanceMask, hv_TopOffset, hv_LeftOffset);
          ConcatObj(ho_InstanceMasks, ho_InstanceMask, &ho_InstanceMasks);
        }
        hv_LeftOffset = (hv_LeftOffset+hv_SpacingCol)+HTuple(hv_Width[hv_Index]);
      }
      }
      hv_TopOffset = (hv_TopOffset+hv_SpacingRow)+HTuple(hv_TiledHeight[0]);
    }
    hv_ResClass = HTuple();
    hv_ResConfidence = HTuple();
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      hv_ResCol1 = HTuple();
      hv_ResRow1 = HTuple();
      hv_ResCol2 = HTuple();
      hv_ResRow2 = HTuple();
    }
    else
    {
      hv_ResCol = HTuple();
      hv_ResRow = HTuple();
      hv_ResLength1 = HTuple();
      hv_ResLength2 = HTuple();
      hv_ResPhi = HTuple();
    }
    if (0 != hv_MasksExist)
    {
      GenEmptyObj(&ho_ResInstanceMasks);
    }
    //Move the result classes.
    if (0 != hv_IncludeResults)
    {
      hv_LeftOffset = 0;
      {
      HTuple end_val367 = hv_NumSamples-1;
      HTuple step_val367 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val367, step_val367); hv_Index += step_val367)
      {
        if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
        {
          hv_CurrentResult = HTuple(hv_DLResult[hv_Index]);
          hv_CurrentResult = hv_CurrentResult.TupleGetDictTuple("words");
          GetDictTuple(hv_CurrentResult, "col", &hv_Col);
          hv_ResCol = hv_ResCol.TupleConcat(hv_Col+hv_LeftOffset);
          GetDictTuple(hv_CurrentResult, "row", &hv_Row);
          hv_ResRow = hv_ResRow.TupleConcat(hv_Row+hv_TopOffset);
          GetDictTuple(hv_CurrentResult, "length1", &hv_Length1);
          hv_ResLength1 = hv_ResLength1.TupleConcat(hv_Length1);
          GetDictTuple(hv_CurrentResult, "length2", &hv_Length2);
          hv_ResLength2 = hv_ResLength2.TupleConcat(hv_Length2);
          GetDictTuple(hv_CurrentResult, "phi", &hv_Phi);
          hv_ResPhi = hv_ResPhi.TupleConcat(hv_Phi);
        }
        else
        {
          GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_class_id", &hv_ClassId);
          hv_ResClass = hv_ResClass.TupleConcat(hv_ClassId);
          GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_confidence", &hv_Confidence);
          hv_ResConfidence = hv_ResConfidence.TupleConcat(hv_Confidence);
          if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
          {
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_col1", &hv_Col1);
            hv_ResCol1 = hv_ResCol1.TupleConcat(hv_Col1+hv_LeftOffset);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_row1", &hv_Row1);
            hv_ResRow1 = hv_ResRow1.TupleConcat(hv_Row1+hv_TopOffset);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_col2", &hv_Col2);
            hv_ResCol2 = hv_ResCol2.TupleConcat(hv_Col2+hv_LeftOffset);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_row2", &hv_Row2);
            hv_ResRow2 = hv_ResRow2.TupleConcat(hv_Row2+hv_TopOffset);
          }
          else
          {
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_col", &hv_Col);
            hv_ResCol = hv_ResCol.TupleConcat(hv_Col+hv_LeftOffset);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_row", &hv_Row);
            hv_ResRow = hv_ResRow.TupleConcat(hv_Row+hv_TopOffset);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_length1", &hv_Length1);
            hv_ResLength1 = hv_ResLength1.TupleConcat(hv_Length1);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_length2", &hv_Length2);
            hv_ResLength2 = hv_ResLength2.TupleConcat(hv_Length2);
            GetDictTuple(HTuple(hv_DLResult[hv_Index]), "bbox_phi", &hv_Phi);
            hv_ResPhi = hv_ResPhi.TupleConcat(hv_Phi);
          }
        }
        if (0 != hv_MasksExist)
        {
          GetDictParam(HTuple(hv_DLResult[hv_Index]), "key_exists", "mask", &hv_ResultMaskExists);
          if (0 != hv_ResultMaskExists)
          {
            GetDictObject(&ho_InstanceMask, HTuple(hv_DLResult[hv_Index]), "mask");
            MoveRegion(ho_InstanceMask, &ho_InstanceMask, hv_TopOffset, hv_LeftOffset);
            ConcatObj(ho_ResInstanceMasks, ho_InstanceMask, &ho_ResInstanceMasks);
          }
        }
        hv_LeftOffset = (hv_LeftOffset+hv_SpacingCol)+HTuple(hv_Width[hv_Index]);
      }
      }
    }
    //
  }
  else if (0 != (HTuple(int(hv_ModelType==HTuple("segmentation"))).TupleOr(int(hv_ModelType==HTuple("3d_gripping_point_detection")))))
  {
    //
    //The tiled segmentation result image is constructed in the same way as the tiled sample image.
    GenEmptyObj(&ho_FinalRows);
    if (0 != hv_IncludeImage)
    {
      GenImageConst(&ho_Image, "real", HTuple(hv_TiledWidth[0]), HTuple(hv_TiledHeight[0]));
      //For the top (image) row, set the (virtual) background class as segmentation result.
      GenImageProto(ho_Image, &ho_ImageCleared, hv_BackGroundClass);
      ConcatObj(ho_FinalRows, ho_ImageCleared, &ho_FinalRows);
    }
    //
    if (0 != hv_IncludeGroundTruth)
    {
      gen_tiled_segmentation_image(&ho_TiledImageRow, hv_DLSamples, hv_SpacingCol, 
          hv_Width, hv_Height);
      if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
      {
        //Map the ground truth class IDs to [1, 0].
        Threshold(ho_TiledImageRow, &ho_Regions, hv_ClassIDs, hv_ClassIDs);
        OverpaintRegion(ho_TiledImageRow, ho_Regions, (HTuple(1).Append(0)), "fill");
      }
      ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
    }
    //
    if (0 != hv_IncludeResults)
    {
      gen_tiled_segmentation_image(&ho_TiledImageRow, hv_DLResult, hv_SpacingCol, 
          hv_Width, hv_Height);
      ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
    }
    GetImageSize(ho_FinalRows, &hv_TiledWidth, &hv_TiledHeight);
    TileImagesOffset(ho_FinalRows, &ho_TiledResult, (HTuple(0).TupleConcat((hv_TiledHeight+hv_SpacingRow).TupleCumul())).TupleSelectRange(0,(hv_TiledHeight.TupleLength())-1), 
        HTuple(hv_TiledHeight.TupleLength(),0), HTuple(hv_TiledHeight.TupleLength(),-1), 
        HTuple(hv_TiledHeight.TupleLength(),-1), HTuple(hv_TiledHeight.TupleLength(),-1), 
        HTuple(hv_TiledHeight.TupleLength(),-1), hv_TiledWidth.TupleMax(), HTuple(((hv_TiledHeight+hv_SpacingRow).TupleCumul())[(hv_TiledHeight.TupleLength())-1])-hv_SpacingRow);
    //Fill up with the background color.
    if (0 != (int(hv_ModelType!=HTuple("3d_gripping_point_detection"))))
    {
      GetDomain(ho_TiledResult, &ho_Domain);
      FullDomain(ho_TiledResult, &ho_TiledResult);
      Complement(ho_Domain, &ho_RegionComplement);
      OverpaintRegion(ho_TiledResult, ho_RegionComplement, hv_BackGroundClass, "fill");
    }
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    //
    //For ocr_recognition the results are shown within a colored bar below the images.
    GenEmptyObj(&ho_FinalRows);
    //
    if (0 != hv_IncludeResults)
    {
      TupleLength(hv_DLResult, &hv_NumResult);
      hv_PredictionsCorrect = HTuple();
      hv_ResWords = HTuple();
      //
      {
      HTuple end_val464 = hv_NumResult-1;
      HTuple step_val464 = 1;
      for (hv_IndexResult=0; hv_IndexResult.Continue(end_val464, step_val464); hv_IndexResult += step_val464)
      {
        //
        //Get ground truth word and resulting word.
        GetDictTuple(HTuple(hv_DLSamples[hv_IndexResult]), "word", &hv_GTWord);
        GetDictTuple(HTuple(hv_DLResult[hv_IndexResult]), "word", &hv_ResWord);
        //
        //Check whether the sample prediction is correct or not.
        hv_PredictionCorrect = int(hv_ResWord==hv_GTWord);
        hv_ResWords = hv_ResWords.TupleConcat(hv_ResWord);
        hv_PredictionsCorrect = hv_PredictionsCorrect.TupleConcat(hv_PredictionCorrect);
      }
      }
      //
      //Tile the sample images.
      gen_tiled_ocr_recognition_image_result(&ho_TiledImageRow, hv_DLSamples, hv_PredictionsCorrect, 
          &hv_TextImageRows, &hv_TextImageColumns, &hv_TextImageWidth, &hv_TextImageHeight);
      ConcatObj(ho_FinalRows, ho_TiledImageRow, &ho_FinalRows);
    }
    GetImageSize(ho_FinalRows, &hv_TiledWidth, &hv_TiledHeight);
    ho_TiledImage = ho_TiledImageRow;
  }
  //
  //** Generate a TiledDLSample and a TiledDLResult to display them with dev_display_dl_data: ***
  //
  //Generate a tiled DLSample.
  if (0 != (int(hv_ModelType==HTuple("classification"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
    SetDictTuple(hv_TiledDLSample, "image_id", hv_ImageID);
    SetDictTuple(hv_TiledDLSample, "image_label_id", hv_ImageLabelID);
  }
  else if (0 != (int(hv_ModelType==HTuple("detection"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
    SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      SetDictTuple(hv_TiledDLSample, "bbox_col1", hv_GTCol1);
      SetDictTuple(hv_TiledDLSample, "bbox_row1", hv_GTRow1);
      SetDictTuple(hv_TiledDLSample, "bbox_col2", hv_GTCol2);
      SetDictTuple(hv_TiledDLSample, "bbox_row2", hv_GTRow2);
    }
    else
    {
      SetDictTuple(hv_TiledDLSample, "bbox_col", hv_GTCol);
      SetDictTuple(hv_TiledDLSample, "bbox_row", hv_GTRow);
      SetDictTuple(hv_TiledDLSample, "bbox_length1", hv_GTLength1);
      SetDictTuple(hv_TiledDLSample, "bbox_length2", hv_GTLength2);
      SetDictTuple(hv_TiledDLSample, "bbox_phi", hv_GTPhi);
    }
    if (0 != hv_MasksExist)
    {
      SetDictObject(ho_InstanceMasks, hv_TiledDLSample, "mask");
    }
  }
  else if (0 != (int(hv_ModelType==HTuple("segmentation"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
  }
  else if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    gen_dl_samples_from_images(ho_TiledImage, &hv_TiledDLSample);
    TupleFind(hv_GTLabel, 1, &hv_CharIndices);
    TupleRemove(hv_GTLabel, hv_CharIndices, &hv_GTLabel);
    SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
    TupleRemove(hv_GTCol, hv_CharIndices, &hv_GTCol);
    SetDictTuple(hv_TiledDLSample, "bbox_col", hv_GTCol);
    TupleRemove(hv_GTRow, hv_CharIndices, &hv_GTRow);
    SetDictTuple(hv_TiledDLSample, "bbox_row", hv_GTRow);
    TupleRemove(hv_GTLength1, hv_CharIndices, &hv_GTLength1);
    SetDictTuple(hv_TiledDLSample, "bbox_length1", hv_GTLength1);
    TupleRemove(hv_GTLength2, hv_CharIndices, &hv_GTLength2);
    SetDictTuple(hv_TiledDLSample, "bbox_length2", hv_GTLength2);
    TupleRemove(hv_GTPhi, hv_CharIndices, &hv_GTPhi);
    SetDictTuple(hv_TiledDLSample, "bbox_phi", hv_GTPhi);
  }
  //
  //Generate a tiled DLResult.
  CreateDict(&hv_TiledDLResult);
  if (0 != (int(hv_ModelType==HTuple("classification"))))
  {
    SetDictTuple(hv_TiledDLResult, "image_class_id", HTuple(hv_ResClassIndices[0]));
    SetDictTuple(hv_TiledDLResult, "image_confidence", hv_ImageConfidences);
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    SetDictTuple(hv_TiledDLResult, "word", hv_ResWords);
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    CreateDict(&hv_Words);
    SetDictTuple(hv_TiledDLResult, "words", hv_Words);
    SetDictTuple(hv_Words, "col", hv_ResCol);
    SetDictTuple(hv_Words, "row", hv_ResRow);
    SetDictTuple(hv_Words, "length1", hv_ResLength1);
    SetDictTuple(hv_Words, "length2", hv_ResLength2);
    SetDictTuple(hv_Words, "phi", hv_ResPhi);
  }
  else if (0 != (int(hv_ModelType==HTuple("segmentation"))))
  {
    SetDictObject(ho_TiledResult, hv_TiledDLResult, "segmentation_image");
  }
  else if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
  {
    SetDictObject(ho_TiledResult, hv_TiledDLResult, "gripping_map");
  }
  else if (0 != (int(hv_ModelType==HTuple("detection"))))
  {
    SetDictTuple(hv_TiledDLResult, "bbox_class_id", hv_ResClass);
    SetDictTuple(hv_TiledDLResult, "bbox_confidence", hv_ResConfidence);
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      SetDictTuple(hv_TiledDLResult, "bbox_col1", hv_ResCol1);
      SetDictTuple(hv_TiledDLResult, "bbox_row1", hv_ResRow1);
      SetDictTuple(hv_TiledDLResult, "bbox_col2", hv_ResCol2);
      SetDictTuple(hv_TiledDLResult, "bbox_row2", hv_ResRow2);
    }
    else
    {
      SetDictTuple(hv_TiledDLResult, "bbox_col", hv_ResCol);
      SetDictTuple(hv_TiledDLResult, "bbox_row", hv_ResRow);
      SetDictTuple(hv_TiledDLResult, "bbox_length1", hv_ResLength1);
      SetDictTuple(hv_TiledDLResult, "bbox_length2", hv_ResLength2);
      SetDictTuple(hv_TiledDLResult, "bbox_phi", hv_ResPhi);
    }
    if (0 != hv_MasksExist)
    {
      SetDictObject(ho_ResInstanceMasks, hv_TiledDLResult, "mask");
    }
  }
  //
  //Set display parameters.
  CreateDict(&hv_DisplayGenParam);
  //Pinch off all text display from dev_display_dl_data for a visualization without clutter.
  SetDictTuple(hv_DisplayGenParam, "display_bottom_desc", 0);
  SetDictTuple(hv_DisplayGenParam, "display_legend", 0);
  SetDictTuple(hv_DisplayGenParam, "display_labels", 0);
  if (0 != (HTuple(int(hv_ModelType==HTuple("detection"))).TupleAnd(int((hv_DLModelHandle.TupleLength())>0))))
  {
    //Don't display directions if 'ignore_direction' is set to 'true'.
    GetDlModelParam(hv_DLModelHandle, "ignore_direction", &hv_IgnoreDirection);
    if (0 != (int(hv_IgnoreDirection==HTuple("true"))))
    {
      SetDictTuple(hv_DisplayGenParam, "display_direction", 0);
    }
  }
  //
  //Initialize the window for displaying the tiled comparison of input and result.
  CreateDict(&hv_WindowHandleDict);
  hv_NoInputWindow = int((hv_WindowHandle.TupleLength())==0);
  if (0 != hv_NoInputWindow)
  {
    GetImageSize(ho_TiledImage, &hv_Width, &hv_Height);
    dev_open_window_fit_size(hv_WindowRow, hv_WindowCol, hv_Width, hv_Height, hv_WindowWidth, 
        hv_WindowHeight, &hv_WindowHandle);
  }
  GetWindowParam(hv_WindowHandle, "flush", &hv_Flush);
  if (0 != (int(hv_Flush==HTuple("true"))))
  {
    SetWindowParam(hv_WindowHandle, "flush", "false");
  }
  SetWindowParam(hv_WindowHandle, "background_color", hv_BackGroundColor);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  (*hv_WindowHandleOut) = hv_WindowHandle;
  //
  if (0 != (int(hv_ModelType==HTuple("classification"))))
  {
    hv_KeyForDisplay = "image";
  }
  else if (0 != (int(hv_ModelType==HTuple("segmentation"))))
  {
    hv_KeyForDisplay = "segmentation_image_result";
  }
  else if (0 != (int(hv_ModelType==HTuple("detection"))))
  {
    hv_KeyForDisplay = "bbox_both";
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    hv_KeyForDisplay = "image";
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    hv_KeyForDisplay = "ocr_detection_both";
  }
  else if (0 != (int(hv_ModelType==HTuple("3d_gripping_point_detection"))))
  {
    hv_KeyForDisplay = "gripping_map";
  }
  //
  SetDictTuple(hv_WindowHandleDict, hv_KeyForDisplay, hv_WindowHandle);
  //
  //Display the tiled image.
  dev_display_dl_data(hv_TiledDLSample, hv_TiledDLResult, hv_DLDataset, hv_KeyForDisplay, 
      hv_DisplayGenParam, hv_WindowHandleDict);
  //
  //For classification and ocr_recognition, display additional text.
  if (0 != (HTuple(int(hv_ModelType==HTuple("classification"))).TupleAnd(hv_IncludeResults)))
  {
    GetImageSize(ho_TiledImage, &hv_Width, &hv_Height);
    {
    HTuple end_val623 = hv_NumSamples-1;
    HTuple step_val623 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val623, step_val623); hv_Index += step_val623)
    {
      hv_GTText = "Ground truth: "+HTuple(hv_ImageLabelIDs[hv_Index]);
      hv_PredictionText = "Prediction: "+HTuple(hv_ResClassIndices[hv_Index]);
      GetStringExtents(hv_WindowHandle, hv_GTText, &hv__, &hv__, &hv_GTWidth, &hv_TextHeight);
      GetStringExtents(hv_WindowHandle, hv_PredictionText, &hv__, &hv__, &hv_PredictionWidth, 
          &hv__);
      //Get ratio between image and window coordinate system.
      GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_WindowWidth, &hv_WindowHeight);
      //Adapt widths of texts to plot it correctly in window coordinate system.
      if (0 != (int((hv_Height/(hv_Width.TupleReal()))>(hv_WindowHeight/(hv_WindowWidth.TupleReal())))))
      {
        hv_WindowImageRatio = 1.0/(hv_WindowHeight/(HTuple(hv_Height[0]).TupleReal()));
      }
      else
      {
        hv_WindowImageRatio = 1.0/(hv_WindowWidth/(HTuple(hv_Width[0]).TupleReal()));
      }
      if (0 != (int(hv_TextImageWidth<(((hv_GTWidth+hv_PredictionWidth)*hv_WindowImageRatio)+30))))
      {
        //Make shorter text.
        hv_GTText = "GT: "+HTuple(hv_ImageLabelIDs[hv_Index]);
        hv_PredictionText = "Pred.: "+HTuple(hv_ResClassIndices[hv_Index]);
        GetStringExtents(hv_WindowHandle, hv_GTText, &hv__, &hv__, &hv_GTWidth, &hv_TextHeight);
        GetStringExtents(hv_WindowHandle, hv_PredictionText, &hv__, &hv__, &hv_PredictionWidth, 
            &hv__);
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_GTText, "image", (HTuple(hv_TextImageRows[hv_Index])+(hv_TextImageHeight/2))-hv_TextHeight, 
            HTuple(hv_TextImageColumns[hv_Index])+10, "white", "box", "false");
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_PredictionText, "image", (HTuple(hv_TextImageRows[hv_Index])+(hv_TextImageHeight/2))-hv_TextHeight, 
            ((HTuple(hv_TextImageColumns[hv_Index])+hv_TextImageWidth)-(hv_PredictionWidth*hv_WindowImageRatio))-10, 
            "white", "box", "false");
    }
    }
  }
  else if (0 != (HTuple(int(hv_ModelType==HTuple("ocr_recognition"))).TupleAnd(hv_IncludeResults)))
  {
    //Get the actual window dimensions.
    hv_WindowWidthMax = hv_WindowWidth;
    hv_WindowHeightMax = hv_WindowHeight;
    GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_WindowWidth, &hv_WindowHeight);
    //If the window was created here increase its size fitting the specified limits and keeping its aspect ratio.
    if (0 != (HTuple(hv_NoInputWindow.TupleAnd(int(hv_WindowWidth<hv_WindowWidthMax))).TupleAnd(int(hv_WindowHeight<hv_WindowHeightMax))))
    {
      hv_Ratio = ((hv_WindowWidthMax.TupleReal())/hv_WindowWidth).TupleMin2((hv_WindowHeightMax.TupleReal())/hv_WindowHeight);
      hv_WindowWidth = (hv_Ratio*hv_WindowWidth).TupleRound();
      hv_WindowHeight = (hv_Ratio*hv_WindowHeight).TupleRound();
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),-1, -1, hv_WindowWidth, hv_WindowHeight);
    }
    //Calculate window/image size ratios.
    GetImageSize(ho_TiledImage, &hv_ImageWidth, &hv_ImageHeight);
    hv_ImageWindowWidthRatio = (hv_ImageWidth.TupleReal())/hv_WindowWidth;
    hv_ImageWindowHeightRatio = (hv_ImageHeight.TupleReal())/hv_WindowHeight;
    //Calculate character image size.
    GetStringExtents(hv_WindowHandle, "H", &hv__, &hv__, &hv_CharWindowWidth, &hv_CharWindowHeight);
    hv_CharImageWidth = hv_CharWindowWidth*hv_ImageWindowWidthRatio;
    hv_CharImageHeight = hv_CharWindowHeight*hv_ImageWindowHeightRatio;
    //Display resulting words.
    {
    HTuple end_val667 = hv_NumSamples-1;
    HTuple step_val667 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val667, step_val667); hv_Index += step_val667)
    {
      hv_ImageRow = ((HTuple(hv_TextImageRows[hv_Index])+(0.5*hv_TextImageHeight))-hv_CharImageHeight)+1;
      hv_ImageColumn = HTuple(hv_TextImageColumns[hv_Index])+(0.5*hv_CharImageWidth);
      hv_String = ("\""+HTuple(hv_ResWords[hv_Index]))+"\"";
      //Reduce string length if it is too long.
      GetStringExtents(hv_WindowHandle, hv_String, &hv__, &hv__, &hv_StringWindowWidth, 
          &hv__);
      hv_StringImageWidth = hv_StringWindowWidth*hv_ImageWindowWidthRatio;
      while (0 != (HTuple(int((hv_String.TupleStrlen())>5)).TupleAnd(int(hv_StringImageWidth>(0.8*hv_TextImageWidth)))))
      {
        hv_String = (hv_String.TupleStrFirstN((hv_String.TupleStrlen())-5))+"...";
        GetStringExtents(hv_WindowHandle, hv_String, &hv__, &hv__, &hv_StringWindowWidth, 
            &hv__);
        hv_StringImageWidth = hv_StringWindowWidth*hv_ImageWindowWidthRatio;
      }
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_String, "image", hv_ImageRow, hv_ImageColumn, 
            "white", "box", "false");
    }
    }
  }
  //
  if (0 != (int(hv_Flush==HTuple("true"))))
  {
    //Only flush the window, if 'flush' is 'true'. Otherwise the caller
    //(who set flush to 'false' on purpose) is responsible for flushing.
    FlushBuffer(hv_WindowHandle);
  }
  SetWindowParam(hv_WindowHandle, "flush", hv_Flush);
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Display the confusion matrix that can be used interactively to display samples. 
void dev_display_dl_interactive_confusion_matrix (HTuple hv_DLDataset, HTuple hv_EvaluationResult, 
    HTuple hv_GenParam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayMatrix, hv_DisplayColor, hv_DisplayColumnWidth;
  HTuple  hv_Font, hv_FontSize, hv_GenParamDevData, hv_GenParamKeysOnlyInteractive;
  HTuple  hv_GenParamKeysCommon, hv_GenParamKeysInteractive;
  HTuple  hv_Index, hv_Exception, hv_DisplayMatrixExists;
  HTuple  hv_DisplayColorExists, hv_DisplayColumnWidthExists;
  HTuple  hv_FontExists, hv_FontSizeExists, hv_ClassNames;
  HTuple  hv_ClassIDs, hv_EvaluatedSamples, hv_ImageIDs, hv_ImageLabelIDs;
  HTuple  hv_Predictions, hv_KeyExists, hv_ConfusionMatrix;
  HTuple  hv_ValuesRelative, hv_NumberFormat, hv_MatrixMaxID;
  HTuple  hv_MaxValue, hv_MaxChars, hv_Str, hv_IsString, hv_Length;
  HTuple  hv_SubStr, hv_ClassIDsToNamesMapping, hv_ValueColors;
  HTuple  hv_DiagonalColor, hv_Seq, hv_DiagonalIndices, hv_WindowHandle;
  HTuple  hv_ColumnNames, hv_RowNames, hv_AxisTitles, hv_NumRows;
  HTuple  hv_NumColumns, hv_AxisColor, hv_BoxColor, hv_HighlightColor;
  HTuple  hv_ColStringWidths, hv_MinStringWidth, hv_MaxStringWidth;
  HTuple  hv_StringHeight, hv_StringIndex, hv__, hv_StringWidth;
  HTuple  hv_StringHeightTmp, hv_TitleHeight, hv_AxisTitleHeight;
  HTuple  hv_AxisTitleWidth, hv_RowStart, hv_RowDistance;
  HTuple  hv_RowEnd, hv_ColumnStart, hv_ColumnOffset, hv_ColumnEnd;
  HTuple  hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit;
  HTuple  hv_TextRow, hv_TextColumn, hv_RowStartTmp, hv_ColumnDistance;
  HTuple  hv_MatrixValues, hv_MatrixText, hv_MatrixTextWidths;
  HTuple  hv_MatrixTextWidth, hv_ButtonHeight, hv_ButtonWidth;
  HTuple  hv_TextToButtonOffset, hv_ZeroIndices, hv_NonZeroIndizes;
  HTuple  hv_ContinueTextWidth, hv_ContinueTextHeight, hv_Row;
  HTuple  hv_Column, hv_WindowWidth, hv_WindowHeight, hv_SelectedButton;
  HTuple  hv_MatrixEntryIndex, hv_GroundTruthClassID, hv_PredictedClassID;
  HTuple  hv_GTIndices, hv_PredictionIndices, hv_ImageIDsSelected;
  HTuple  hv_WindowHandleDict, hv_DisplaySamples, hv_DisplayIndex;
  HTuple  hv_DLSamples, hv_DLSampleIndex, hv_DLSample, hv_DLResult;
  HTuple  hv_WindowHandles, hv_WindowHandleLegend, hv_DataButtonNames;
  HTuple  hv_DataTextRow, hv_DataTextColumn, hv_DataButtonHeight;
  HTuple  hv_DataButtonWidth, hv_DataValueColors, hv_DataBoxColor;
  HTuple  hv_SelectedDataButton;

  //
  //This procedure displays a confusion matrix that can be used interactively to display samples.
  //
  //Set generic parameter defaults.
  hv_DisplayMatrix = "absolute";
  hv_DisplayColor = 1;
  hv_DisplayColumnWidth = "equal";
  hv_Font = "mono";
  hv_FontSize = 14;
  //
  //Handle the generic parameters.
  hv_GenParamDevData = HTuple();
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    //
    //Possible keys for generic parameters of this procedure and common keys with dev_display_dl_data.
    hv_GenParamKeysOnlyInteractive.Clear();
    hv_GenParamKeysOnlyInteractive[0] = "display_matrix";
    hv_GenParamKeysOnlyInteractive[1] = "display_color";
    hv_GenParamKeysOnlyInteractive[2] = "display_column_width";
    hv_GenParamKeysCommon.Clear();
    hv_GenParamKeysCommon[0] = "font";
    hv_GenParamKeysCommon[1] = "font_size";
    hv_GenParamKeysInteractive.Clear();
    hv_GenParamKeysInteractive.Append(hv_GenParamKeysOnlyInteractive);
    hv_GenParamKeysInteractive.Append(hv_GenParamKeysCommon);
    //All other keys are expected to be generic parameters for dev_display_dl_data.
    CopyDict(hv_GenParam, HTuple(), HTuple(), &hv_GenParamDevData);
    {
    HTuple end_val20 = (hv_GenParamKeysOnlyInteractive.TupleLength())-1;
    HTuple step_val20 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val20, step_val20); hv_Index += step_val20)
    {
      try
      {
        RemoveDictKey(hv_GenParamDevData, HTuple(hv_GenParamKeysOnlyInteractive[hv_Index]));
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
      }
    }
    }
    GetDictParam(hv_GenParam, "key_exists", HTuple(hv_GenParamKeysInteractive[0]), 
        &hv_DisplayMatrixExists);
    GetDictParam(hv_GenParam, "key_exists", HTuple(hv_GenParamKeysInteractive[1]), 
        &hv_DisplayColorExists);
    GetDictParam(hv_GenParam, "key_exists", HTuple(hv_GenParamKeysInteractive[2]), 
        &hv_DisplayColumnWidthExists);
    GetDictParam(hv_GenParam, "key_exists", HTuple(hv_GenParamKeysInteractive[3]), 
        &hv_FontExists);
    GetDictParam(hv_GenParam, "key_exists", HTuple(hv_GenParamKeysInteractive[4]), 
        &hv_FontSizeExists);
    //Set display matrix.
    if (0 != hv_DisplayMatrixExists)
    {
      GetDictTuple(hv_GenParam, "display_matrix", &hv_DisplayMatrix);
      if (0 != (HTuple(int((hv_DisplayMatrix.TupleLength())!=1)).TupleOr(int(((HTuple("absolute").Append("relative")).TupleFind(hv_DisplayMatrix))==-1))))
      {
        throw HException("Invalid value for 'display_matrix'");
      }
    }
    //Set display color.
    if (0 != hv_DisplayColorExists)
    {
      GetDictTuple(hv_GenParam, "display_color", &hv_DisplayColor);
      if (0 != (HTuple(int((hv_DisplayColor.TupleLength())!=1)).TupleOr(int(((HTuple("true").Append("false")).TupleFind(hv_DisplayColor))==-1))))
      {
        throw HException("Invalid value for 'display_color'");
      }
      else
      {
        if (0 != (int(hv_DisplayColor==HTuple("true"))))
        {
          hv_DisplayColor = 1;
        }
        else
        {
          hv_DisplayColor = 0;
        }
      }
    }
    //Set display column width.
    if (0 != hv_DisplayColumnWidthExists)
    {
      GetDictTuple(hv_GenParam, "display_column_width", &hv_DisplayColumnWidth);
      if (0 != (HTuple(int((hv_DisplayColumnWidth.TupleLength())!=1)).TupleOr(int(((HTuple("equal").Append("minimal")).TupleFind(hv_DisplayColumnWidth))==-1))))
      {
        throw HException("Invalid value for 'display_column_width'");
      }
    }
    //Set font.
    if (0 != hv_FontExists)
    {
      GetDictTuple(hv_GenParam, "font", &hv_Font);
    }
    //Set font size.
    if (0 != hv_FontSizeExists)
    {
      GetDictTuple(hv_GenParam, "font_size", &hv_FontSize);
      if (0 != (HTuple(int(hv_FontSize<8)).TupleOr(int(hv_FontSize>64))))
      {
        throw HException(HTuple("Key 'font_size' for font size has to be in range of [8,64]"));
      }
    }
  }
  //
  //Get information from DLDataset and EvaluationResult.
  GetDictTuple(hv_DLDataset, "class_names", &hv_ClassNames);
  GetDictTuple(hv_DLDataset, "class_ids", &hv_ClassIDs);
  GetDictTuple(hv_EvaluationResult, "evaluated_samples", &hv_EvaluatedSamples);
  GetDictTuple(hv_EvaluatedSamples, "image_ids", &hv_ImageIDs);
  GetDictTuple(hv_EvaluatedSamples, "image_label_ids", &hv_ImageLabelIDs);
  GetDictTuple(hv_EvaluatedSamples, "top1_predictions", &hv_Predictions);
  //Get or calculate confusion matrix.
  GetDictParam(hv_EvaluationResult, "key_exists", hv_DisplayMatrix+"_confusion_matrix", 
      &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    GetDictTuple(hv_EvaluationResult, hv_DisplayMatrix+"_confusion_matrix", &hv_ConfusionMatrix);
  }
  else
  {
    //Check if all classes are available in the image label IDs.
    if (0 != (int(((hv_ImageLabelIDs.TupleSort()).TupleUniq())!=(hv_ClassIDs.TupleSort()))))
    {
      throw HException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
    }
    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (HTuple("display_matrix").Append("return_matrix")), 
        HTuple("none").TupleConcat(hv_DisplayMatrix), HTuple(), &hv_ConfusionMatrix);
  }
  //
  //Calculate proper number format and convert relative matrix values to percent, if needed.
  if (0 != (int(hv_DisplayMatrix==HTuple("relative"))))
  {
    //To avoid overwriting of the values, copy matrix in place.
    CopyMatrix(hv_ConfusionMatrix, &hv_ConfusionMatrix);
    GetFullMatrix(hv_ConfusionMatrix, &hv_ValuesRelative);
    SetFullMatrix(hv_ConfusionMatrix, 100*hv_ValuesRelative);
    hv_NumberFormat = "3.0f";
  }
  else
  {
    MaxMatrix(hv_ConfusionMatrix, "full", &hv_MatrixMaxID);
    GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
    hv_NumberFormat = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
  }
  //
  //Cut class names for better visualization and get mapping between class IDs and class names.
  if (0 != (int(hv_ClassNames!=HTuple())))
  {
    //Cut class names.
    hv_MaxChars = 14;
    {
    HTuple end_val107 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val107 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val107, step_val107); hv_Index += step_val107)
    {
      hv_Str = HTuple(hv_ClassNames[hv_Index]);
      TupleIsString(hv_Str, &hv_IsString);
      if (0 != hv_IsString)
      {
        TupleStrlen(hv_Str, &hv_Length);
        if (0 != (int(hv_Length>hv_MaxChars)))
        {
          hv_SubStr = (hv_Str.TupleSubstr(0,hv_MaxChars-3))+"...";
          hv_ClassNames[hv_Index] = hv_SubStr;
        }
      }
    }
    }
    //Generate mapping.
    TupleGenConst(hv_ClassIDs.TupleMax(), -1, &hv_ClassIDsToNamesMapping);
    hv_ClassIDsToNamesMapping[hv_ClassIDs] = HTuple::TupleGenSequence(0,(hv_ClassIDs.TupleLength())-1,1);
  }
  //
  //Get color for matrix entries.
  hv_ValueColors = HTuple((hv_ClassIDs.TupleLength())*(hv_ClassIDs.TupleLength()),"white");
  if (0 != hv_DisplayColor)
  {
    //Display off-diagonal values in red.
    hv_ValueColors = HTuple((hv_ClassIDs.TupleLength())*(hv_ClassIDs.TupleLength()),"#ff4500");
    //Display diagonal values in green.
    hv_DiagonalColor = "#00ff00";
    TupleGenSequence(0, (hv_ClassIDs.TupleLength())-1, 1, &hv_Seq);
    hv_DiagonalIndices = ((hv_ClassIDs.TupleLength())*hv_Seq)+hv_Seq;
    hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
  }
  //
  //
  //* Generate and display interactive confusion matrix.
  //
  //Open and set new window.
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  HDevWindowStack::SetActive(hv_WindowHandle);
  // dev_set_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  //
  try
  {
    set_display_font(hv_WindowHandle, hv_FontSize, hv_Font, "false", "false");
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());
    throw HException("No valid font: "+hv_Font);
  }
  //
  hv_ColumnNames = hv_ClassNames;
  hv_RowNames = hv_ClassNames;
  hv_AxisTitles.Clear();
  hv_AxisTitles[0] = "Ground Truth";
  hv_AxisTitles[1] = "Predicted";
  GetSizeMatrix(hv_ConfusionMatrix, &hv_NumRows, &hv_NumColumns);
  hv_AxisColor = "light gray";
  hv_BoxColor = HTuple((hv_ClassNames.TupleLength())*(hv_ClassNames.TupleLength()),"#333333");
  hv_HighlightColor = "#fce9d4";
  //
  //Calculate the width of the name strings.
  hv_ColStringWidths = HTuple();
  hv_MinStringWidth = 1e3;
  hv_MaxStringWidth = 0;
  hv_StringHeight = 0;
  {
  HTuple end_val164 = (hv_ClassNames.TupleLength())-1;
  HTuple step_val164 = 1;
  for (hv_StringIndex=0; hv_StringIndex.Continue(end_val164, step_val164); hv_StringIndex += step_val164)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_ClassNames[hv_StringIndex]), &hv__, 
        &hv__, &hv_StringWidth, &hv_StringHeightTmp);
    hv_ColStringWidths = hv_ColStringWidths.TupleConcat(hv_StringWidth);
    hv_MinStringWidth = hv_MinStringWidth.TupleMin2(hv_StringWidth);
    hv_MaxStringWidth = hv_MaxStringWidth.TupleMax2(hv_StringWidth);
    hv_StringHeight = hv_StringHeight.TupleMax2(hv_StringHeightTmp);
  }
  }
  //The columns should have a minimum width for four characters.
  GetStringExtents(hv_WindowHandle, "test", &hv__, &hv__, &hv_StringWidth, &hv__);
  hv_MaxStringWidth = hv_MaxStringWidth.TupleMax2(hv_StringWidth);
  //
  //Set display parameters, e.g., margin borders, row- and column-offsets.
  hv_TitleHeight = 0;
  hv_AxisTitleHeight = 0;
  GetStringExtents(hv_WindowHandle, hv_AxisTitles, &hv__, &hv__, &hv_AxisTitleWidth, 
      &hv_AxisTitleHeight);
  hv_RowStart = (80+hv_TitleHeight)+hv_AxisTitleHeight;
  hv_RowDistance = hv_StringHeight+10;
  hv_RowEnd = hv_StringHeight*7;
  hv_ColumnStart = 50+hv_MaxStringWidth;
  hv_ColumnOffset = 30;
  hv_ColumnEnd = hv_ColumnOffset;
  //
  //Adapt the window size to fit the confusion matrix.
  if (0 != (int(hv_DisplayColumnWidth==HTuple("minimal"))))
  {
    //Every column of the confusion matrix is as narrow as possible
    //based to the respective string widths.
    hv_Width = (((hv_ColStringWidths.TupleSum())+(hv_ColumnOffset*hv_NumColumns))+hv_ColumnStart)+hv_ColumnEnd;
  }
  else if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
  {
    //Every column of the confusion matrix should have the same width.
    //based on the maximum string width.
    hv_Width = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumColumns)+hv_ColumnStart)+hv_ColumnEnd;
  }
  hv_Height = ((hv_RowDistance*hv_NumRows)+hv_RowStart)+hv_RowEnd;
  //
  //Set reasonable limits for graphics window (adapt if necessary).
  hv_WidthLimit.Clear();
  hv_WidthLimit[0] = 450;
  hv_WidthLimit.Append(hv_Width);
  hv_HeightLimit.Clear();
  hv_HeightLimit[0] = 250;
  hv_HeightLimit.Append(hv_Height);
  dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
  //
  //Calculate row and column coordinates for display of text and buttons.
  hv_TextRow = HTuple();
  hv_TextColumn = HTuple();
  hv_RowStartTmp = 0;
  hv_ColumnDistance.Clear();
  hv_ColumnDistance[0] = 0;
  hv_ColumnDistance.Append(((hv_ColStringWidths.TupleSelectRange(0,hv_NumColumns-2))+hv_ColumnOffset).TupleCumul());
  if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
  {
    hv_ColumnDistance = HTuple::TupleGenSequence(0,hv_NumColumns-1,1)*(hv_MaxStringWidth+hv_ColumnOffset);
  }
  {
  HTuple end_val211 = hv_NumRows-1;
  HTuple step_val211 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val211, step_val211); hv_Index += step_val211)
  {
    hv_TextRow = hv_TextRow.TupleConcat(HTuple(hv_NumColumns,hv_RowStartTmp));
    hv_RowStartTmp += hv_RowDistance;
    hv_TextColumn = hv_TextColumn.TupleConcat(hv_ColumnDistance);
  }
  }
  //Display the confusion matrix with a margin from the top and left.
  hv_TextColumn += hv_ColumnStart;
  hv_TextRow += hv_RowStart;
  //Align the numbers right.
  GetFullMatrix(hv_ConfusionMatrix, &hv_MatrixValues);
  hv_MatrixText = hv_MatrixValues.TupleString(hv_NumberFormat);
  //Calculate button widths and heights.
  hv_MatrixTextWidths = HTuple();
  {
  HTuple end_val224 = (hv_MatrixText.TupleLength())-1;
  HTuple step_val224 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val224, step_val224); hv_Index += step_val224)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_MatrixText[hv_Index]), &hv__, &hv__, 
        &hv_MatrixTextWidth, &hv__);
    hv_MatrixTextWidths = hv_MatrixTextWidths.TupleConcat(hv_MatrixTextWidth);
  }
  }
  hv_ButtonHeight = HTuple(hv_MatrixText.TupleLength(),hv_StringHeight*1.5);
  hv_ButtonWidth = HTuple(hv_MatrixText.TupleLength(),(hv_MinStringWidth.TupleMax2(0.9*hv_MinStringWidth))*1.2);
  //Calculate offset between button and text column coordinates to keep the entries in the matrix aligned.
  hv_TextToButtonOffset = ((HTuple(hv_ButtonWidth[0])/2)+((hv_MatrixTextWidths.TupleMax())/2))-(hv_MatrixTextWidths.TupleMin());
  //
  //Find zero-entries to avoid that they are selectable by a button.
  hv_ZeroIndices = (hv_MatrixValues.TupleEqualElem(0.0)).TupleFind(1);
  hv_NonZeroIndizes = HTuple::TupleGenSequence(0,(hv_MatrixValues.TupleLength())-1,1).TupleDifference(hv_ZeroIndices);
  //
  //Add continue button.
  hv_NonZeroIndizes = hv_NonZeroIndizes.TupleConcat(hv_MatrixText.TupleLength());
  hv_MatrixText = hv_MatrixText.TupleConcat("Continue");
  GetStringExtents(hv_WindowHandle, "Continue", &hv__, &hv__, &hv_ContinueTextWidth, 
      &hv_ContinueTextHeight);
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_WindowWidth, &hv_WindowHeight);
  hv_TextRow = hv_TextRow.TupleConcat((hv_WindowHeight-hv_ContinueTextHeight)-20);
  hv_TextColumn = hv_TextColumn.TupleConcat((hv_WindowWidth-hv_ContinueTextWidth)-40);
  hv_ButtonHeight = hv_ButtonHeight.TupleConcat(hv_ContinueTextHeight*1.5);
  hv_ButtonWidth = hv_ButtonWidth.TupleConcat(hv_ContinueTextWidth*1.2);
  hv_ValueColors = hv_ValueColors.TupleConcat("black");
  hv_BoxColor = hv_BoxColor.TupleConcat("#f28d26");
  //
  //Display values of matrix with buttons.
  hv_DisplayMatrix = 1;
  while (0 != hv_DisplayMatrix)
  {
    //
    //Display axis titles, row, and column names.
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[0]), "window", "top", 
          "right", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[1]), "window", "bottom", 
          "left", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_RowNames, "window", HTuple(hv_TextRow[HTuple::TupleGenSequence(0,hv_NumColumns*(hv_NumRows-1),hv_NumColumns)]), 
          HTuple(hv_NumRows,(HTuple(hv_TextColumn[0])-hv_MaxStringWidth)-hv_ColumnOffset), 
          hv_AxisColor, "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_ColumnNames, "window", HTuple(hv_NumColumns,HTuple(hv_TextRow[0])-hv_RowDistance), 
          hv_TextColumn.TupleSelectRange(0,hv_NumColumns-1), hv_AxisColor, "box", 
          "false");
    //
    //Display matrix entries. Zero-entries are displayed as text, all others as buttons.
    if (0 != (int(hv_ZeroIndices!=-1)))
    {
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),HTuple(hv_MatrixText[hv_ZeroIndices]), 
            "window", HTuple(hv_TextRow[hv_ZeroIndices]), HTuple(hv_TextColumn[hv_ZeroIndices])+hv_TextToButtonOffset, 
            HTuple(hv_ValueColors[hv_ZeroIndices]), "box", "false");
    }
    dev_disp_button(HTuple(hv_MatrixText[hv_NonZeroIndizes]), HTuple(hv_TextRow[hv_NonZeroIndizes]), 
        HTuple(hv_TextColumn[hv_NonZeroIndizes]), HTuple(hv_ButtonWidth[hv_NonZeroIndizes]), 
        HTuple(hv_ButtonHeight[hv_NonZeroIndizes]), HTuple(hv_ValueColors[hv_NonZeroIndizes]), 
        HTuple(hv_BoxColor[hv_NonZeroIndizes]), hv_HighlightColor, hv_WindowHandle, 
        &hv_SelectedButton);
    //
    //Display axis titles, row names, column names, and zero-entries again to update screen.
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[0]), "window", "top", 
          "right", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[1]), "window", "bottom", 
          "left", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_RowNames, "window", HTuple(hv_TextRow[HTuple::TupleGenSequence(0,hv_NumColumns*(hv_NumRows-1),hv_NumColumns)]), 
          HTuple(hv_NumRows,(HTuple(hv_TextColumn[0])-hv_MaxStringWidth)-hv_ColumnOffset), 
          hv_AxisColor, "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_ColumnNames, "window", HTuple(hv_NumColumns,HTuple(hv_TextRow[0])-hv_RowDistance), 
          hv_TextColumn.TupleSelectRange(0,hv_NumColumns-1), hv_AxisColor, "box", 
          "false");
    if (0 != (int(hv_ZeroIndices!=-1)))
    {
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),HTuple(hv_MatrixText[hv_ZeroIndices]), 
            "window", HTuple(hv_TextRow[hv_ZeroIndices]), HTuple(hv_TextColumn[hv_ZeroIndices])+hv_TextToButtonOffset, 
            HTuple(hv_ValueColors[hv_ZeroIndices]), "box", "false");
    }
    //
    if (0 != (int(hv_SelectedButton==((hv_NonZeroIndizes.TupleLength())-1))))
    {
      //Continue-button.
      hv_DisplayMatrix = 0;
      HDevWindowStack::SetActive(hv_WindowHandle);
      if (HDevWindowStack::IsOpen())
        CloseWindow(HDevWindowStack::Pop());
    }
    else
    {
      //Find correct samples and display them.
      hv_MatrixEntryIndex = HTuple(hv_NonZeroIndizes[hv_SelectedButton]);
      hv_GroundTruthClassID = hv_MatrixEntryIndex%(hv_ClassIDs.TupleLength());
      hv_PredictedClassID = hv_MatrixEntryIndex/(hv_ClassIDs.TupleLength());
      hv_GTIndices = (hv_ImageLabelIDs.TupleEqualElem(hv_GroundTruthClassID)).TupleFind(1);
      hv_PredictionIndices = (hv_Predictions.TupleEqualElem(hv_PredictedClassID)).TupleFind(1);
      hv_ImageIDsSelected = HTuple(hv_ImageIDs[hv_GTIndices.TupleIntersection(hv_PredictionIndices)]);
      CreateDict(&hv_WindowHandleDict);
      hv_DisplaySamples = 1;
      hv_DisplayIndex = 0;
      while (0 != hv_DisplaySamples)
      {
        GetDictTuple(hv_DLDataset, "samples", &hv_DLSamples);
        find_dl_samples(hv_DLSamples, "image_id", HTuple(hv_ImageIDsSelected[hv_DisplayIndex]), 
            "match", &hv_DLSampleIndex);
        read_dl_samples(hv_DLDataset, hv_DLSampleIndex, &hv_DLSample);
        //Create temporary DLResult for display.
        CreateDict(&hv_DLResult);
        SetDictTuple(hv_DLResult, "classification_class_ids", hv_PredictedClassID);
        SetDictTuple(hv_DLResult, "classification_class_names", HTuple(hv_ClassNames[HTuple(hv_ClassIDsToNamesMapping[hv_PredictedClassID])]));
        dev_display_dl_data(hv_DLSample, hv_DLResult, hv_DLDataset, "classification_both", 
            hv_GenParamDevData, hv_WindowHandleDict);
        //Display buttons.
        GetDictTuple(hv_WindowHandleDict, "classification_both", &hv_WindowHandles);
        hv_WindowHandleLegend = ((const HTuple&)hv_WindowHandles)[(hv_WindowHandles.TupleLength())-1];
        //
        hv_DataButtonNames.Clear();
        hv_DataButtonNames[0] = "Previous";
        hv_DataButtonNames[1] = "Next";
        hv_DataButtonNames[2] = "Continue";
        GetStringExtents(hv_WindowHandleLegend, "Continue", &hv__, &hv__, &hv_ContinueTextWidth, 
            &hv_ContinueTextHeight);
        GetWindowExtents(hv_WindowHandleLegend, &hv_Row, &hv_Column, &hv_WindowWidth, 
            &hv_WindowHeight);
        hv_DataTextRow = HTuple(3,(hv_WindowHeight-hv_ContinueTextHeight)-20);
        hv_DataTextColumn.Clear();
        hv_DataTextColumn[0] = 20;
        hv_DataTextColumn.Append((hv_WindowWidth-hv_ContinueTextWidth)/2);
        hv_DataTextColumn.Append((hv_WindowWidth-hv_ContinueTextWidth)-20);
        hv_DataButtonHeight = HTuple(3,hv_ContinueTextHeight*1.5);
        hv_DataButtonWidth = HTuple(3,hv_ContinueTextWidth*1.2);
        hv_DataValueColors = HTuple(3,"black");
        hv_DataBoxColor = HTuple(3,"#f28d26");
        //
        dev_disp_button(hv_DataButtonNames, hv_DataTextRow, hv_DataTextColumn, hv_DataButtonWidth, 
            hv_DataButtonHeight, hv_DataValueColors, hv_DataBoxColor, hv_HighlightColor, 
            hv_WindowHandleLegend, &hv_SelectedDataButton);
        if (0 != (int(hv_SelectedDataButton==0)))
        {
          //Previous-button.
          hv_DisplayIndex = (((hv_ImageIDsSelected.TupleLength())+hv_DisplayIndex)-1)%(hv_ImageIDsSelected.TupleLength());
        }
        else if (0 != (int(hv_SelectedDataButton==1)))
        {
          //Next-button.
          hv_DisplayIndex = (hv_DisplayIndex+1)%(hv_ImageIDsSelected.TupleLength());
        }
        else
        {
          //Continue-button.
          hv_DisplaySamples = 0;
          dev_close_window_dict(hv_WindowHandleDict);
        }
      }
    }
  }
  //
  // dev_set_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  //
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: Displays information about invalid dataset samples of a Deep OCR dataset. 
void dev_display_dl_invalid_samples (HTuple hv_DLDataset, HTuple hv_DLModelHandle, 
    HTuple hv_InvalidSamplesIndices, HTuple hv_InvalidSamplesReasons)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_InvalidSamples, hv_ModelType, hv_InvalidType;
  HTuple  hv_KeyToDisplay, hv_InvalidIndicesUnique, hv_InvalidReasonsUnique;
  HTuple  hv_Count, hv_Suffix1, hv_Suffix2, hv_Headline, hv_Content;
  HTuple  hv_Percent, hv_PercentStr, hv_Text, hv_I, hv_Reason;
  HTuple  hv_Indices, hv_Space, hv_Msg, hv_ImageWidth, hv_WindowWidth;
  HTuple  hv_WindowHeight, hv_WindowHandle, hv_WindowDict;
  HTuple  hv_DLPreprocessParam, hv_NumImages, hv_SampleIndex;
  HTuple  hv_InvalidSample, hv_DLSample, hv_ReasonIndices;
  HTuple  hv_TextLocation;

  //This procedure displays invalid Deep OCR samples.
  //
  // dev_close_inspect_ctrl(...); only in hdevelop
  if (0 != (int((hv_InvalidSamplesIndices.TupleLength())==0)))
  {
    return;
  }
  //
  //Determine model type
  GetDlModelParam(hv_DLModelHandle, "type", &hv_ModelType);
  if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    hv_InvalidType = "sample";
    hv_KeyToDisplay = "ocr_recognition_ground_truth";
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    hv_InvalidType = "label";
    hv_KeyToDisplay = "ocr_detection_ground_truth";
  }
  else
  {
    throw HException(("The model type "+hv_ModelType)+" is not supported");
  }
  hv_InvalidIndicesUnique = (hv_InvalidSamplesIndices.TupleSort()).TupleUniq();
  hv_InvalidReasonsUnique = (hv_InvalidSamplesReasons.TupleSort()).TupleUniq();
  //Suffix 's' for plural
  hv_Count = hv_InvalidSamplesIndices.TupleLength();
  if (0 != (int(hv_Count>1)))
  {
    hv_Suffix1 = "s";
    hv_Suffix2 = "";
  }
  else
  {
    hv_Suffix1 = "";
    hv_Suffix2 = "s";
  }
  //
  //Headline
  hv_Headline = (("Invalid training "+hv_InvalidType)+hv_Suffix1)+" found:";
  //
  hv_Content.Clear();
  hv_Content[0] = "";
  hv_Content[1] = "";
  //Determine the percentage of affected samples
  hv_Percent = (100.0*(hv_InvalidIndicesUnique.TupleLength()))/((hv_DLDataset.TupleGetDictTuple("samples")).TupleLength());
  hv_PercentStr = (hv_Percent.TupleString(".2f"))+"%";
  if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    hv_Text = ((HTuple(HTuple(HTuple(hv_InvalidIndicesUnique.TupleLength())+" of ")+((hv_DLDataset.TupleGetDictTuple("samples")).TupleLength()))+" (")+hv_PercentStr)+") samples cannot be used in training.";
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    hv_Text = ((HTuple(HTuple(HTuple(hv_InvalidIndicesUnique.TupleLength())+" of ")+((hv_DLDataset.TupleGetDictTuple("samples")).TupleLength()))+" (")+hv_PercentStr)+") samples contain invalid labels.";
  }
  hv_Content = hv_Content.TupleConcat(hv_Text);
  hv_Content = hv_Content.TupleConcat("");
  //
  hv_Text = "";
  //Determine individual reasons and create info messages
  {
  HTuple end_val47 = (hv_InvalidReasonsUnique.TupleLength())-1;
  HTuple step_val47 = 1;
  for (hv_I=0; hv_I.Continue(end_val47, step_val47); hv_I += step_val47)
  {
    hv_Reason = HTuple(hv_InvalidReasonsUnique[hv_I]);
    TupleFind(hv_InvalidSamplesReasons, hv_Reason, &hv_Indices);
    hv_Count = hv_Indices.TupleLength();
    if (0 != (int(hv_Count>1)))
    {
      hv_Suffix1 = "s";
      hv_Suffix2 = "";
    }
    else
    {
      hv_Suffix1 = "";
      hv_Suffix2 = "s";
    }
    hv_Text = ("\""+hv_Reason)+"\":";
    hv_Space = "    ";
    if (0 != (int(hv_Reason==HTuple("unknown char"))))
    {
      hv_Text = hv_Text.TupleConcat(((((((hv_Space+hv_Count)+" ")+hv_InvalidType)+hv_Suffix1)+" contain")+hv_Suffix2)+" characters that are not part of the alphabet.");
      hv_Text = hv_Text.TupleConcat(hv_Space+"Please check the ground truth or extend the model alphabet.");
    }
    else if (0 != (int(hv_Reason==HTuple("empty word"))))
    {
      if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
      {
        hv_Msg = " an empty string as the ground truth.";
      }
      else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
      {
        hv_Msg = " words with an empty string as the ground truth.";
      }
      hv_Text = hv_Text.TupleConcat(((((((hv_Space+hv_Count)+" ")+hv_InvalidType)+hv_Suffix1)+" contain")+hv_Suffix2)+hv_Msg);
      hv_Text = hv_Text.TupleConcat(hv_Space+"This is not allowed.");
    }
    else if (0 != (int(hv_Reason==HTuple("word too long"))))
    {
      hv_Text = hv_Text.TupleConcat(((((((hv_Space+hv_Count)+" ")+hv_InvalidType)+hv_Suffix1)+" contain")+hv_Suffix2)+" a string that is too long for the given model.");
      GetDlModelParam(hv_DLModelHandle, "image_width", &hv_ImageWidth);
      hv_Text = hv_Text.TupleConcat(((hv_Space+"The given model has an \"image_width\" of ")+hv_ImageWidth)+" pixels. Based on an");
      hv_Text = hv_Text.TupleConcat(hv_Space+"approximate width of ~6 pixels per character the maximum word ");
      hv_Text = hv_Text.TupleConcat(((hv_Space+"length is ")+(hv_ImageWidth/6))+". Consider to increase the \"image_width\" of the model.");
    }
    else
    {
      hv_Text = hv_Text.TupleConcat(((((((hv_Space+hv_Count)+" ")+hv_InvalidType)+hv_Suffix1)+" contain")+hv_Suffix2)+" a label that is marked as invalid");
      hv_Text = hv_Text.TupleConcat(hv_Space+"for an unknown reason. Please check the labeling.");
    }
    hv_Text = hv_Text.TupleConcat("");
    hv_Content = hv_Content.TupleConcat(hv_Text);
  }
  }
  if (0 != (int(hv_ModelType==HTuple("ocr_recognition"))))
  {
    hv_Text = "Training will continue without these invalid samples.";
  }
  else if (0 != (int(hv_ModelType==HTuple("ocr_detection"))))
  {
    hv_Text = "The invalid labels have been preemptively moved to the 'ignore' category\n while reading the dataset.";
  }
  hv_Content = hv_Content.TupleConcat("");
  hv_Content = hv_Content.TupleConcat(hv_Text);
  hv_Text = HTuple("Next, some invalid samples will be shown.");
  hv_Content = hv_Content.TupleConcat("");
  hv_Content = hv_Content.TupleConcat(hv_Text);
  //
  //Open a window
  hv_WindowWidth = 600;
  hv_WindowHeight = 600;
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_WindowWidth,hv_WindowHeight,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //Display text
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Headline, "window", "top", "left", "yellow", 
        "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Content, "window", "top", "left", "white", 
        "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Press F5 to continue", "window", "bottom", 
        "right", "black", HTuple(), HTuple());
  CreateDict(&hv_WindowDict);
  create_dl_preprocess_param_from_model(hv_DLModelHandle, "none", "full_domain", 
      HTuple(), HTuple(), HTuple(), &hv_DLPreprocessParam);
  hv_InvalidSamples = HTuple((hv_DLDataset.TupleGetDictTuple("samples"))[hv_InvalidIndicesUnique]);
  // dev_inspect_ctrl(...); only in hdevelop
  hv_NumImages = hv_InvalidIndicesUnique.TupleLength();
  hv_NumImages = (hv_NumImages.TupleConcat(5)).TupleMin();
  {
  HTuple end_val111 = hv_NumImages-1;
  HTuple step_val111 = 1;
  for (hv_I=0; hv_I.Continue(end_val111, step_val111); hv_I += step_val111)
  {
    hv_SampleIndex = HTuple(hv_InvalidIndicesUnique[hv_I]);
    hv_InvalidSample = HTuple((hv_DLDataset.TupleGetDictTuple("samples"))[hv_SampleIndex]);
    gen_dl_samples(hv_DLDataset, hv_SampleIndex, hv_ModelType, HTuple(), &hv_DLSample);
    preprocess_dl_samples(hv_DLSample, hv_DLPreprocessParam);
    dev_display_dl_data(hv_DLSample, HTuple(), HTuple(), hv_KeyToDisplay, HTuple(), 
        hv_WindowDict);
    if (HDevWindowStack::IsOpen())
      hv_WindowHandle = HDevWindowStack::GetActive();
    hv_ReasonIndices = hv_InvalidSamplesIndices.TupleFind(HTuple(hv_InvalidIndicesUnique[hv_I]));
    hv_Reason = HTuple(hv_InvalidSamplesReasons[hv_ReasonIndices]);
    if (0 != (HTuple(int(hv_I==0)).TupleAnd(int(hv_ModelType==HTuple("ocr_recognition")))))
    {
      HDevWindowStack::SetActive(hv_WindowDict.TupleGetDictTuple("ocr_recognition_ground_truth"));
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),0, hv_WindowWidth+10, -1, -1);
      hv_TextLocation = "top";
    }
    else if (0 != (HTuple(int(hv_I==0)).TupleAnd(int(hv_ModelType==HTuple("ocr_detection")))))
    {
      HDevWindowStack::SetActive(HTuple((hv_WindowDict.TupleGetDictTuple("ocr_detection_ground_truth"))[0]));
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),0, hv_WindowWidth+10, -1, -1);
      HDevWindowStack::SetActive(HTuple((hv_WindowDict.TupleGetDictTuple("ocr_detection_ground_truth"))[1]));
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),0, ((hv_WindowWidth+480)+10)+10, 
            -1, -1);
      hv_TextLocation = "bottom";
    }
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Reason.TupleJoin("\n"), "window", 
          hv_TextLocation, "left", "black", HTuple(), HTuple());
    // stop(...); only in hdevelop
  }
  }
  // dev_close_inspect_ctrl(...); only in hdevelop
  dev_close_window_dict(hv_WindowDict);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display the ground truth anomaly regions of the given DLSample. 
void dev_display_ground_truth_anomaly_regions (HTuple hv_SampleKeys, HTuple hv_DLSample, 
    HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor, 
    HTuple hv_AnomalyColorTransparency, HTuple *hv_AnomalyRegionExists)
{

  // Local iconic variables
  HObject  ho_AnomalyImage, ho_AnomalyRegion;

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Alpha, hv_InitialColor;
  HTuple  hv_IndexColor, hv_Color_RGBA, hv_Area;

  //
  //This procedure visualizes the ground truth anomalies
  //if there is an anomaly_ground_truth in DLSample.
  //
  //Get current set color.
  GetRgba(hv_CurrentWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);
  hv_InitialColor = HTuple();
  {
  HTuple end_val7 = (hv_Red.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_IndexColor=0; hv_IndexColor.Continue(end_val7, step_val7); hv_IndexColor += step_val7)
  {
    hv_Color_RGBA = ((("#"+(HTuple(hv_Red[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Green[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Blue[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Alpha[hv_IndexColor]).TupleString("2x"));
    TupleRegexpReplace(hv_Color_RGBA, (HTuple(" ").Append("replace_all")), "0", &hv_Color_RGBA);
    hv_InitialColor = hv_InitialColor.TupleConcat(hv_Color_RGBA);
  }
  }
  //
  if (0 != (int((hv_SampleKeys.TupleFind("anomaly_ground_truth"))!=-1)))
  {
    GetDictObject(&ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
    Threshold(ho_AnomalyImage, &ho_AnomalyRegion, 1, 255);
    //Get non-empty regions.
    RegionFeatures(ho_AnomalyRegion, "area", &hv_Area);
    if (0 != (int(hv_Area>0)))
    {
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),hv_AnomalyRegionLabelColor+hv_AnomalyColorTransparency);
      //Display the anomaly region.
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"fill");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_AnomalyRegion, HDevWindowStack::GetActive());
    }
    (*hv_AnomalyRegionExists) = "true";
  }
  else
  {
    (*hv_AnomalyRegionExists) = "false";
  }
  //
  //Reset colors.
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_InitialColor);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display the ground truth bounding boxes of DLSample. 
void dev_display_ground_truth_detection (HTuple hv_DLSample, HTuple hv_SampleKeys, 
    HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor, 
    HTuple hv_WindowImageRatio, HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, 
    HTuple hv_WindowHandle, HTuple *hv_BboxIDs)
{

  // Local iconic variables
  HObject  ho_InstanceMask, ho_BboxRectangle, ho_OrientationArrows;
  HObject  ho_RectangleSelected, ho_MaskSelected, ho_ArrowSelected;

  // Local control variables
  HTuple  hv_InstanceType, hv_MaskExists, hv_BboxRow1;
  HTuple  hv_BboxCol1, hv_BboxRow2, hv_BboxCol2, hv_BboxRow;
  HTuple  hv_BboxCol, hv_BboxLength1, hv_BboxLength2, hv_BboxPhi;
  HTuple  hv_BboxLabels, hv_Text, hv_Ascent, hv_Descent, hv__;
  HTuple  hv_TextOffset, hv_LabelRow, hv_LabelCol, hv_ArrowSizeFactorLength;
  HTuple  hv_ArrowSizeFactorHead, hv_MaxLengthArrow, hv_HalfLengthArrow;
  HTuple  hv_ArrowBaseRow, hv_ArrowBaseCol, hv_ArrowHeadRow;
  HTuple  hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ContourStyle;
  HTuple  hv_Style, hv_IndexBbox, hv_ClassID, hv_TextColorClasses;

  //
  //This procedure displays the ground truth bounding boxes and masks (if present) of a DLSample.
  //
  hv_InstanceType = "";
  hv_MaskExists = 0;
  if (0 != (int((hv_SampleKeys.TupleFind("bbox_row1"))!=-1)))
  {
    GetDictTuple(hv_DLSample, "bbox_row1", &hv_BboxRow1);
    GetDictTuple(hv_DLSample, "bbox_col1", &hv_BboxCol1);
    GetDictTuple(hv_DLSample, "bbox_row2", &hv_BboxRow2);
    GetDictTuple(hv_DLSample, "bbox_col2", &hv_BboxCol2);
    hv_InstanceType = "rectangle1";
  }
  else if (0 != (int((hv_SampleKeys.TupleFind("bbox_phi"))!=-1)))
  {
    GetDictTuple(hv_DLSample, "bbox_row", &hv_BboxRow);
    GetDictTuple(hv_DLSample, "bbox_col", &hv_BboxCol);
    GetDictTuple(hv_DLSample, "bbox_length1", &hv_BboxLength1);
    GetDictTuple(hv_DLSample, "bbox_length2", &hv_BboxLength2);
    GetDictTuple(hv_DLSample, "bbox_phi", &hv_BboxPhi);
    hv_InstanceType = "rectangle2";
  }
  else
  {
    throw HException("Ground truth bounding box data could not be found in DLSample.");
  }
  if (0 != (int((hv_SampleKeys.TupleFind("mask"))!=-1)))
  {
    GetDictObject(&ho_InstanceMask, hv_DLSample, "mask");
    hv_MaskExists = 1;
  }
  if (0 != (HTuple(HTuple(int(hv_InstanceType!=HTuple("rectangle1"))).TupleAnd(int(hv_InstanceType!=HTuple("rectangle2")))).TupleAnd(hv_MaskExists.TupleNot())))
  {
    throw HException("Ground truth bounding box or mask data could not be found in DLSample.");
  }
  GetDictTuple(hv_DLSample, "bbox_label_id", &hv_BboxLabels);
  if (0 != (int((hv_BboxLabels.TupleLength())>0)))
  {
    //
    //Get text and text size for correct positioning of label IDs.
    if (0 != hv_ShowLabels)
    {
      hv_Text = hv_BboxLabels;
      GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv__, 
          &hv__);
      hv_TextOffset = (hv_Ascent+hv_Descent)/hv_WindowImageRatio;
    }
    //
    //Generate bounding box XLDs.
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      TupleGenConst(hv_BboxRow1.TupleLength(), 0.0, &hv_BboxPhi);
      GenRectangle2ContourXld(&ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 0.5*(hv_BboxCol1+hv_BboxCol2), 
          hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 0.5*(hv_BboxRow2-hv_BboxRow1));
      if (0 != hv_ShowLabels)
      {
        hv_LabelRow = hv_BboxRow1;
        hv_LabelCol = hv_BboxCol1;
      }
    }
    else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      GenRectangle2ContourXld(&ho_BboxRectangle, hv_BboxRow, hv_BboxCol, hv_BboxPhi, 
          hv_BboxLength1, hv_BboxLength2);
      if (0 != hv_ShowLabels)
      {
        hv_LabelRow = hv_BboxRow-hv_TextOffset;
        hv_LabelCol = hv_BboxCol;
      }
      if (0 != hv_ShowDirection)
      {
        if (0 != (int(hv_ShowDirection==-1)))
        {
          hv_ArrowSizeFactorLength = 0.4;
          hv_ArrowSizeFactorHead = 0.2;
          hv_MaxLengthArrow = 20;
          hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(hv_BboxLength1*hv_ArrowSizeFactorLength);
          hv_ArrowBaseRow = hv_BboxRow-((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()));
          hv_ArrowBaseCol = hv_BboxCol+((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()));
          hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()));
          hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()));
          hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(hv_BboxLength1.TupleMin2(hv_BboxLength2)))*hv_ArrowSizeFactorHead;
        }
        else
        {
          hv_ArrowHeadSize = 20.0;
          hv_ArrowBaseRow = hv_BboxRow;
          hv_ArrowBaseCol = hv_BboxCol;
          hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleSin()));
          hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleCos()));
        }
        gen_arrow_contour_xld(&ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
            hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
      }
    }
    else if (0 != hv_MaskExists)
    {
      if (0 != hv_ShowLabels)
      {
        AreaCenter(ho_InstanceMask, &hv__, &hv_LabelRow, &hv_LabelCol);
      }
    }
    else
    {
      throw HException("Unknown instance_type: "+hv_InstanceType);
    }
    //
    //Collect the ClassIDs of the bounding boxes.
    TupleGenConst(hv_BboxLabels.TupleLength(), 0, &(*hv_BboxIDs));
    //
    //Draw the bounding boxes.
    GetContourStyle(hv_WindowHandle, &hv_ContourStyle);
    if (HDevWindowStack::IsOpen())
      SetContourStyle(HDevWindowStack::GetActive(),"stroke_and_fill");
    GetLineStyle(hv_WindowHandle, &hv_Style);
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),hv_LineWidthBbox);
    {
    HTuple end_val88 = (hv_BboxLabels.TupleLength())-1;
    HTuple step_val88 = 1;
    for (hv_IndexBbox=0; hv_IndexBbox.Continue(end_val88, step_val88); hv_IndexBbox += step_val88)
    {
      SelectObj(ho_BboxRectangle, &ho_RectangleSelected, hv_IndexBbox+1);
      hv_ClassID = hv_ClassIDs.TupleFind(HTuple(hv_BboxLabels[hv_IndexBbox]));
      (*hv_BboxIDs)[hv_IndexBbox] = hv_ClassID;
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),HTuple(hv_BboxColors[hv_ClassID])+"60");
      if (0 != hv_MaskExists)
      {
        if (HDevWindowStack::IsOpen())
          SetDraw(HDevWindowStack::GetActive(),"fill");
        SelectObj(ho_InstanceMask, &ho_MaskSelected, hv_IndexBbox+1);
        if (HDevWindowStack::IsOpen())
          DispObj(ho_MaskSelected, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetContourStyle(HDevWindowStack::GetActive(),"stroke");
      }
      if (0 != (int(hv_InstanceType!=HTuple(""))))
      {
        SelectObj(ho_BboxRectangle, &ho_RectangleSelected, hv_IndexBbox+1);
        if (HDevWindowStack::IsOpen())
          DispObj(ho_RectangleSelected, HDevWindowStack::GetActive());
        if (0 != (HTuple(int(hv_InstanceType==HTuple("rectangle2"))).TupleAnd(hv_ShowDirection)))
        {
          SelectObj(ho_OrientationArrows, &ho_ArrowSelected, hv_IndexBbox+1);
          if (HDevWindowStack::IsOpen())
            SetColor(HDevWindowStack::GetActive(),HTuple(hv_BboxColors[hv_ClassID])+"FF");
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ArrowSelected, HDevWindowStack::GetActive());
          if (HDevWindowStack::IsOpen())
            SetColor(HDevWindowStack::GetActive(),HTuple(hv_BboxColors[hv_ClassID])+"60");
        }
      }
    }
    }
    //
    //Write text to the bounding boxes.
    if (0 != hv_ShowLabels)
    {
      //For better visibility the text is displayed after all bounding boxes are drawn.
      //Select text color.
      if (0 != (int(hv_TextColor==HTuple(""))))
      {
        hv_TextColorClasses = HTuple(hv_BboxColors[(*hv_BboxIDs)]);
      }
      else
      {
        TupleGenConst((*hv_BboxIDs).TupleLength(), hv_TextColor, &hv_TextColorClasses);
      }
      //Display text.
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_BboxLabels, "image", hv_LabelRow, 
            hv_LabelCol, hv_TextColorClasses, ((HTuple("box_color").Append("shadow")).Append("border_radius")), 
            hv_BboxLabelColor.TupleConcat((HTuple("false").Append(0))));
    }
    //
    if (HDevWindowStack::IsOpen())
      SetContourStyle(HDevWindowStack::GetActive(),hv_ContourStyle);
    SetLineStyle(hv_WindowHandle, hv_Style);
  }
  else
  {
    //Do nothing if there are no ground truth bounding boxes.
    (*hv_BboxIDs) = HTuple();
  }
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display a color bar next to an image. 
void dev_display_map_color_bar (HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_MapColorBarWidth, 
    HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_Rectangle;

  // Local control variables
  HTuple  hv_ClipRegion, hv_ColorIndex, hv_RectHeight;
  HTuple  hv_DrawMode, hv_Row, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv__, hv_TextHeight, hv_Index, hv_Text;

  //
  //This procedure displays a color bar next to the image
  //specified with ImageWidth and ImageHeight.
  //
  GetSystem("clip_region", &hv_ClipRegion);
  SetSystem("clip_region", "false");
  //
  //Display the color bar.
  hv_ColorIndex = 0;
  hv_RectHeight = (1.0*hv_ImageHeight)/(hv_Colors.TupleLength());
  //Set draw mode to fill
  GetDraw(hv_WindowHandle, &hv_DrawMode);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"fill");
  {
  HTuple end_val13 = 0;
  HTuple step_val13 = -hv_RectHeight;
  for (hv_Row=hv_ImageHeight-1; hv_Row.Continue(end_val13, step_val13); hv_Row += step_val13)
  {
    //The color bar consists of multiple rectangle1.
    hv_Row1 = hv_Row-hv_RectHeight;
    hv_Column1 = hv_ImageWidth+(20/hv_WindowImageRatio);
    hv_Row2 = hv_Row;
    hv_Column2 = (hv_ImageWidth+20)+(hv_MapColorBarWidth/hv_WindowImageRatio);
    GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),HTuple(hv_Colors[hv_ColorIndex]));
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Rectangle, HDevWindowStack::GetActive());
    hv_ColorIndex += 1;
  }
  }
  //
  //Display labels for color bar.
  GetStringExtents(hv_WindowHandle, "0123456789", &hv__, &hv__, &hv__, &hv_TextHeight);
  for (hv_Index=0; hv_Index<=1; hv_Index+=0.2)
  {
    hv_Text = (hv_MaxValue-(hv_Index*hv_MaxValue)).TupleString(".1f");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Text, "image", hv_Index*(hv_ImageHeight-(2*(hv_TextHeight/hv_WindowImageRatio))), 
          hv_ImageWidth+(40/hv_WindowImageRatio), "black", "box", "false");
  }
  //
  SetSystem("clip_region", hv_ClipRegion);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),hv_DrawMode);
  return;
}

// Chapter: Graphics / Output
// Short Description: Display a matrix inside a window 
void dev_display_matrix (HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames, 
    HTuple hv_WindowHandle, HTuple hv_GenParam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumRows, hv_NumColumns, hv_DisplayColumnWidth;
  HTuple  hv_DisplayColor, hv_IdxsNoDisplay, hv_ValueColors;
  HTuple  hv_NumberFormat, hv_TitleExists, hv_Title, hv_SubtitleExists;
  HTuple  hv_Subtitle, hv_AxisTitlesExists, hv_AxisTitles;
  HTuple  hv_AxisColor, hv_GenParamKeys, hv_GenParamIndex;
  HTuple  hv_ValueTmp, hv_ColStringWidths, hv_AllNames, hv_MaxStringWidth;
  HTuple  hv_StringIndex, hv_String, hv_Ascent, hv_Descent;
  HTuple  hv_StringWidth, hv_StringHeight, hv_RowSeparator;
  HTuple  hv_RowStart, hv_TitleHeight, hv_TitleWidth, hv_SubtitleHeight;
  HTuple  hv_SubtitleWidth, hv_AxisTitleHeight, hv_TitleAscent;
  HTuple  hv_TitleDescent, hv_TitleRowStart, hv_SubtitleAscent;
  HTuple  hv_SubtitleDescent, hv_SubtitleRowStart, hv_AxisTitleAscent;
  HTuple  hv_AxisTitleDescent, hv_AxisTitleWidth, hv_AxisTitleRowStart;
  HTuple  hv_LabelRowStart, hv_RowDistance, hv_RowEnd, hv_ColumnStart;
  HTuple  hv_ColumnOffset, hv_ColumnEnd, hv_Width, hv_Height;
  HTuple  hv_WidthLimit, hv_HeightLimit, hv_TextRow, hv_TextColumn;
  HTuple  hv_RowStartTmp, hv_ColumnDistance, hv_Index, hv_MatrixText;
  HTuple  hv_IdxsDisplay;

  //
  //Display a matrix in a window.
  //
  //GenParam (all are optional):
  //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
  //                          that equals the width of the longest row or column-name.
  //  - display_color:        If true, the values will be displayed with the colors that are given by
  //                          'value_colors'.
  //                          Else, all values are displayed in white.
  //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
  //                          given in row-major order, according to get_full_matrix. If not given or if
  //                          set to an empty tuple, all matrix values are displayed.
  //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
  //                          and bottom-left of the matrix, respectively. Should be a tuple of length
  //                          two or an empty tuple if no axis titles should be displayed.
  //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
  //                          single value is given, this color is used for all values, else it must have
  //                          the length of the number of values in the matrix. Is ignored if
  //                          display_color is false.
  //  - number_format:        Format of the numbers when they are converted to strings for display.
  //                          Default: 2.0f
  //  - title:                Title of the displayed matrix, if given shown in the top-left.
  //  - subtitle:             Subtitle of the displayed matrix, if given shown beyond the title.
  //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
  //
  //
  //Get the matrix dimensions.
  GetSizeMatrix(hv_Matrix, &hv_NumRows, &hv_NumColumns);
  //Set defaults parameters.
  hv_DisplayColumnWidth = "equal";
  hv_DisplayColor = 0;
  hv_IdxsNoDisplay = HTuple();
  hv_ValueColors = HTuple(hv_NumRows*hv_NumColumns,"white");
  hv_NumberFormat = "2.0f";
  hv_TitleExists = 0;
  hv_Title = HTuple();
  hv_SubtitleExists = 0;
  hv_Subtitle = HTuple();
  hv_AxisTitlesExists = 0;
  hv_AxisTitles = HTuple();
  hv_AxisColor = "light gray";
  //Get parameters and overwrite
  //
  hv_GenParamKeys = HTuple();
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamKeys);
  }
  {
  HTuple end_val47 = (hv_GenParamKeys.TupleLength())-1;
  HTuple step_val47 = 1;
  for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val47, step_val47); hv_GenParamIndex += step_val47)
  {
    //DisplayColumnWidth.
    if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("display_column_width"))))
    {
      GetDictTuple(hv_GenParam, "display_column_width", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple("equal").Append("minimal")).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_column_width'");
      }
      else
      {
        hv_DisplayColumnWidth = hv_ValueTmp;
      }
      //DisplayColor.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("display_color"))))
    {
      GetDictTuple(hv_GenParam, "display_color", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_color'");
      }
      else
      {
        hv_DisplayColor = hv_ValueTmp;
      }
      //ValueIdxsNoDisplay.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("idxs_no_display"))))
    {
      GetDictTuple(hv_GenParam, "idxs_no_display", &hv_ValueTmp);
      if (0 != (int((hv_ValueTmp.TupleLength())>0)))
      {
        if (0 != (HTuple(HTuple(HTuple(int((hv_ValueTmp.TupleMin())<0)).TupleOr(int((hv_ValueTmp.TupleMax())>((hv_NumRows*hv_NumColumns)-1)))).TupleOr((hv_ValueTmp.TupleIsInt()).TupleNot())).TupleOr(int((hv_ValueTmp.TupleLength())>(hv_NumRows*hv_NumColumns)))))
        {
          throw HException("Invalid value for 'idxs_no_display'");
        }
        hv_IdxsNoDisplay = hv_ValueTmp;
      }
      //ValueColors.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("value_colors"))))
    {
      if (0 != hv_DisplayColor)
      {
        GetDictTuple(hv_GenParam, "value_colors", &hv_ValueTmp);
        if (0 != (int((hv_ValueTmp.TupleLength())>0)))
        {
          if (0 != (HTuple(HTuple(int((hv_ValueTmp.TupleLength())!=(hv_NumColumns*hv_NumRows))).TupleAnd(int((hv_ValueTmp.TupleLength())!=1))).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
          {
            throw HException("Invalid value for 'value_colors'");
          }
          if (0 != (int((hv_ValueTmp.TupleLength())==1)))
          {
            hv_ValueTmp = HTuple(hv_NumRows*hv_NumColumns,hv_ValueTmp);
          }
          hv_ValueColors = hv_ValueTmp;
        }
      }
      //NumberFormat.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("number_format"))))
    {
      GetDictTuple(hv_GenParam, "number_format", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
      {
        throw HException("Invalid value for 'number_format'");
      }
      else
      {
        hv_NumberFormat = hv_ValueTmp;
      }
      //Title.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("title"))))
    {
      GetDictTuple(hv_GenParam, "title", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
      {
        throw HException("Invalid value for 'title'");
      }
      else
      {
        hv_TitleExists = 1;
        hv_Title = hv_ValueTmp;
      }
      //Subtitle.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("subtitle"))))
    {
      GetDictTuple(hv_GenParam, "subtitle", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
      {
        throw HException("Invalid value for 'subtitle'");
      }
      else
      {
        hv_SubtitleExists = 1;
        hv_Subtitle = hv_ValueTmp;
      }
      //AxisTitles.
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("axis_titles"))))
    {
      GetDictTuple(hv_GenParam, "axis_titles", &hv_ValueTmp);
      if (0 != (int((hv_ValueTmp.TupleLength())>0)))
      {
        if (0 != (HTuple(int((hv_ValueTmp.TupleLength())>2)).TupleOr(int((hv_ValueTmp.TupleIsStringElem())!=HTuple(hv_ValueTmp.TupleLength(),1)))))
        {
          throw HException("Invalid value for 'axis_titles'");
        }
        hv_AxisTitlesExists = 1;
        hv_AxisTitles = hv_ValueTmp;
      }
      //Color for row and column names
    }
    else if (0 != (int(HTuple(hv_GenParamKeys[hv_GenParamIndex])==HTuple("row_col_names_color"))))
    {
      GetDictTuple(hv_GenParam, "row_col_names_color", &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
      {
        throw HException("Invalid value for 'row_col_names_color'");
      }
      else
      {
        hv_AxisColor = hv_ValueTmp;
      }
    }
  }
  }
  //
  //Calculate the width of row and column-name-strings.
  hv_ColStringWidths = HTuple();
  hv_AllNames.Clear();
  hv_AllNames.Append(hv_ColumnNames);
  hv_AllNames.Append(hv_RowNames);
  hv_MaxStringWidth = 0;
  {
  HTuple end_val138 = (hv_AllNames.TupleLength())-1;
  HTuple step_val138 = 1;
  for (hv_StringIndex=0; hv_StringIndex.Continue(end_val138, step_val138); hv_StringIndex += step_val138)
  {
    hv_String = HTuple(hv_AllNames[hv_StringIndex]);
    GetStringExtents(hv_WindowHandle, hv_String, &hv_Ascent, &hv_Descent, &hv_StringWidth, 
        &hv_StringHeight);
    if (0 != (int(hv_StringIndex<(hv_ColumnNames.TupleLength()))))
    {
      hv_ColStringWidths = hv_ColStringWidths.TupleConcat(hv_StringWidth);
    }
    hv_MaxStringWidth = hv_MaxStringWidth.TupleMax2(hv_StringWidth);
  }
  }
  //The columns should have a minimum width for 4 characters.
  GetStringExtents(hv_WindowHandle, "test", &hv_Ascent, &hv_Descent, &hv_StringWidth, 
      &hv_StringHeight);
  //Update the maximum string width.
  hv_MaxStringWidth = hv_MaxStringWidth.TupleMax2(hv_StringWidth);
  //
  //Set parameters for nice display, e.g., distances from window border, row- and column-offsets,
  //axis titles and title.
  //Begin
  //Title
  //Subtitle
  //                   AxisLabel
  //         Class 1     Class n
  //Label 1  a(1,1) ...  a(1,n)
  //                ...
  //Label m  a(m,1) ...  a(m,n)
  //End
  //Thereby entries are vertically separated by RowSeparator
  hv_RowSeparator = 10;
  hv_RowStart = hv_StringHeight+hv_RowSeparator;
  hv_TitleHeight = 0;
  hv_TitleWidth = 0;
  hv_SubtitleHeight = 0;
  hv_SubtitleWidth = 0;
  hv_AxisTitleHeight = 0;
  if (0 != (int((hv_Title.TupleLength())>0)))
  {
    GetStringExtents(hv_WindowHandle, hv_Title, &hv_TitleAscent, &hv_TitleDescent, 
        &hv_TitleWidth, &hv_TitleHeight);
    hv_TitleRowStart = hv_RowStart;
    hv_RowStart = (hv_RowStart+hv_TitleHeight)+hv_RowSeparator;
  }
  if (0 != (int((hv_Subtitle.TupleLength())>0)))
  {
    GetStringExtents(hv_WindowHandle, hv_Subtitle, &hv_SubtitleAscent, &hv_SubtitleDescent, 
        &hv_SubtitleWidth, &hv_SubtitleHeight);
    hv_SubtitleRowStart = hv_RowStart;
    hv_RowStart = (hv_RowStart+hv_SubtitleHeight)+hv_RowSeparator;
  }
  hv_RowStart = (hv_RowStart+hv_StringHeight)+hv_RowSeparator;
  if (0 != (hv_AxisTitles.TupleLength()))
  {
    GetStringExtents(hv_WindowHandle, hv_AxisTitles, &hv_AxisTitleAscent, &hv_AxisTitleDescent, 
        &hv_AxisTitleWidth, &hv_AxisTitleHeight);
    hv_AxisTitleRowStart = hv_RowStart;
    hv_RowStart = (hv_RowStart+hv_AxisTitleHeight)+hv_RowSeparator;
  }
  //Add space for label names
  hv_LabelRowStart = hv_RowStart;
  hv_RowStart = (hv_RowStart+hv_StringHeight)+hv_RowSeparator;
  hv_RowDistance = hv_StringHeight+hv_RowSeparator;
  hv_RowEnd = (hv_StringHeight*2)+(hv_RowSeparator*2);
  hv_ColumnStart = 50+hv_MaxStringWidth;
  hv_ColumnOffset = 30;
  hv_ColumnEnd = hv_ColumnOffset;
  //
  //Adapt the window size to fit the confusion matrix.
  if (0 != (int(hv_DisplayColumnWidth==HTuple("minimal"))))
  {
    //Every column of the confusion matrix is as narrow as possible
    //based to the respective string widths.
    hv_Width = (((hv_ColStringWidths.TupleSum())+(hv_ColumnOffset*hv_NumColumns))+hv_ColumnStart)+hv_ColumnEnd;
  }
  else if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
  {
    //Every column of the confusion matrix should have the same width.
    //based on the maximum string width.
    hv_Width = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumColumns)+hv_ColumnStart)+hv_ColumnEnd;
  }
  //Make sure, window is large enough for the title / subtitle:
  hv_Width = hv_Width.TupleMax2((hv_TitleWidth.TupleMax2(hv_SubtitleWidth))+(2*hv_ColumnOffset));
  hv_Height = ((hv_RowDistance*hv_NumRows)+hv_RowStart)+hv_RowEnd;
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //
  //Set reasonable limits for graphics window (adapt if necessary).
  hv_WidthLimit.Clear();
  hv_WidthLimit[0] = 450;
  hv_WidthLimit.Append(hv_Width);
  hv_HeightLimit.Clear();
  hv_HeightLimit[0] = 250;
  hv_HeightLimit.Append(hv_Height);
  dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
  //
  //Calculate row and column coordinates for display of values.
  hv_TextRow = HTuple();
  hv_TextColumn = HTuple();
  hv_RowStartTmp = 0;
  hv_ColumnDistance.Clear();
  hv_ColumnDistance[0] = 0;
  hv_ColumnDistance.Append(((hv_ColStringWidths.TupleSelectRange(0,hv_NumColumns-2))+hv_ColumnOffset).TupleCumul());
  if (0 != (int(hv_DisplayColumnWidth==HTuple("equal"))))
  {
    hv_ColumnDistance = HTuple::TupleGenSequence(0,hv_NumColumns-1,1)*(hv_MaxStringWidth+hv_ColumnOffset);
  }
  {
  HTuple end_val224 = hv_NumRows-1;
  HTuple step_val224 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val224, step_val224); hv_Index += step_val224)
  {
    hv_TextRow = hv_TextRow.TupleConcat(HTuple(hv_NumColumns,hv_RowStartTmp));
    hv_RowStartTmp += hv_RowDistance;
    hv_TextColumn = hv_TextColumn.TupleConcat(hv_ColumnDistance);
  }
  }
  //Display the confusion matrix with a margin from the top and left.
  hv_TextColumn += hv_ColumnStart;
  hv_TextRow += hv_RowStart;
  //
  //Display title.
  if (0 != (int((hv_Title.TupleLength())>0)))
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Title, "window", hv_TitleRowStart, 
          "left", "white", "box", "false");
  }
  //Display subtitle.
  if (0 != (int((hv_Subtitle.TupleLength())>0)))
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Subtitle, "window", hv_SubtitleRowStart, 
          "left", "white", "box", "false");
  }
  //Display axis.
  if (0 != (int((hv_AxisTitles.TupleLength())>0)))
  {
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[0]), "window", hv_AxisTitleRowStart, 
          "right", "white", "box", "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_AxisTitles[1]), "window", ((hv_TextRow.TupleMax())+hv_StringHeight)+hv_RowSeparator, 
          "left", "white", "box", "false");
  }
  //
  //Display row names.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_RowNames, "window", HTuple(hv_TextRow[HTuple::TupleGenSequence(0,hv_NumColumns*(hv_NumRows-1),hv_NumColumns)]), 
        HTuple(hv_NumRows,(HTuple(hv_TextColumn[0])-hv_MaxStringWidth)-hv_ColumnOffset), 
        hv_AxisColor, "box", "false");
  //
  //Display column names.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_ColumnNames, "window", HTuple(hv_NumColumns,hv_LabelRowStart), 
        hv_TextColumn.TupleSelectRange(0,hv_NumColumns-1), hv_AxisColor, "box", "false");
  //
  //
  //Align the numbers right.
  GetFullMatrix(hv_Matrix, &hv_MatrixText);
  hv_MatrixText = hv_MatrixText.TupleString(hv_NumberFormat);
  //
  //
  //Handle no-display indices.
  hv_IdxsDisplay = HTuple::TupleGenSequence(0,(hv_MatrixText.TupleLength())-1,1).TupleDifference(hv_IdxsNoDisplay);
  //
  //Display confusion matrix.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),HTuple(hv_MatrixText[hv_IdxsDisplay]), 
        "window", HTuple(hv_TextRow[hv_IdxsDisplay]), HTuple(hv_TextColumn[hv_IdxsDisplay]), 
        HTuple(hv_ValueColors[hv_IdxsDisplay]), "box", "false");
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Display the confusion matrix given by ConfusionMatrix. 
void dev_display_pixel_confusion_matrix (HTuple hv_ConfusionMatrix, HTuple hv_ClassNames, 
    HTuple hv_GenParam, HTuple hv_WindowHandles)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayAbsoluteMatrix, hv_DisplayRelativeMatrix;
  HTuple  hv_DisplayColor, hv_DisplayColumnWidth, hv_RowColNameColor;
  HTuple  hv_GenParamKeys, hv_KeyExists, hv_ValueTmp, hv_DisplayColumnWidthTmp;
  HTuple  hv_NumRows, hv_NumColumns, hv_Values, hv_ConfusionMatrixRelative;
  HTuple  hv_C, hv_RowValues, hv_ValueColors, hv_DiagonalColor;
  HTuple  hv_Seq, hv_DiagonalIndices, hv_GenParamDisplay;
  HTuple  hv_MatrixMaxID, hv_MaxValue, hv_NumberFormat, hv_ValuesRelative;

  //
  //This procedure displays the confusion matrix given by ConfusionMatrix.
  //Thereby, the matrix can be displayed with absolute or
  //relative values.
  //
  //Set the default values for generic parameters.
  hv_DisplayAbsoluteMatrix = 1;
  hv_DisplayRelativeMatrix = 0;
  hv_DisplayColor = 1;
  hv_DisplayColumnWidth = "equal";
  hv_RowColNameColor = "light gray";
  //
  //Parse generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "display_color";
    hv_GenParamKeys[1] = "display_relative_matrix";
    hv_GenParamKeys[2] = "display_absolute_matrix";
    hv_GenParamKeys[3] = "display_column_width";
    hv_GenParamKeys[4] = "row_col_names_color";
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //DisplayColor
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[0]), &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_color'");
      }
      else
      {
        hv_DisplayColor = hv_ValueTmp;
      }
    }
    //DisplayRelativeMatrix.
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[1]), &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_relative_matrix'");
      }
      else
      {
        hv_DisplayRelativeMatrix = hv_ValueTmp;
      }
    }
    //DisplayAbsoluteMatrix.
    if (0 != (HTuple(hv_KeyExists[2])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[2]), &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr(int(((HTuple(1).Append(0)).TupleFind(hv_ValueTmp))==-1))))
      {
        throw HException("Invalid value for 'display_absolute_matrix'");
      }
      else
      {
        hv_DisplayAbsoluteMatrix = hv_ValueTmp;
      }
    }
    //DisplayColumnWidth.
    if (0 != (HTuple(hv_KeyExists[3])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[3]), &hv_DisplayColumnWidthTmp);
      if (0 != (HTuple(int((hv_DisplayColumnWidthTmp.TupleLength())!=1)).TupleOr(int(((HTuple("equal").Append("minimal")).TupleFind(hv_DisplayColumnWidthTmp))==-1))))
      {
        throw HException("Invalid value for 'display_column_width'");
      }
      else
      {
        hv_DisplayColumnWidth = hv_DisplayColumnWidthTmp;
      }
    }
    //Color for row and column names.
    if (0 != (HTuple(hv_KeyExists[4])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[4]), &hv_ValueTmp);
      if (0 != (HTuple(int((hv_ValueTmp.TupleLength())!=1)).TupleOr((hv_ValueTmp.TupleIsString()).TupleNot())))
      {
        throw HException("Invalid value for 'row_col_names_color'");
      }
      hv_RowColNameColor = hv_ValueTmp;
    }
  }
  //
  if (0 != (HTuple(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayAbsoluteMatrix)).TupleNot()))
  {
    throw HException("At least one of 'display_absolute_matrix' and 'display_relative_matrix' should be true");
  }
  if (0 != (int((hv_DisplayRelativeMatrix+hv_DisplayAbsoluteMatrix)!=(hv_WindowHandles.TupleLength()))))
  {
    throw HException("Wrong number of WindowHandles");
  }
  //
  //Calculate the confusion matrix with absolute values
  //and the confusion matrix with relative errors.
  GetSizeMatrix(hv_ConfusionMatrix, &hv_NumRows, &hv_NumColumns);
  GetFullMatrix(hv_ConfusionMatrix, &hv_Values);
  //
  if (0 != hv_DisplayRelativeMatrix)
  {
    //Calculate relative matrix for display and in order to set colors correctly.
    CopyMatrix(hv_ConfusionMatrix, &hv_ConfusionMatrixRelative);
    //For each class:
    {
    HTuple end_val78 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val78 = 1;
    for (hv_C=0; hv_C.Continue(end_val78, step_val78); hv_C += step_val78)
    {
      //Get the total number of predictions and calculate the relative values.
      GetValueMatrix(hv_ConfusionMatrix, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
          &hv_RowValues);
      if (0 != (int((hv_RowValues.TupleSum())>0)))
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
            (hv_RowValues.TupleReal())/(hv_RowValues.TupleSum()));
      }
      else
      {
        SetValueMatrix(hv_ConfusionMatrixRelative, HTuple(hv_NumColumns,hv_C), HTuple::TupleGenSequence(0,hv_NumColumns-1,1), 
            hv_RowValues.TupleReal());
      }
    }
    }
  }
  //
  //Set color for displayed confusion matrix.
  hv_ValueColors = HTuple(hv_Values.TupleLength(),"#666666");
  if (0 != hv_DisplayColor)
  {
    //Display off-diagonal values in red.
    hv_ValueColors = HTuple(hv_Values.TupleLength(),"#ff4500");
    //Display diagonal values in green.
    hv_DiagonalColor = "#00ff00";
    TupleGenSequence(0, hv_NumColumns-1, 1, &hv_Seq);
    hv_DiagonalIndices = (hv_NumColumns*hv_Seq)+hv_Seq;
    hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
  }
  //
  //Display the matrix.
  //
  //Create GenParam for matrix display.
  CreateDict(&hv_GenParamDisplay);
  SetDictTuple(hv_GenParamDisplay, "display_column_width", hv_DisplayColumnWidth);
  SetDictTuple(hv_GenParamDisplay, "display_color", hv_DisplayColor);
  SetDictTuple(hv_GenParamDisplay, "axis_titles", (HTuple("Ground truth labels").Append("Predicted classes")));
  SetDictTuple(hv_GenParamDisplay, "value_colors", hv_ValueColors);
  SetDictTuple(hv_GenParamDisplay, "row_col_names_color", hv_RowColNameColor);
  if (0 != hv_DisplayAbsoluteMatrix)
  {
    //Display absolute matrix.
    //Calculate proper number format.
    MaxMatrix(hv_ConfusionMatrix, "full", &hv_MatrixMaxID);
    GetFullMatrix(hv_MatrixMaxID, &hv_MaxValue);
    if (0 != (int(hv_MaxValue>0)))
    {
      hv_NumberFormat = (((hv_MaxValue.TupleLog10()).TupleCeil()).TupleInt())+".0f";
    }
    else
    {
      hv_NumberFormat = "1.0f";
    }
    SetDictTuple(hv_GenParamDisplay, "number_format", hv_NumberFormat);
    //Set title.
    SetDictTuple(hv_GenParamDisplay, "title", HTuple("Pixel confusion matrix, absolute"));
    //Display the matrix.
    dev_display_matrix(hv_ConfusionMatrix, hv_ClassNames, hv_ClassNames, HTuple(hv_WindowHandles[0]), 
        hv_GenParamDisplay);
  }
  //
  if (0 != hv_DisplayRelativeMatrix)
  {
    //Display relative matrix.
    //Convert relative matrix values to percent.
    GetFullMatrix(hv_ConfusionMatrixRelative, &hv_ValuesRelative);
    SetFullMatrix(hv_ConfusionMatrixRelative, 100*hv_ValuesRelative);
    //Set number format.
    hv_NumberFormat = "2.1f";
    SetDictTuple(hv_GenParamDisplay, "number_format", hv_NumberFormat);
    //Set title.
    SetDictTuple(hv_GenParamDisplay, "title", HTuple("Pixel confusion matrix, relative [%]"));
    //Display the matrix.
    dev_display_matrix(hv_ConfusionMatrixRelative, hv_ClassNames, hv_ClassNames, 
        HTuple(hv_WindowHandles[hv_DisplayAbsoluteMatrix]), hv_GenParamDisplay);
  }
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Display the detected anomaly regions. 
void dev_display_result_anomaly_regions (HObject ho_AnomalyRegion, HTuple hv_CurrentWindowHandle, 
    HTuple hv_LineWidth, HTuple hv_AnomalyRegionResultColor)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Alpha, hv_InitialColor;
  HTuple  hv_IndexColor, hv_Color_RGBA, hv_Area;

  //
  //This procedure displays the result anomaly regions.
  //
  //Get current set color.
  GetRgba(hv_CurrentWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);
  hv_InitialColor = HTuple();
  {
  HTuple end_val6 = (hv_Red.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_IndexColor=0; hv_IndexColor.Continue(end_val6, step_val6); hv_IndexColor += step_val6)
  {
    hv_Color_RGBA = ((("#"+(HTuple(hv_Red[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Green[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Blue[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Alpha[hv_IndexColor]).TupleString("2x"));
    TupleRegexpReplace(hv_Color_RGBA, (HTuple(" ").Append("replace_all")), "0", &hv_Color_RGBA);
    hv_InitialColor = hv_InitialColor.TupleConcat(hv_Color_RGBA);
  }
  }
  //
  //Display anomaly regions.
  //Get non-empty regions.
  RegionFeatures(ho_AnomalyRegion, "area", &hv_Area);
  //
  //Display all non-empty class regions in distinct colors.
  if (0 != (int(hv_Area>0)))
  {
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_AnomalyRegionResultColor);
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),hv_LineWidth);
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
      DispObj(ho_AnomalyRegion, HDevWindowStack::GetActive());
  }
  //
  //Reset colors.
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_InitialColor);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display result bounding boxes. 
void dev_display_result_detection (HTuple hv_DLResult, HTuple hv_ResultKeys, HTuple hv_LineWidthBbox, 
    HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors, HTuple hv_BoxLabelColor, 
    HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow, HTuple hv_TextColor, HTuple hv_ShowLabels, 
    HTuple hv_ShowDirection, HTuple hv_WindowHandle, HTuple *hv_BboxClassIndices)
{

  // Local iconic variables
  HObject  ho_InstanceMask, ho_BboxRectangle, ho_OrientationArrows;
  HObject  ho_MaskSelected, ho_RectangleSelected, ho_ArrowSelected;

  // Local control variables
  HTuple  hv_InstanceType, hv_MaskExists, hv_BboxRow1;
  HTuple  hv_BboxCol1, hv_BboxRow2, hv_BboxCol2, hv_BboxRow;
  HTuple  hv_BboxCol, hv_BboxLength1, hv_BboxLength2, hv_BboxPhi;
  HTuple  hv_BboxClasses, hv_Text, hv_Ascent, hv_Descent;
  HTuple  hv__, hv_TextOffset, hv_LabelRowTop, hv_LabelRowBottom;
  HTuple  hv_LabelCol, hv_ArrowSizeFactorLength, hv_ArrowSizeFactorHead;
  HTuple  hv_MaxLengthArrow, hv_HalfLengthArrow, hv_ArrowBaseRow;
  HTuple  hv_ArrowBaseCol, hv_ArrowHeadRow, hv_ArrowHeadCol;
  HTuple  hv_ArrowHeadSize, hv_MaskRow, hv_MaskCol, hv_ContourStyle;
  HTuple  hv_Style, hv_LineWidths, hv_IndexBbox, hv_ClassID;
  HTuple  hv_CurrentColors, hv_IndexStyle, hv_TextColorClasses;
  HTuple  hv_LabelRow;

  //
  //This procedure displays the bounding boxes and masks (if present) defined by a DLResult.
  //The ClassIDs are necessary to display bounding boxes from the same class
  //always with the same color.
  //
  hv_InstanceType = "";
  hv_MaskExists = 0;
  if (0 != (int((hv_ResultKeys.TupleFind("bbox_row1"))!=-1)))
  {
    GetDictTuple(hv_DLResult, "bbox_row1", &hv_BboxRow1);
    GetDictTuple(hv_DLResult, "bbox_col1", &hv_BboxCol1);
    GetDictTuple(hv_DLResult, "bbox_row2", &hv_BboxRow2);
    GetDictTuple(hv_DLResult, "bbox_col2", &hv_BboxCol2);
    hv_InstanceType = "rectangle1";
  }
  else if (0 != (int((hv_ResultKeys.TupleFind("bbox_phi"))!=-1)))
  {
    GetDictTuple(hv_DLResult, "bbox_row", &hv_BboxRow);
    GetDictTuple(hv_DLResult, "bbox_col", &hv_BboxCol);
    GetDictTuple(hv_DLResult, "bbox_length1", &hv_BboxLength1);
    GetDictTuple(hv_DLResult, "bbox_length2", &hv_BboxLength2);
    GetDictTuple(hv_DLResult, "bbox_phi", &hv_BboxPhi);
    GetDictTuple(hv_DLResult, "bbox_class_id", &hv_BboxClasses);
    hv_InstanceType = "rectangle2";
  }
  else
  {
    throw HException("Result bounding box data could not be found in DLResult.");
  }
  if (0 != (int((hv_ResultKeys.TupleFind("mask"))!=-1)))
  {
    GetDictObject(&ho_InstanceMask, hv_DLResult, "mask");
    hv_MaskExists = 1;
  }
  if (0 != (HTuple(HTuple(int(hv_InstanceType!=HTuple("rectangle1"))).TupleAnd(int(hv_InstanceType!=HTuple("rectangle2")))).TupleAnd(hv_MaskExists.TupleNot())))
  {
    throw HException("Result bounding box or mask data could not be found in DLSample.");
  }
  GetDictTuple(hv_DLResult, "bbox_class_id", &hv_BboxClasses);
  if (0 != (int((hv_BboxClasses.TupleLength())>0)))
  {
    //
    //Get text and text size for correct positioning of result class IDs.
    if (0 != hv_ShowLabels)
    {
      hv_Text = hv_BboxClasses+hv_TextConf;
      GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv__, 
          &hv__);
      hv_TextOffset = (hv_Ascent+hv_Descent)/hv_WindowImageRatio;
    }
    //
    //Generate bounding box XLDs.
    if (0 != (int(hv_InstanceType==HTuple("rectangle1"))))
    {
      TupleGenConst(hv_BboxRow1.TupleLength(), 0.0, &hv_BboxPhi);
      GenRectangle2ContourXld(&ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 0.5*(hv_BboxCol1+hv_BboxCol2), 
          hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 0.5*(hv_BboxRow2-hv_BboxRow1));
      if (0 != hv_ShowLabels)
      {
        hv_LabelRowTop = hv_BboxRow1;
        hv_LabelRowBottom = hv_BboxRow2-hv_TextOffset;
        hv_LabelCol = hv_BboxCol1;
      }
    }
    else if (0 != (int(hv_InstanceType==HTuple("rectangle2"))))
    {
      GenRectangle2ContourXld(&ho_BboxRectangle, hv_BboxRow, hv_BboxCol, hv_BboxPhi, 
          hv_BboxLength1, hv_BboxLength2);
      if (0 != hv_ShowLabels)
      {
        hv_LabelRowTop = hv_BboxRow-hv_TextOffset;
        hv_LabelRowBottom = hv_BboxRow;
        hv_LabelCol = hv_BboxCol;
      }
      if (0 != hv_ShowDirection)
      {
        if (0 != (int(hv_ShowDirection==-1)))
        {
          hv_ArrowSizeFactorLength = 0.4;
          hv_ArrowSizeFactorHead = 0.2;
          hv_MaxLengthArrow = 20;
          hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(hv_BboxLength1*hv_ArrowSizeFactorLength);
          hv_ArrowBaseRow = hv_BboxRow-((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()));
          hv_ArrowBaseCol = hv_BboxCol+((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()));
          hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()));
          hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()));
          hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(hv_BboxLength1.TupleMin2(hv_BboxLength2)))*hv_ArrowSizeFactorHead;
        }
        else
        {
          hv_ArrowHeadSize = 20.0;
          hv_ArrowBaseRow = hv_BboxRow;
          hv_ArrowBaseCol = hv_BboxCol;
          hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleSin()));
          hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleCos()));
        }
        gen_arrow_contour_xld(&ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
            hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
      }
    }
    else if (0 != hv_MaskExists)
    {
      AreaCenter(ho_InstanceMask, &hv__, &hv_MaskRow, &hv_MaskCol);
      hv_LabelRowTop = hv_MaskRow-hv_TextOffset;
      hv_LabelRowBottom = hv_MaskRow;
      hv_LabelCol = hv_MaskCol;
    }
    else
    {
      throw HException("Unknown instance_type: "+hv_InstanceType);
    }
    //
    GetContourStyle(hv_WindowHandle, &hv_ContourStyle);
    if (HDevWindowStack::IsOpen())
      SetContourStyle(HDevWindowStack::GetActive(),"stroke");
    GetLineStyle(hv_WindowHandle, &hv_Style);
    hv_LineWidths.Clear();
    hv_LineWidths.Append(hv_LineWidthBbox+2);
    hv_LineWidths.Append(hv_LineWidthBbox);
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),hv_LineWidthBbox);
    //
    //Collect ClassIDs of the bounding boxes.
    TupleGenConst(hv_BboxClasses.TupleLength(), 0, &(*hv_BboxClassIndices));
    //
    //Draw bounding boxes.
    {
    HTuple end_val96 = (hv_BboxClasses.TupleLength())-1;
    HTuple step_val96 = 1;
    for (hv_IndexBbox=0; hv_IndexBbox.Continue(end_val96, step_val96); hv_IndexBbox += step_val96)
    {
      hv_ClassID = hv_ClassIDs.TupleFind(HTuple(hv_BboxClasses[hv_IndexBbox]));
      (*hv_BboxClassIndices)[hv_IndexBbox] = hv_ClassID;
      //First draw in black to make the class-color visible.
      hv_CurrentColors.Clear();
      hv_CurrentColors[0] = "black";
      hv_CurrentColors.Append(HTuple(hv_Colors[hv_ClassID]));
      if (0 != hv_MaskExists)
      {
        SelectObj(ho_InstanceMask, &ho_MaskSelected, hv_IndexBbox+1);
        if (HDevWindowStack::IsOpen())
          SetDraw(HDevWindowStack::GetActive(),"fill");
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),HTuple(hv_Colors[hv_ClassID])+"80");
        if (HDevWindowStack::IsOpen())
          DispObj(ho_MaskSelected, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          SetDraw(HDevWindowStack::GetActive(),"margin");
      }
      {
      HTuple end_val108 = (hv_CurrentColors.TupleLength())-1;
      HTuple step_val108 = 1;
      for (hv_IndexStyle=0; hv_IndexStyle.Continue(end_val108, step_val108); hv_IndexStyle += step_val108)
      {
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),HTuple(hv_CurrentColors[hv_IndexStyle]));
        if (HDevWindowStack::IsOpen())
          SetLineWidth(HDevWindowStack::GetActive(),HTuple(hv_LineWidths[hv_IndexStyle]));
        if (0 != (int(hv_InstanceType!=HTuple(""))))
        {
          SelectObj(ho_BboxRectangle, &ho_RectangleSelected, hv_IndexBbox+1);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_RectangleSelected, HDevWindowStack::GetActive());
          if (0 != (HTuple(int(hv_InstanceType==HTuple("rectangle2"))).TupleAnd(hv_ShowDirection)))
          {
            SelectObj(ho_OrientationArrows, &ho_ArrowSelected, hv_IndexBbox+1);
            if (HDevWindowStack::IsOpen())
              DispObj(ho_ArrowSelected, HDevWindowStack::GetActive());
          }
        }
      }
      }
    }
    }
    //
    //Draw text of bounding boxes.
    if (0 != hv_ShowLabels)
    {
      //For better visibility the text is displayed after all bounding boxes are drawn.
      //Get text and text size for correct positioning of result class IDs.
      hv_Text = hv_BboxClasses+hv_TextConf;
      //Select text color.
      if (0 != (int(hv_TextColor==HTuple(""))))
      {
        hv_TextColorClasses = HTuple(hv_Colors[(*hv_BboxClassIndices)]);
      }
      else
      {
        TupleGenConst((*hv_BboxClassIndices).TupleLength(), hv_TextColor, &hv_TextColorClasses);
      }
      //Select correct position of the text.
      hv_LabelRow = hv_LabelRowTop;
      if (0 != (int(hv_TextPositionRow==HTuple("bottom"))))
      {
        hv_LabelRow = hv_LabelRowBottom;
      }
      //Display text.
      if (HDevWindowStack::IsOpen())
        DispText(HDevWindowStack::GetActive(),hv_Text, "image", hv_LabelRow, hv_LabelCol, 
            hv_TextColorClasses, ((HTuple("box_color").Append("shadow")).Append("border_radius")), 
            hv_BoxLabelColor.TupleConcat((HTuple("false").Append(0))));
    }
    //
    if (HDevWindowStack::IsOpen())
      SetContourStyle(HDevWindowStack::GetActive(),hv_ContourStyle);
    SetLineStyle(hv_WindowHandle, hv_Style);
  }
  else
  {
    //Do nothing if no results are present.
    (*hv_BboxClassIndices) = HTuple();
  }
  //
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Visualize the results of an evaluation for a model of type segmentation. 
void dev_display_segmentation_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
    HTuple hv_GenParam, HTuple hv_WindowHandleDict)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative;
  HTuple  hv_DisplayMeasures, hv_MeasureColor, hv_RowColNameColor;
  HTuple  hv_DisplayColor, hv_GenParamKeys, hv_Keys, hv_KeyIndex;
  HTuple  hv_KeyExists, hv_SupportedModes, hv_Value, hv_ValueIndex;
  HTuple  hv_RGB, hv_Exception, hv_KeysExist, hv_ClassIDs;
  HTuple  hv_ClassNames, hv_MaxChars, hv_Index, hv_Str, hv_IsString;
  HTuple  hv_Length, hv_SubStr, hv_PixelConfMatrix, hv_MeanIoU;
  HTuple  hv_ClassIoU, hv_PixelAccuracy, hv_MeanAccuracy;
  HTuple  hv_ClassPixelAccuracy, hv_MeasureKeys, hv_MeasureKeysExist;
  HTuple  hv_MeasuresDisplayed, hv_GenParamMeasures, hv_NumRows;
  HTuple  hv_RowNames, hv_IdxsNoDisplay, hv_ClassMeasures;
  HTuple  hv_ValidClassIoUs, hv_RowIndex, hv_ValidClassPixelAccuracy;
  HTuple  hv_IdxsNoDisplay1, hv_IdxsNoDisplay2, hv_ColNames;
  HTuple  hv_WindowMeasuresExists, hv_WindowHandleMeasures;
  HTuple  hv_Measures, hv_WindowHandlesConfusion, hv_GenParamConfusion;
  HTuple  hv_WindowConfAbsoluteExists, hv_WindowHandleConfusionAbsolute;
  HTuple  hv_WindowConfRelativeExists, hv_WindowHandleConfusionRelative;
  HTuple  hv_WindowHandleKeys, hv_WindowHandleKeysExist, hv_ColConfusion;
  HTuple  hv_RowConfusion, hv_WidthConf, hv_HeightConf, hv__;
  HTuple  hv_Width, hv_Height, hv_Row, hv_Column;

  //
  //This procedure visualizes the evaluation results for a model of type segmentation.
  //
  //Set the default values.
  hv_DisplayConfusionAbsolute = 0;
  hv_DisplayConfusionRelative = 0;
  hv_DisplayMeasures = 1;
  hv_MeasureColor = "white";
  hv_RowColNameColor = "light gray";
  hv_DisplayColor = 1;
  //
  //Handle the generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    hv_GenParamKeys.Clear();
    hv_GenParamKeys[0] = "display_mode";
    hv_GenParamKeys[1] = "measure_color";
    hv_GenParamKeys[2] = "row_col_names_color";
    hv_GenParamKeys[3] = "display_color_confusion_matrix";
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_Keys);
    {
    HTuple end_val15 = (hv_Keys.TupleLength())-1;
    HTuple step_val15 = 1;
    for (hv_KeyIndex=0; hv_KeyIndex.Continue(end_val15, step_val15); hv_KeyIndex += step_val15)
    {
      if (0 != (int((hv_GenParamKeys.TupleFind(HTuple(hv_Keys[hv_KeyIndex])))==-1)))
      {
        throw HException(("Invalid GenParam key '"+HTuple(hv_Keys[hv_KeyIndex]))+"'");
      }
    }
    }
    GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, &hv_KeyExists);
    //Set display mode.
    if (0 != (HTuple(hv_KeyExists[0])))
    {
      hv_SupportedModes.Clear();
      hv_SupportedModes[0] = "absolute_confusion_matrix";
      hv_SupportedModes[1] = "relative_confusion_matrix";
      hv_SupportedModes[2] = "measures";
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[0]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())==0)))
      {
        throw HException("GenParam key 'display_mode' cannot be an empty tuple");
      }
      hv_DisplayConfusionAbsolute = 0;
      hv_DisplayConfusionRelative = 0;
      hv_DisplayMeasures = 0;
      {
      HTuple end_val31 = (hv_Value.TupleLength())-1;
      HTuple step_val31 = 1;
      for (hv_ValueIndex=0; hv_ValueIndex.Continue(end_val31, step_val31); hv_ValueIndex += step_val31)
      {
        if (0 != (int(HTuple(hv_Value[hv_ValueIndex])==HTuple(hv_SupportedModes[0]))))
        {
          hv_DisplayConfusionAbsolute = 1;
        }
        else if (0 != (int(HTuple(hv_Value[hv_ValueIndex])==HTuple(hv_SupportedModes[1]))))
        {
          hv_DisplayConfusionRelative = 1;
        }
        else if (0 != (int(HTuple(hv_Value[hv_ValueIndex])==HTuple(hv_SupportedModes[2]))))
        {
          hv_DisplayMeasures = 1;
        }
        else
        {
          throw HException("Invalid value for GenParam key 'display_mode'");
        }
      }
      }
    }
    //Set MeasureColor.
    if (0 != (HTuple(hv_KeyExists[1])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[1]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'measure_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'measure_color' must be a valid color string");
      }
      hv_MeasureColor = hv_Value;
    }
    //Set color for row and column names.
    if (0 != (HTuple(hv_KeyExists[2])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[2]), &hv_Value);
      if (0 != (int((hv_Value.TupleLength())!=1)))
      {
        throw HException("GenParam 'row_col_names_color' must be a single value");
      }
      try
      {
        color_string_to_rgb(hv_Value, &hv_RGB);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("GenParam 'row_col_names_color' must be a valid color string");
      }
      hv_RowColNameColor = hv_Value;
    }
    //Set DisplayColor.
    if (0 != (HTuple(hv_KeyExists[3])))
    {
      GetDictTuple(hv_GenParam, HTuple(hv_GenParamKeys[3]), &hv_Value);
      if (0 != (HTuple(int(hv_Value!=1)).TupleAnd(int(hv_Value!=0))))
      {
        throw HException("GenParam 'display_color_confusion_matrix' should be either true or false");
      }
      hv_DisplayColor = hv_Value;
    }
  }
  //
  //Get the class names.
  GetDictParam(hv_EvalParam, "key_exists", (HTuple("class_names").Append("class_ids")), 
      &hv_KeysExist);
  if (0 != ((hv_KeysExist.TupleSum()).TupleNot()))
  {
    throw HException("EvalParam must contain at least one of the keys 'class_names' or 'class_ids'");
  }
  else if (0 != (HTuple(hv_KeysExist[0]).TupleNot()))
  {
    //If class names are not given, use class IDs instead.
    GetDictTuple(hv_EvalParam, "class_ids", &hv_ClassIDs);
    hv_ClassNames = "class_"+hv_ClassIDs;
  }
  else
  {
    //Get the class names from the EvalParam dict.
    GetDictTuple(hv_EvalParam, "class_names", &hv_ClassNames);
  }
  //
  //Cut class names for better visualization.
  if (0 != (int(hv_ClassNames!=HTuple())))
  {
    hv_MaxChars = 14;
    {
    HTuple end_val95 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val95 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val95, step_val95); hv_Index += step_val95)
    {
      hv_Str = HTuple(hv_ClassNames[hv_Index]);
      TupleIsString(hv_Str, &hv_IsString);
      if (0 != hv_IsString)
      {
        TupleStrlen(hv_Str, &hv_Length);
        if (0 != (int(hv_Length>hv_MaxChars)))
        {
          hv_SubStr = (hv_Str.TupleSubstr(0,hv_MaxChars-3))+"...";
          hv_ClassNames[hv_Index] = hv_SubStr;
        }
      }
    }
    }
  }
  //
  //Get the evaluation results.
  //Initialize the result variables.
  hv_PixelConfMatrix = HTuple();
  hv_MeanIoU = HTuple();
  hv_ClassIoU = HTuple();
  hv_PixelAccuracy = HTuple();
  hv_MeanAccuracy = HTuple();
  hv_ClassPixelAccuracy = HTuple();
  //
  //Get some evaluation parameters.
  hv_MeasureKeys.Clear();
  hv_MeasureKeys[0] = "pixel_confusion_matrix";
  hv_MeasureKeys[1] = "mean_iou";
  hv_MeasureKeys[2] = "class_iou";
  hv_MeasureKeys[3] = "pixel_accuracy";
  hv_MeasureKeys[4] = "mean_accuracy";
  hv_MeasureKeys[5] = "class_pixel_accuracy";
  GetDictParam(hv_EvaluationResult, "key_exists", hv_MeasureKeys, &hv_MeasureKeysExist);
  //
  //Check the input evaluation results for necessary entries.
  if (0 != (int((hv_MeasureKeysExist.TupleSum())==0)))
  {
    throw HException("There are no valid keys given in EvaluationResult.");
  }
  if (0 != (HTuple(int(((hv_MeasureKeysExist.TupleSum())-HTuple(hv_MeasureKeysExist[0]))==0)).TupleAnd(hv_DisplayMeasures)))
  {
    throw HException("There are no measures given in EvaluationResult");
  }
  //
  //Pixel confusion matrix.
  if (0 != (HTuple(hv_MeasureKeysExist[0])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[0]), &hv_PixelConfMatrix);
  }
  else
  {
    if (0 != (hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)))
    {
      throw HException("'pixel_confusion_matrix' has to be set as measure in evaluation for this visualization");
    }
  }
  //Mean IoU.
  if (0 != (HTuple(hv_MeasureKeysExist[1])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[1]), &hv_MeanIoU);
  }
  //Class IoU.
  if (0 != (HTuple(hv_MeasureKeysExist[2])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[2]), &hv_ClassIoU);
  }
  //Pixel accuracy.
  if (0 != (HTuple(hv_MeasureKeysExist[3])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[3]), &hv_PixelAccuracy);
  }
  //Mean accuracy.
  if (0 != (HTuple(hv_MeasureKeysExist[4])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[4]), &hv_MeanAccuracy);
  }
  //Class pixel accuracy.
  if (0 != (HTuple(hv_MeasureKeysExist[5])))
  {
    GetDictTuple(hv_EvaluationResult, HTuple(hv_MeasureKeys[5]), &hv_ClassPixelAccuracy);
  }
  //
  //
  hv_MeasuresDisplayed = 0;
  //
  //Set parameters for the visualization of measures.
  if (0 != hv_DisplayMeasures)
  {
    CreateDict(&hv_GenParamMeasures);
    SetDictTuple(hv_GenParamMeasures, "title", "Measures");
    SetDictTuple(hv_GenParamMeasures, "number_format", "0.3f");
    SetDictTuple(hv_GenParamMeasures, "display_column_width", "minimal");
    SetDictTuple(hv_GenParamMeasures, "value_colors", hv_MeasureColor);
    SetDictTuple(hv_GenParamMeasures, "display_color", 1);
    SetDictTuple(hv_GenParamMeasures, "row_col_names_color", hv_RowColNameColor);
    //
    //Visualize class measures.
    if (0 != (HTuple(int(hv_ClassIoU!=HTuple())).TupleOr(int(hv_ClassPixelAccuracy!=HTuple()))))
    {
      //Create matrix.
      hv_NumRows = ((int(hv_ClassIoU!=HTuple()))+(int(hv_ClassPixelAccuracy!=HTuple())))+(2*(int(hv_PixelAccuracy!=HTuple())));
      hv_RowNames = HTuple();
      hv_IdxsNoDisplay = HTuple();
      CreateMatrix(hv_NumRows, (hv_ClassNames.TupleLength())+1, 0., &hv_ClassMeasures);
      if (0 != (int(hv_ClassIoU!=HTuple())))
      {
        //Add row for class IoU.
        SetValueMatrix(hv_ClassMeasures, HTuple(hv_ClassNames.TupleLength(),0), HTuple::TupleGenSequence(0,(hv_ClassNames.TupleLength())-1,1), 
            hv_ClassIoU);
        hv_ValidClassIoUs = HTuple(hv_ClassIoU[(hv_ClassIoU.TupleGreaterElem(-1)).TupleFind(1)]);
        SetValueMatrix(hv_ClassMeasures, 0, hv_ClassNames.TupleLength(), hv_ValidClassIoUs.TupleMean());
        hv_RowNames = hv_RowNames.TupleConcat("IoU");
      }
      if (0 != (int(hv_ClassPixelAccuracy!=HTuple())))
      {
        //Add row for class pixel accuracy.
        hv_RowIndex = int(hv_ClassIoU!=HTuple());
        SetValueMatrix(hv_ClassMeasures, HTuple(hv_ClassNames.TupleLength(),hv_RowIndex), 
            HTuple::TupleGenSequence(0,(hv_ClassNames.TupleLength())-1,1), hv_ClassPixelAccuracy);
        hv_ValidClassPixelAccuracy = HTuple(hv_ClassPixelAccuracy[(hv_ClassPixelAccuracy.TupleGreaterElem(-1)).TupleFind(1)]);
        SetValueMatrix(hv_ClassMeasures, hv_RowIndex, hv_ClassNames.TupleLength(), 
            hv_ValidClassPixelAccuracy.TupleMean());
        hv_RowNames = hv_RowNames.TupleConcat("Pixel Acc.");
      }
      if (0 != (int(hv_PixelAccuracy!=HTuple())))
      {
        //Add row for overall pixel accuracy.
        hv_RowIndex = (int(hv_ClassIoU!=HTuple()))+(int(hv_ClassPixelAccuracy!=HTuple()));
        SetValueMatrix(hv_ClassMeasures, hv_RowIndex+1, 0, hv_PixelAccuracy);
        hv_RowNames = hv_RowNames.TupleConcat((HTuple("").Append("Pixel Acc. (overall)")));
        hv_IdxsNoDisplay1 = HTuple::TupleGenSequence(hv_RowIndex*((hv_ClassNames.TupleLength())+1),((hv_RowIndex+1)*((hv_ClassNames.TupleLength())+1))-1,1);
        hv_IdxsNoDisplay2 = HTuple::TupleGenSequence(((hv_RowIndex+1)*((hv_ClassNames.TupleLength())+1))+1,((hv_RowIndex+2)*((hv_ClassNames.TupleLength())+1))-1,1);
        hv_IdxsNoDisplay = (hv_IdxsNoDisplay.TupleConcat(hv_IdxsNoDisplay1)).TupleConcat(hv_IdxsNoDisplay2);
      }
      //Add GenParamMeasures parameter for displaying the matrix.
      SetDictTuple(hv_GenParamMeasures, "idxs_no_display", hv_IdxsNoDisplay);
      //Add 'mean' to column names.
      hv_ColNames.Clear();
      hv_ColNames.Append(hv_ClassNames);
      hv_ColNames.Append("mean");
      //
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", &hv_WindowMeasuresExists);
      if (0 != hv_WindowMeasuresExists)
      {
        GetDictTuple(hv_WindowHandleDict, "window_measures", &hv_WindowHandleMeasures);
        HDevWindowStack::SetActive(hv_WindowHandleMeasures);
      }
      else
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleMeasures);
        HDevWindowStack::Push(hv_WindowHandleMeasures);
        SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
      }
      //
      //Display.
      dev_display_matrix(hv_ClassMeasures, hv_ColNames, hv_RowNames, hv_WindowHandleMeasures, 
          hv_GenParamMeasures);
      //
      hv_MeasuresDisplayed = 1;
    }
    //
    //Visualize mean measures.
    if (0 != (HTuple(hv_MeasuresDisplayed.TupleNot()).TupleAnd(HTuple(HTuple(int(hv_MeanIoU!=HTuple())).TupleOr(int(hv_PixelAccuracy!=HTuple()))).TupleOr(int(hv_MeanAccuracy!=HTuple())))))
    {
      //Create matrix.
      hv_NumRows = ((int(hv_MeanIoU!=HTuple()))+(int(hv_PixelAccuracy!=HTuple())))+(int(hv_MeanAccuracy!=HTuple()));
      hv_RowNames = HTuple();
      CreateMatrix(hv_NumRows, 1, 0., &hv_Measures);
      if (0 != (int(hv_MeanIoU!=HTuple())))
      {
        SetValueMatrix(hv_Measures, 0, 0, hv_MeanIoU);
        hv_RowNames = hv_RowNames.TupleConcat("Mean IoU");
      }
      if (0 != (int(hv_MeanAccuracy!=HTuple())))
      {
        hv_RowIndex = int(hv_MeanIoU!=HTuple());
        SetValueMatrix(hv_Measures, hv_RowIndex, 0, hv_MeanAccuracy);
        hv_RowNames = hv_RowNames.TupleConcat("Mean Class Pixel Acc.");
      }
      if (0 != (int(hv_PixelAccuracy!=HTuple())))
      {
        hv_RowIndex = (int(hv_MeanIoU!=HTuple()))+(int(hv_MeanAccuracy!=HTuple()));
        SetValueMatrix(hv_Measures, hv_RowIndex, 0, hv_PixelAccuracy);
        hv_RowNames = hv_RowNames.TupleConcat("Pixel Acc. (overall)");
      }
      //
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", &hv_WindowMeasuresExists);
      if (0 != hv_WindowMeasuresExists)
      {
        GetDictTuple(hv_WindowHandleDict, "window_measures", &hv_WindowHandleMeasures);
        HDevWindowStack::SetActive(hv_WindowHandleMeasures);
      }
      else
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleMeasures);
        HDevWindowStack::Push(hv_WindowHandleMeasures);
        SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
      }
      //
      //Display.
      dev_display_matrix(hv_Measures, "", hv_RowNames, hv_WindowHandleMeasures, hv_GenParamMeasures);
      //
      hv_MeasuresDisplayed = 1;
    }
    //
  }
  //
  //Visualize the pixel confusion matrix.
  if (0 != (hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)))
  {
    //Collect the window handles.
    hv_WindowHandlesConfusion = HTuple();
    //Set the display parameters.
    CreateDict(&hv_GenParamConfusion);
    SetDictTuple(hv_GenParamConfusion, "display_relative_matrix", hv_DisplayConfusionRelative);
    SetDictTuple(hv_GenParamConfusion, "display_absolute_matrix", hv_DisplayConfusionAbsolute);
    SetDictTuple(hv_GenParamConfusion, "display_color", hv_DisplayColor);
    SetDictTuple(hv_GenParamConfusion, "row_col_names_color", hv_RowColNameColor);
    if (0 != hv_DisplayConfusionAbsolute)
    {
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_confusion_absolute", 
          &hv_WindowConfAbsoluteExists);
      if (0 != hv_WindowConfAbsoluteExists)
      {
        GetDictTuple(hv_WindowHandleDict, "window_confusion_absolute", &hv_WindowHandleConfusionAbsolute);
        HDevWindowStack::SetActive(hv_WindowHandleConfusionAbsolute);
      }
      else
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleConfusionAbsolute);
        HDevWindowStack::Push(hv_WindowHandleConfusionAbsolute);
        SetDictTuple(hv_WindowHandleDict, "window_confusion_absolute", hv_WindowHandleConfusionAbsolute);
      }
      hv_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(hv_WindowHandleConfusionAbsolute);
    }
    if (0 != hv_DisplayConfusionRelative)
    {
      //Check if there is already a window handle.
      GetDictParam(hv_WindowHandleDict, "key_exists", "window_confusion_relative", 
          &hv_WindowConfRelativeExists);
      if (0 != hv_WindowConfRelativeExists)
      {
        GetDictTuple(hv_WindowHandleDict, "window_confusion_relative", &hv_WindowHandleConfusionRelative);
        HDevWindowStack::SetActive(hv_WindowHandleConfusionRelative);
      }
      else
      {
        SetWindowAttr("background_color","black");
        OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandleConfusionRelative);
        HDevWindowStack::Push(hv_WindowHandleConfusionRelative);
        SetDictTuple(hv_WindowHandleDict, "window_confusion_relative", hv_WindowHandleConfusionRelative);
      }
      hv_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(hv_WindowHandleConfusionRelative);
    }
    hv_ColNames = hv_ClassNames;
    dev_display_pixel_confusion_matrix(hv_PixelConfMatrix, hv_ColNames, hv_GenParamConfusion, 
        hv_WindowHandlesConfusion);
  }
  //
  //Rearrange windows.
  hv_WindowHandleKeys.Clear();
  hv_WindowHandleKeys[0] = "window_measures";
  hv_WindowHandleKeys[1] = "window_confusion_absolute";
  hv_WindowHandleKeys[2] = "window_confusion_relative";
  GetDictParam(hv_WindowHandleDict, "key_exists", hv_WindowHandleKeys, &hv_WindowHandleKeysExist);
  if (0 != (int((hv_WindowHandleKeysExist.TupleSum())>1)))
  {
    hv_ColConfusion.Clear();
    hv_ColConfusion[0] = 0;
    hv_ColConfusion[1] = 0;
    hv_RowConfusion.Clear();
    hv_RowConfusion[0] = 0;
    hv_RowConfusion[1] = 0;
    hv_WidthConf = -1;
    hv_HeightConf = -1;
    if (0 != hv_MeasuresDisplayed)
    {
      GetWindowExtents(hv_WindowHandleMeasures, &hv__, &hv__, &hv_Width, &hv_Height);
      hv_RowConfusion.Clear();
      hv_RowConfusion.Append(hv_Height+55);
      hv_RowConfusion.Append(hv_Height+55);
    }
    if (0 != hv_DisplayConfusionAbsolute)
    {
      GetWindowExtents(hv_WindowHandleConfusionAbsolute, &hv_Row, &hv_Column, &hv_WidthConf, 
          &hv_HeightConf);
      HDevWindowStack::SetActive(hv_WindowHandleConfusionAbsolute);
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),HTuple(hv_RowConfusion[0]), 
            HTuple(hv_ColConfusion[0]), hv_WidthConf, hv_HeightConf);
      // dev_get_preferences(...); only in hdevelop
      hv_ColConfusion[1] = hv_WidthConf+8;
    }
    if (0 != hv_DisplayConfusionRelative)
    {
      HDevWindowStack::SetActive(hv_WindowHandleConfusionRelative);
      if (HDevWindowStack::IsOpen())
        SetWindowExtents(HDevWindowStack::GetActive(),HTuple(hv_RowConfusion[1]), 
            HTuple(hv_ColConfusion[1]), hv_WidthConf, hv_HeightConf);
    }
  }
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Display the ground truth/result segmentation as regions. 
void dev_display_segmentation_regions (HObject ho_SegmentationImage, HTuple hv_ClassIDs, 
    HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, HTuple *hv_ImageClassIDs)
{

  // Local iconic variables
  HObject  ho_Regions, ho_SelectedRegion;

  // Local control variables
  HTuple  hv_IncludedClassIDs, hv_Area, hv_Index;
  HTuple  hv_ClassID, hv_IndexColor;

  //
  //This procedure displays the ground truth/result segmentation
  //given in SegmentationImage as regions. The ClassIDs are necessary to
  //display ground truth/result segmentations from the same class
  //always with the same color. It is possible to exclude certain ClassIDs
  //from being displayed. The displayed classes are returned in ImageClassIDs.
  //
  //
  //Remove excluded class IDs from the list.
  hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(hv_ExcludeClassIDs);
  //
  //Get a region for each class ID.
  Threshold(ho_SegmentationImage, &ho_Regions, hv_IncludedClassIDs, hv_IncludedClassIDs);
  //
  //Get classes with non-empty regions.
  RegionFeatures(ho_Regions, "area", &hv_Area);
  if (0 != (int((hv_Area.TupleLength())!=(hv_IncludedClassIDs.TupleLength()))))
  {
    throw HException("No equal number of class IDs and segmentation regions.");
  }
  TupleSelectMask(hv_IncludedClassIDs, hv_Area.TupleGreaterElem(0), &(*hv_ImageClassIDs));
  //
  //Display all non-empty class regions in distinct colors.
  {
  HTuple end_val22 = (hv_IncludedClassIDs.TupleLength())-1;
  HTuple step_val22 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val22, step_val22); hv_Index += step_val22)
  {
    if (0 != (int(HTuple(hv_Area[hv_Index])>0)))
    {
      //Use class ID to determine region color.
      hv_ClassID = HTuple(hv_IncludedClassIDs[hv_Index]);
      hv_IndexColor = hv_ClassIDs.TupleFindFirst(hv_ClassID);
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),HTuple(hv_ColorsSegmentation[hv_IndexColor]));
      //Display the segmentation region.
      SelectObj(ho_Regions, &ho_SelectedRegion, hv_Index+1);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_SelectedRegion, HDevWindowStack::GetActive());
    }
  }
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Display a map of weights. 
void dev_display_weight_regions (HObject ho_ImageWeight, HTuple hv_DrawTransparency, 
    HTuple hv_SegMaxWeight, HTuple *hv_Colors)
{

  // Local iconic variables
  HObject  ho_Domain, ho_WeightsRegion;

  // Local control variables
  HTuple  hv_NumColors, hv_WeightsColorsAlpha, hv_Rows;
  HTuple  hv_Columns, hv_GrayVal, hv_GrayValWeight, hv_ColorIndex;
  HTuple  hv_ClassColor;

  //
  //This procedure displays a map of the weights
  //given in ImageWeight as regions.
  //The transparency can be adjusted.
  //The used colors are returned.
  //
  //Define colors.
  hv_NumColors = 20;
  get_distinct_colors(hv_NumColors, 0, 0, 160, &(*hv_Colors));
  TupleInverse((*hv_Colors), &(*hv_Colors));
  hv_WeightsColorsAlpha = (*hv_Colors)+hv_DrawTransparency;
  //
  //Get gay values of ImageWeight.
  GetDomain(ho_ImageWeight, &ho_Domain);
  GetRegionPoints(ho_Domain, &hv_Rows, &hv_Columns);
  GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, &hv_GrayVal);
  //
  //Check that the gray values of the image
  //are below the specified maximum.
  if (0 != (int((hv_GrayVal.TupleMax())>hv_SegMaxWeight)))
  {
    throw HException(((("The maximum weight ("+(hv_GrayVal.TupleMax()))+") in the weight image is greater than the given SegMaxWeight (")+hv_SegMaxWeight)+").");
  }
  //
  while (0 != (int(hv_GrayVal!=HTuple())))
  {
    //Go through all gray value 'groups',
    //starting from the maximum.
    hv_GrayValWeight = hv_GrayVal.TupleMax();
    hv_GrayVal = hv_GrayVal.TupleRemove(hv_GrayVal.TupleFind(hv_GrayValWeight));
    Threshold(ho_ImageWeight, &ho_WeightsRegion, hv_GrayValWeight, hv_GrayValWeight);
    //
    //Visualize the respective group.
    hv_ColorIndex = (((hv_GrayValWeight/hv_SegMaxWeight)*(hv_NumColors-1)).TupleCeil()).TupleInt();
    hv_ClassColor = HTuple(hv_WeightsColorsAlpha[hv_ColorIndex]);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_ClassColor);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_WeightsRegion, HDevWindowStack::GetActive());
  }
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Generate a tiled image for the classified DLSamples and add indications whether the predictions are true or not. 
void gen_tiled_classification_image_result (HObject *ho_TiledImageRow, HTuple hv_DLSamples, 
    HTuple hv_SpacingCol, HTuple hv_PredictionsCorrect, HTuple hv_ResClasses, HTuple *hv_TextImageRows, 
    HTuple *hv_TextImageColumns, HTuple *hv_TextImageWidth, HTuple *hv_TextImageHeight)
{

  // Local iconic variables
  HObject  ho_GTImagesRaw, ho_GTImage, ho_Channel;
  HObject  ho_RegionContourCheck, ho_Rectangle1, ho_Rectangle2;
  HObject  ho_RegionContourCross, ho_TopContour, ho_LeftContour;
  HObject  ho_RightContour, ho_BottomContour, ho_Frame, ho_TextImageOneChannel;
  HObject  ho_TextImageOneChannels, ho_TextImage, ho_SeparateImageOneChannel;
  HObject  ho_SeparateImageOneChannels, ho_SeparateImage, ho_GTImages;
  HObject  ho_GTImageChannelsScaled, ho_GTImageChannel, ho_GTImageChannelScaled;
  HObject  ho_GTImageR, ho_GTImageG, ho_GTImageB, ho_RegionContour;

  // Local control variables
  HTuple  hv_NumSamples, hv_NumRows, hv_NumColumns;
  HTuple  hv_Index, hv_NumChannels, hv_GrayMin, hv_GrayMax;
  HTuple  hv_IndexChannel, hv_GrayMinTmp, hv_GrayMaxTmp, hv__;
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_Length1, hv_Length2;
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate, hv_HomMat2DCompose;
  HTuple  hv_FrameSize, hv_SeparateImageHeight, hv_SeparateImageWidth;
  HTuple  hv_ScaleMax, hv_ScaleMin, hv_Color, hv_Number, hv_TiledRows;
  HTuple  hv_TiledColumns, hv_TiledHeights, hv_TiledWidths;
  HTuple  hv_MinusOnes;
  HTupleVector  hvec_GrayMins(1), hvec_GrayMaxs(1);

  //
  //This procedure generates a tiled image for the classified DLSamples.
  //In the process it adds indications if the prediction was
  //correct (green frame and checkmark) or wrong (red frame and cross).
  //
  hv_NumSamples = hv_DLSamples.TupleLength();
  //
  //Get number of rows/columns of tiled image.
  if (0 != (int(hv_NumSamples>9)))
  {
    throw HException("More than 9 images cannot be shown in the training progress.");
  }
  if (0 != (HTuple(HTuple(int(hv_NumSamples==1)).TupleOr(int(hv_NumSamples==4))).TupleOr(int(hv_NumSamples==9))))
  {
    hv_NumRows = (hv_NumSamples.TupleSqrt()).TupleInt();
    hv_NumColumns = hv_NumRows;
  }
  else
  {
    hv_NumRows = hv_NumSamples.TupleMin2(3);
    hv_NumColumns = ((hv_NumSamples-1)/hv_NumRows)+1;
  }
  //
  //Get images and minimal/maximal gray values.
  GenEmptyObj(&ho_GTImagesRaw);
  {
  HTuple end_val21 = hv_NumSamples-1;
  HTuple step_val21 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val21, step_val21); hv_Index += step_val21)
  {
    GetDictObject(&ho_GTImage, HTuple(hv_DLSamples[hv_Index]), "image");
    ConcatObj(ho_GTImagesRaw, ho_GTImage, &ho_GTImagesRaw);
    CountChannels(ho_GTImage, &hv_NumChannels);
    hv_GrayMin = HTuple();
    hv_GrayMax = HTuple();
    {
    HTuple end_val27 = hv_NumChannels-1;
    HTuple step_val27 = 1;
    for (hv_IndexChannel=0; hv_IndexChannel.Continue(end_val27, step_val27); hv_IndexChannel += step_val27)
    {
      AccessChannel(ho_GTImage, &ho_Channel, hv_IndexChannel+1);
      MinMaxGray(ho_Channel, ho_Channel, 0, &hv_GrayMinTmp, &hv_GrayMaxTmp, &hv__);
      hv_GrayMin = hv_GrayMin.TupleConcat(hv_GrayMinTmp);
      hv_GrayMax = hv_GrayMax.TupleConcat(hv_GrayMaxTmp);
    }
    }
    hvec_GrayMins[hv_Index] = HTupleVector(hv_GrayMin);
    hvec_GrayMaxs[hv_Index] = HTupleVector(hv_GrayMax);
  }
  }
  //
  //Create a checkmark, a cross, and a frame.
  //Note: It is assumed that all images have the same size.
  //Set parameters for displaying crosses/hooks at the bottom-right corner.
  GetImageSize(ho_GTImage, &hv_ImageWidth, &hv_ImageHeight);
  hv_Length1 = (hv_ImageWidth.TupleMin2(hv_ImageHeight))/5;
  hv_Length2 = (hv_ImageWidth.TupleMin2(hv_ImageHeight))/25;
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, HTuple(45).TupleRad(), 0, 0, &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, hv_ImageHeight-(0.75*hv_Length1), hv_ImageWidth-(0.75*hv_Length1), 
      &hv_HomMat2DCompose);
  //Generate checkmark.
  GenContourPolygonXld(&ho_RegionContourCheck, (((((-hv_Length2).TupleConcat(hv_Length2)).TupleConcat(hv_Length2)).TupleConcat((HTuple(0).Append(0)))).TupleConcat(-hv_Length2)).TupleConcat(-hv_Length2), 
      ((((((HTuple(0).Append(0)).TupleConcat(hv_Length1)).TupleConcat(hv_Length1)).TupleConcat(hv_Length2)).TupleConcat(hv_Length2)).TupleConcat(0))-(hv_Length1/2));
  AffineTransContourXld(ho_RegionContourCheck, &ho_RegionContourCheck, hv_HomMat2DCompose);
  //Generate cross.
  GenRectangle2ContourXld(&ho_Rectangle1, 0, 0, 0, hv_Length1/2, hv_Length2/2);
  GenRectangle2ContourXld(&ho_Rectangle2, 0, 0, 0, hv_Length2/2, hv_Length1/2);
  ConcatObj(ho_Rectangle1, ho_Rectangle2, &ho_RegionContourCross);
  AffineTransContourXld(ho_RegionContourCross, &ho_RegionContourCross, hv_HomMat2DCompose);
  //Generate the color frame.
  hv_FrameSize = 7;
  GenContourPolygonXld(&ho_TopContour, ((((HTuple(0).Append(0)).TupleConcat(hv_FrameSize)).TupleConcat(hv_FrameSize)).TupleConcat(0))-0.5, 
      (((HTuple(0).TupleConcat(hv_ImageWidth)).TupleConcat(hv_ImageWidth)).TupleConcat((HTuple(0).Append(0))))-0.5);
  GenContourPolygonXld(&ho_LeftContour, ((((HTuple(0).Append(0)).TupleConcat(hv_ImageHeight)).TupleConcat(hv_ImageHeight)).TupleConcat(0))-0.5, 
      (((HTuple(0).TupleConcat(hv_FrameSize)).TupleConcat(hv_FrameSize)).TupleConcat((HTuple(0).Append(0))))-0.5);
  GenContourPolygonXld(&ho_RightContour, (((HTuple(0).TupleConcat(hv_ImageHeight)).TupleConcat(hv_ImageHeight)).TupleConcat((HTuple(0).Append(0))))-0.5, 
      ((((hv_ImageWidth.TupleConcat(hv_ImageWidth)).TupleConcat(hv_ImageWidth-hv_FrameSize)).TupleConcat(hv_ImageWidth-hv_FrameSize)).TupleConcat(hv_ImageWidth))-0.5);
  GenContourPolygonXld(&ho_BottomContour, ((((hv_ImageHeight.TupleConcat(hv_ImageHeight-hv_FrameSize)).TupleConcat(hv_ImageHeight-hv_FrameSize)).TupleConcat(hv_ImageHeight)).TupleConcat(hv_ImageHeight))-0.5, 
      ((((HTuple(0).Append(0)).TupleConcat(hv_ImageWidth)).TupleConcat(hv_ImageWidth)).TupleConcat(0))-0.5);
  ConcatObj(ho_TopContour, ho_RightContour, &ho_Frame);
  ConcatObj(ho_Frame, ho_BottomContour, &ho_Frame);
  ConcatObj(ho_Frame, ho_LeftContour, &ho_Frame);
  //
  //Create black image to print in text later.
  (*hv_TextImageHeight) = 40;
  (*hv_TextImageWidth) = hv_ImageWidth;
  GenImageConst(&ho_TextImageOneChannel, "real", (*hv_TextImageWidth), (*hv_TextImageHeight));
  ConcatObj(ho_TextImageOneChannel, ho_TextImageOneChannel, &ho_TextImageOneChannels
      );
  ConcatObj(ho_TextImageOneChannels, ho_TextImageOneChannel, &ho_TextImageOneChannels
      );
  ChannelsToImage(ho_TextImageOneChannels, &ho_TextImage);
  //
  //Create black image to separate columns.
  hv_SeparateImageHeight = hv_NumRows*(hv_ImageHeight+(*hv_TextImageHeight));
  hv_SeparateImageWidth = 4;
  GenImageConst(&ho_SeparateImageOneChannel, "real", hv_SeparateImageWidth, hv_SeparateImageHeight);
  ConcatObj(ho_SeparateImageOneChannel, ho_SeparateImageOneChannel, &ho_SeparateImageOneChannels
      );
  ConcatObj(ho_SeparateImageOneChannels, ho_SeparateImageOneChannel, &ho_SeparateImageOneChannels
      );
  ChannelsToImage(ho_SeparateImageOneChannels, &ho_SeparateImage);
  //
  //Adapt images with frame and checkmark/cross.
  GenEmptyObj(&ho_GTImages);
  {
  HTuple end_val82 = hv_NumSamples-1;
  HTuple step_val82 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val82, step_val82); hv_Index += step_val82)
  {
    //Scale images to [0,1] to have identical color ranges.
    SelectObj(ho_GTImagesRaw, &ho_GTImage, hv_Index+1);
    CountChannels(ho_GTImage, &hv_NumChannels);
    GenEmptyObj(&ho_GTImageChannelsScaled);
    {
    HTuple end_val87 = hv_NumChannels-1;
    HTuple step_val87 = 1;
    for (hv_IndexChannel=0; hv_IndexChannel.Continue(end_val87, step_val87); hv_IndexChannel += step_val87)
    {
      AccessChannel(ho_GTImage, &ho_GTImageChannel, hv_IndexChannel+1);
      hv_ScaleMax = HTuple(hvec_GrayMaxs[hv_Index].T()[hv_IndexChannel]);
      hv_ScaleMin = HTuple(hvec_GrayMins[hv_Index].T()[hv_IndexChannel]);
      if (0 != (int((hv_ScaleMax-hv_ScaleMin)>1e-5)))
      {
        ScaleImage(ho_GTImageChannel, &ho_GTImageChannelScaled, 1.0/(hv_ScaleMax-hv_ScaleMin), 
            (-hv_ScaleMin)/(hv_ScaleMax-hv_ScaleMin));
      }
      else
      {
        ScaleImage(ho_GTImageChannel, &ho_GTImageChannelScaled, 0, 0);
      }
      ConcatObj(ho_GTImageChannelsScaled, ho_GTImageChannelScaled, &ho_GTImageChannelsScaled
          );
    }
    }
    ChannelsToImage(ho_GTImageChannelsScaled, &ho_GTImage);
    //The frame has 3 channels, hence ensure that GTImage
    //has equal number of channels for display.
    if (0 != (int(hv_NumChannels!=3)))
    {
      //Just take the first channel and use this to generate
      //an image with 3 channels for visualization.
      AccessChannel(ho_GTImage, &ho_GTImageR, 1);
      CopyImage(ho_GTImageR, &ho_GTImageG);
      CopyImage(ho_GTImageR, &ho_GTImageB);
      Compose3(ho_GTImageR, ho_GTImageG, ho_GTImageB, &ho_GTImage);
    }
    //
    if (0 != (int(HTuple(hv_PredictionsCorrect[hv_Index])==1)))
    {
      //If the actual image is predicted correctly, plot a green frame and
      //a green checkmark.
      ho_RegionContour = ho_RegionContourCheck;
      hv_Color.Clear();
      hv_Color[0] = 0;
      hv_Color[1] = 1;
      hv_Color[2] = 0;
    }
    else
    {
      //Same as for the correct predictions, plot red frame and
      //a red cross for incorrect predictions.
      ho_RegionContour = ho_RegionContourCross;
      hv_Color.Clear();
      hv_Color[0] = 1;
      hv_Color[1] = 0;
      hv_Color[2] = 0;
    }
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    PaintXld(ho_Frame, ho_GTImage, &ho_GTImage, hv_Color);
    PaintXld(ho_RegionContour, ho_GTImage, &ho_GTImage, hv_Color);
    ConcatObj(ho_GTImages, ho_GTImage, &ho_GTImages);
    //Add TextImage.
    ConcatObj(ho_GTImages, ho_TextImage, &ho_GTImages);
  }
  }
  //
  //Tile the images. The maximum is 3x3=9 samples.
  //Set row/column positions of upper-left corners of images and text images.
  CountObj(ho_GTImages, &hv_Number);
  TupleGenConst(hv_Number, 0, &hv_TiledRows);
  TupleGenConst(hv_Number, 0, &hv_TiledColumns);
  TupleGenConst(hv_Number/2, 0, &(*hv_TextImageRows));
  TupleGenConst(hv_Number/2, 0, &(*hv_TextImageColumns));
  {
  HTuple end_val136 = (hv_Number/2)-1;
  HTuple step_val136 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val136, step_val136); hv_Index += step_val136)
  {
    hv_TiledRows[2*hv_Index] = ((*hv_TextImageHeight)+hv_ImageHeight)*(hv_Index%hv_NumRows);
    (*hv_TextImageRows)[hv_Index] = (((*hv_TextImageHeight)+hv_ImageHeight)*(hv_Index%hv_NumRows))+hv_ImageHeight;
    hv_TiledRows[(2*hv_Index)+1] = HTuple((*hv_TextImageRows)[hv_Index]);
    hv_TiledColumns[2*hv_Index] = (hv_ImageWidth+hv_SeparateImageWidth)*(hv_Index/hv_NumRows);
    (*hv_TextImageColumns)[hv_Index] = HTuple(hv_TiledColumns[2*hv_Index]);
    hv_TiledColumns[(2*hv_Index)+1] = HTuple((*hv_TextImageColumns)[hv_Index]);
  }
  }
  //Add images and row/column positions of upper-left corners of SeparateImages.
  {
  HTuple end_val145 = hv_NumColumns-2;
  HTuple step_val145 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val145, step_val145); hv_Index += step_val145)
  {
    ConcatObj(ho_GTImages, ho_SeparateImage, &ho_GTImages);
    hv_TiledRows[hv_TiledRows.TupleLength()] = 0;
    hv_TiledColumns[hv_TiledColumns.TupleLength()] = (hv_Index+1)*hv_ImageWidth;
  }
  }
  //
  hv_TiledHeights = hv_NumRows*((*hv_TextImageHeight)+hv_ImageHeight);
  hv_TiledWidths = (hv_NumColumns*hv_ImageWidth)+((hv_NumColumns-1)*hv_SeparateImageWidth);
  TupleGenConst(hv_TiledRows.TupleLength(), -1, &hv_MinusOnes);
  TileImagesOffset(ho_GTImages, &(*ho_TiledImageRow), hv_TiledRows, hv_TiledColumns, 
      hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_TiledWidths, hv_TiledHeights);
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Generate a tiled image for the Deep OCR DLSamples and add indications whether the predictions are true or not. 
void gen_tiled_ocr_recognition_image_result (HObject *ho_TiledImage, HTuple hv_DLSamples, 
    HTuple hv_PredictionsCorrect, HTuple *hv_TextImageRows, HTuple *hv_TextImageColumns, 
    HTuple *hv_TextImageWidth, HTuple *hv_TextImageHeight)
{

  // Local iconic variables
  HObject  ho_SampleImagesRaw, ho_Image, ho_ChannelR;
  HObject  ho_ChannelG, ho_ChannelB, ho_TextImageRaw, ho_SeparateImage;
  HObject  ho_Checkmark, ho_Cross, ho_ImagesToTile, ho_SampleImage;
  HObject  ho_ImageChannelsScaled, ho_ImageChannel, ho_ImageChannelScaled;
  HObject  ho_ImageR, ho_ImageG, ho_ImageB, ho_PredictionSymbol;
  HObject  ho_TextImage;

  // Local control variables
  HTuple  hv_NumSamples, hv_NumColumnsTiled, hv_NumRowsTiled;
  HTuple  hv_MaxNumSamplesSupported, hv_NumRows, hv_NumColumns;
  HTuple  hv_Index, hv_ImageWidth, hv_ImageHeight, hv_SeparateImageWidth;
  HTuple  hv_SeparateImageHeight, hv_SymbolLineWidth, hv_SymbolSize;
  HTuple  hv_SymbolRow, hv_SymbolColumn, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DCompose, hv_S, hv_W;
  HTuple  hv_NumChannels, hv_IndexChannel, hv_ScaleMax, hv_ScaleMin;
  HTuple  hv_PredictionForegroundColor, hv_PredictionBackgroundColor;
  HTuple  hv_TiledRows, hv_TiledColumns, hv_TiledHeights;
  HTuple  hv_TiledWidths, hv_MinusOnes;

  //
  //This procedure generates a tiled image for the Deep OCR Recognition samples.
  //It adds indications if the prediction was correct (green bar with checkmark)
  //or wrong (red bar with cross).
  //
  hv_NumSamples = hv_DLSamples.TupleLength();
  //
  //Maximum number of samples supported: 16 (grid 4 x 4).
  hv_NumColumnsTiled.Clear();
  hv_NumColumnsTiled[0] = 1;
  hv_NumColumnsTiled[1] = 1;
  hv_NumColumnsTiled[2] = 1;
  hv_NumColumnsTiled[3] = 1;
  hv_NumColumnsTiled[4] = 2;
  hv_NumColumnsTiled[5] = 2;
  hv_NumColumnsTiled[6] = 2;
  hv_NumColumnsTiled[7] = 2;
  hv_NumColumnsTiled[8] = 3;
  hv_NumColumnsTiled[9] = 3;
  hv_NumColumnsTiled[10] = 3;
  hv_NumColumnsTiled[11] = 3;
  hv_NumColumnsTiled[12] = 4;
  hv_NumColumnsTiled[13] = 4;
  hv_NumColumnsTiled[14] = 4;
  hv_NumColumnsTiled[15] = 4;
  hv_NumRowsTiled.Clear();
  hv_NumRowsTiled[0] = 1;
  hv_NumRowsTiled[1] = 2;
  hv_NumRowsTiled[2] = 3;
  hv_NumRowsTiled[3] = 4;
  hv_NumRowsTiled[4] = 4;
  hv_NumRowsTiled[5] = 4;
  hv_NumRowsTiled[6] = 4;
  hv_NumRowsTiled[7] = 4;
  hv_NumRowsTiled[8] = 4;
  hv_NumRowsTiled[9] = 4;
  hv_NumRowsTiled[10] = 4;
  hv_NumRowsTiled[11] = 4;
  hv_NumRowsTiled[12] = 4;
  hv_NumRowsTiled[13] = 4;
  hv_NumRowsTiled[14] = 4;
  hv_NumRowsTiled[15] = 4;
  hv_MaxNumSamplesSupported = hv_NumRowsTiled.TupleLength();
  //
  //Get number of rows/columns of tiled image.
  if (0 != (int(hv_NumSamples>hv_MaxNumSamplesSupported)))
  {
    throw HException(("More than "+hv_MaxNumSamplesSupported)+" images cannot be shown in the training progress.");
  }
  hv_NumRows = HTuple(hv_NumRowsTiled[hv_NumSamples-1]);
  hv_NumColumns = HTuple(hv_NumColumnsTiled[hv_NumSamples-1]);
  //
  //Get images and minimal/maximal gray values.
  GenEmptyObj(&ho_SampleImagesRaw);
  {
  HTuple end_val21 = hv_NumSamples-1;
  HTuple step_val21 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val21, step_val21); hv_Index += step_val21)
  {
    GetDictObject(&ho_Image, HTuple(hv_DLSamples[hv_Index]), "image");
    ConcatObj(ho_SampleImagesRaw, ho_Image, &ho_SampleImagesRaw);
  }
  }
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //
  //Create text image to print in text later.
  (*hv_TextImageHeight) = 24;
  (*hv_TextImageWidth) = hv_ImageWidth;
  GenImageConst(&ho_ChannelR, "real", (*hv_TextImageWidth), (*hv_TextImageHeight));
  GenImageConst(&ho_ChannelG, "real", (*hv_TextImageWidth), (*hv_TextImageHeight));
  GenImageConst(&ho_ChannelB, "real", (*hv_TextImageWidth), (*hv_TextImageHeight));
  Compose3(ho_ChannelR, ho_ChannelG, ho_ChannelB, &ho_TextImageRaw);
  //
  //Create black image to separate columns.
  hv_SeparateImageWidth = 4;
  hv_SeparateImageHeight = hv_NumRows*(hv_ImageHeight+(*hv_TextImageHeight));
  GenImageConst(&ho_ChannelR, "real", hv_SeparateImageWidth, hv_SeparateImageHeight);
  GenImageConst(&ho_ChannelG, "real", hv_SeparateImageWidth, hv_SeparateImageHeight);
  GenImageConst(&ho_ChannelB, "real", hv_SeparateImageWidth, hv_SeparateImageHeight);
  Compose3(ho_ChannelR, ho_ChannelG, ho_ChannelB, &ho_SeparateImage);
  //
  //Create prediction symbols: checkmark/cross for correct/incorrect.
  hv_SymbolLineWidth = 3.6;
  hv_SymbolSize = 0.5*(*hv_TextImageHeight);
  hv_SymbolRow = 0.5*(*hv_TextImageHeight);
  hv_SymbolColumn = hv_ImageWidth-hv_SymbolSize;
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, HTuple(45).TupleRad(), 0, 0, &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, hv_SymbolRow, hv_SymbolColumn, &hv_HomMat2DCompose);
  hv_S = 0.5*hv_SymbolSize;
  hv_W = 0.5*hv_SymbolLineWidth;
  GenContourPolygonXld(&ho_Checkmark, (((((hv_W.TupleConcat(-0.75*hv_S)).TupleConcat(-0.75*hv_S)).TupleConcat(-hv_W)).TupleConcat(-hv_W)).TupleConcat(hv_W)).TupleConcat(hv_W), 
      (((((((-hv_S)-hv_W).TupleConcat((-hv_S)-hv_W)).TupleConcat((-hv_S)+hv_W)).TupleConcat((-hv_S)+hv_W)).TupleConcat(hv_S)).TupleConcat(hv_S)).TupleConcat((-hv_S)-hv_W));
  GenContourPolygonXld(&ho_Cross, ((((((((((((-hv_W).TupleConcat(-hv_W)).TupleConcat(-hv_S)).TupleConcat(-hv_S)).TupleConcat(-hv_W)).TupleConcat(-hv_W)).TupleConcat(hv_W)).TupleConcat(hv_W)).TupleConcat(hv_S)).TupleConcat(hv_S)).TupleConcat(hv_W)).TupleConcat(hv_W)).TupleConcat(-hv_W), 
      ((((((((((((-hv_S).TupleConcat(-hv_W)).TupleConcat(-hv_W)).TupleConcat(hv_W)).TupleConcat(hv_W)).TupleConcat(hv_S)).TupleConcat(hv_S)).TupleConcat(hv_W)).TupleConcat(hv_W)).TupleConcat(-hv_W)).TupleConcat(-hv_W)).TupleConcat(-hv_S)).TupleConcat(-hv_S));
  AffineTransContourXld(ho_Checkmark, &ho_Checkmark, hv_HomMat2DCompose);
  AffineTransContourXld(ho_Cross, &ho_Cross, hv_HomMat2DCompose);
  //
  //Adapt images with prediction results.
  GenEmptyObj(&ho_ImagesToTile);
  {
  HTuple end_val60 = hv_NumSamples-1;
  HTuple step_val60 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val60, step_val60); hv_Index += step_val60)
  {
    //Scale images to [0,1] to have identical color ranges.
    SelectObj(ho_SampleImagesRaw, &ho_SampleImage, hv_Index+1);
    FullDomain(ho_SampleImage, &ho_SampleImage);
    CountChannels(ho_SampleImage, &hv_NumChannels);
    GenEmptyObj(&ho_ImageChannelsScaled);
    {
    HTuple end_val66 = hv_NumChannels-1;
    HTuple step_val66 = 1;
    for (hv_IndexChannel=0; hv_IndexChannel.Continue(end_val66, step_val66); hv_IndexChannel += step_val66)
    {
      //ocr_recognition image range is [-1,1]
      hv_ScaleMax = 1.0;
      hv_ScaleMin = -1.0;
      AccessChannel(ho_SampleImage, &ho_ImageChannel, hv_IndexChannel+1);
      ScaleImage(ho_ImageChannel, &ho_ImageChannelScaled, 1.0/(hv_ScaleMax-hv_ScaleMin), 
          (-(hv_ScaleMin.TupleReal()))/(hv_ScaleMax-hv_ScaleMin));
      ConcatObj(ho_ImageChannelsScaled, ho_ImageChannelScaled, &ho_ImageChannelsScaled
          );
    }
    }
    ChannelsToImage(ho_ImageChannelsScaled, &ho_SampleImage);
    //Ensure that all images in Image has equal number of channels for display.
    if (0 != (int(hv_NumChannels!=3)))
    {
      AccessChannel(ho_SampleImage, &ho_ImageR, 1);
      CopyImage(ho_ImageR, &ho_ImageG);
      CopyImage(ho_ImageR, &ho_ImageB);
      Compose3(ho_ImageR, ho_ImageG, ho_ImageB, &ho_SampleImage);
    }
    //Set prediction parameters.
    if (0 != (HTuple(hv_PredictionsCorrect[hv_Index])))
    {
      hv_PredictionForegroundColor.Clear();
      hv_PredictionForegroundColor[0] = 0;
      hv_PredictionForegroundColor[1] = 1;
      hv_PredictionForegroundColor[2] = 0;
      hv_PredictionBackgroundColor.Clear();
      hv_PredictionBackgroundColor[0] = 0;
      hv_PredictionBackgroundColor[1] = 0.5;
      hv_PredictionBackgroundColor[2] = 0;
      ho_PredictionSymbol = ho_Checkmark;
    }
    else
    {
      hv_PredictionForegroundColor.Clear();
      hv_PredictionForegroundColor[0] = 1;
      hv_PredictionForegroundColor[1] = 0;
      hv_PredictionForegroundColor[2] = 0;
      hv_PredictionBackgroundColor.Clear();
      hv_PredictionBackgroundColor[0] = 0.5;
      hv_PredictionBackgroundColor[1] = 0;
      hv_PredictionBackgroundColor[2] = 0;
      ho_PredictionSymbol = ho_Cross;
    }
    //Add sample image.
    ConcatObj(ho_ImagesToTile, ho_SampleImage, &ho_ImagesToTile);
    //Add text image.
    CopyImage(ho_TextImageRaw, &ho_TextImage);
    OverpaintRegion(ho_TextImage, ho_TextImage, hv_PredictionBackgroundColor, "fill");
    PaintXld(ho_PredictionSymbol, ho_TextImage, &ho_TextImage, hv_PredictionForegroundColor);
    ConcatObj(ho_ImagesToTile, ho_TextImage, &ho_ImagesToTile);
  }
  }
  //
  //Set row/column positions of upper-left corners for the images to tile,
  //and for the text images.
  hv_TiledRows = HTuple(2*hv_NumSamples,0);
  hv_TiledColumns = HTuple(2*hv_NumSamples,0);
  (*hv_TextImageRows) = HTuple(hv_NumSamples,0);
  (*hv_TextImageColumns) = HTuple(hv_NumSamples,0);
  {
  HTuple end_val107 = hv_NumSamples-1;
  HTuple step_val107 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val107, step_val107); hv_Index += step_val107)
  {
    hv_TiledRows[2*hv_Index] = (hv_Index%hv_NumRows)*((*hv_TextImageHeight)+hv_ImageHeight);
    hv_TiledRows[(2*hv_Index)+1] = HTuple(hv_TiledRows[2*hv_Index])+hv_ImageHeight;
    hv_TiledColumns[2*hv_Index] = (hv_Index/hv_NumRows)*(hv_ImageWidth+hv_SeparateImageWidth);
    hv_TiledColumns[(2*hv_Index)+1] = HTuple(hv_TiledColumns[2*hv_Index]);
    (*hv_TextImageRows)[hv_Index] = HTuple(hv_TiledRows[(2*hv_Index)+1]);
    (*hv_TextImageColumns)[hv_Index] = HTuple(hv_TiledColumns[(2*hv_Index)+1]);
  }
  }
  //
  //Add vertical separator images to the images to tile, and
  //set the row/column positions of their upper-left corners.
  {
  HTuple end_val118 = hv_NumColumns-1;
  HTuple step_val118 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val118, step_val118); hv_Index += step_val118)
  {
    ConcatObj(ho_ImagesToTile, ho_SeparateImage, &ho_ImagesToTile);
    hv_TiledRows[hv_TiledRows.TupleLength()] = 0;
    hv_TiledColumns[hv_TiledColumns.TupleLength()] = (hv_Index*(hv_ImageWidth+hv_SeparateImageWidth))+hv_ImageWidth;
  }
  }
  //
  hv_TiledHeights = hv_NumRows*((*hv_TextImageHeight)+hv_ImageHeight);
  hv_TiledWidths = (hv_NumColumns*hv_ImageWidth)+((hv_NumColumns-1)*hv_SeparateImageWidth);
  TupleGenConst(hv_TiledRows.TupleLength(), -1, &hv_MinusOnes);
  TileImagesOffset(ho_ImagesToTile, &(*ho_TiledImage), hv_TiledRows, hv_TiledColumns, 
      hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_TiledWidths, hv_TiledHeights);
  //
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Generate a tiled image for segmentation and 3D Gripping Point Detection DLSamples. 
void gen_tiled_segmentation_image (HObject *ho_TiledImageRow, HTuple hv_DLSamples, 
    HTuple hv_SpacingCol, HTuple hv_Width, HTuple hv_Height)
{

  // Local iconic variables
  HObject  ho_GTImages, ho_GTImage;

  // Local control variables
  HTuple  hv_SegmentationImageExist, hv_GrippingMapExist;
  HTuple  hv_ImageNameKey, hv_Crop, hv_OffsetRow, hv_NumSamples;
  HTuple  hv_Index;

  //
  //This procedure tiles the existing segmentation or gripping map images in given samples in a row.
  //
  //Check the required image for tiling.
  GetDictParam(HTuple(hv_DLSamples[0]), "key_exists", "segmentation_image", &hv_SegmentationImageExist);
  GetDictParam(HTuple(hv_DLSamples[0]), "key_exists", "gripping_map", &hv_GrippingMapExist);
  if (0 != hv_SegmentationImageExist)
  {
    hv_ImageNameKey = "segmentation_image";
  }
  else if (0 != hv_GrippingMapExist)
  {
    hv_ImageNameKey = "gripping_map";
  }
  //
  TupleGenConst(hv_Width.TupleLength(), -1, &hv_Crop);
  TupleGenConst(hv_Width.TupleLength(), 0, &hv_OffsetRow);
  hv_NumSamples = hv_DLSamples.TupleLength();
  GenEmptyObj(&ho_GTImages);
  {
  HTuple end_val16 = hv_NumSamples-1;
  HTuple step_val16 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
  {
    GetDictObject(&ho_GTImage, HTuple(hv_DLSamples[hv_Index]), hv_ImageNameKey);
    ConcatObj(ho_GTImages, ho_GTImage, &ho_GTImages);
  }
  }
  //
  TileImagesOffset(ho_GTImages, &(*ho_TiledImageRow), hv_OffsetRow, (HTuple(0).TupleConcat((hv_Width+hv_SpacingCol).TupleCumul())).TupleSelectRange(0,(hv_Width.TupleLength())-1), 
      hv_Crop, hv_Crop, hv_Crop, hv_Crop, HTuple(((hv_Width+hv_SpacingCol).TupleCumul())[(hv_Width.TupleLength())-1])-hv_SpacingCol, 
      hv_Height.TupleMax());
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Get the ground truth anomaly label and label ID. 
void get_anomaly_ground_truth_label (HTuple hv_SampleKeys, HTuple hv_DLSample, HTuple *hv_AnomalyLabelGroundTruth, 
    HTuple *hv_AnomalyLabelIDGroundTruth)
{

  //
  //This procedure returns the anomaly ground truth label.
  //
  if (0 != (int((hv_SampleKeys.TupleFind("anomaly_label"))!=-1)))
  {
    GetDictTuple(hv_DLSample, "anomaly_label", &(*hv_AnomalyLabelGroundTruth));
  }
  else
  {
    throw HException("Ground truth class label cannot be found in DLSample.");
  }
  if (0 != (int((hv_SampleKeys.TupleFind("anomaly_label_id"))!=-1)))
  {
    GetDictTuple(hv_DLSample, "anomaly_label_id", &(*hv_AnomalyLabelIDGroundTruth));
  }
  else
  {
    throw HException("Ground truth class label id cannot be found in DLSample.");
  }
  //
  return;
}

// Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
// Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). 
void get_anomaly_result (HObject *ho_AnomalyImage, HObject *ho_AnomalyRegion, HTuple hv_DLResult, 
    HTuple hv_AnomalyClassThreshold, HTuple hv_AnomalyRegionThreshold, HTuple hv_AnomalyResultPostfix, 
    HTuple *hv_AnomalyScore, HTuple *hv_AnomalyClassID, HTuple *hv_AnomalyClassThresholdDisplay, 
    HTuple *hv_AnomalyRegionThresholdDisplay)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_AnomalyImageKey, hv_AnomalyScoreKey;
  HTuple  hv_AnomalyRegionKey, hv_AnomalyClassIdKey, hv_ErrorMsgPostfix;
  HTuple  hv_ResultKeys;

  //
  //This procedure returns the inference results in DLResult which are
  //the anomaly image and the anomaly score. It also returns the
  //classification of the anomaly score and segmentation of anomalous
  //pixels in the anomaly image by applying the specified thresholds if
  //given. Otherwise the results from DLResult are used.
  //
  //
  hv_AnomalyImageKey = "anomaly_image"+hv_AnomalyResultPostfix;
  hv_AnomalyScoreKey = "anomaly_score"+hv_AnomalyResultPostfix;
  hv_AnomalyRegionKey = "anomaly_region"+hv_AnomalyResultPostfix;
  hv_AnomalyClassIdKey = "anomaly_class_id"+hv_AnomalyResultPostfix;
  //
  TupleRegexpReplace(hv_AnomalyResultPostfix, "_", " ", &hv_ErrorMsgPostfix);
  //
  GetDictParam(hv_DLResult, "keys", HTuple(), &hv_ResultKeys);
  if (0 != (int(hv_ResultKeys==HTuple())))
  {
    throw HException(("Result anomaly image"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
  }
  //
  if (0 != (int((hv_ResultKeys.TupleFindFirst(hv_AnomalyImageKey))!=-1)))
  {
    GetDictObject(&(*ho_AnomalyImage), hv_DLResult, hv_AnomalyImageKey);
  }
  else
  {
    throw HException(("Result anomaly image"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
  }
  //
  if (0 != (int((hv_ResultKeys.TupleFindFirst(hv_AnomalyScoreKey))!=-1)))
  {
    GetDictTuple(hv_DLResult, hv_AnomalyScoreKey, &(*hv_AnomalyScore));
  }
  else
  {
    throw HException(("Result anomaly score"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
  }
  //
  (*hv_AnomalyRegionThresholdDisplay) = -1;
  if (0 != (int(hv_AnomalyRegionThreshold!=-1)))
  {
    //Apply threshold for segmentation result.
    if (0 != (int((hv_AnomalyRegionThreshold.TupleLength())!=1)))
    {
      throw HException("Selected 'anomaly_region_threshold' must be specified by exactly one value.");
    }
    Threshold((*ho_AnomalyImage), &(*ho_AnomalyRegion), hv_AnomalyRegionThreshold, 
        "max");
    (*hv_AnomalyRegionThresholdDisplay) = hv_AnomalyRegionThreshold;
  }
  else
  {
    //If no threshold is given, use the threshold and resulting anomaly region out of DLResult.
    if (0 != (int((hv_ResultKeys.TupleFindFirst(hv_AnomalyRegionKey))!=-1)))
    {
      GetDictObject(&(*ho_AnomalyRegion), hv_DLResult, hv_AnomalyRegionKey);
    }
    else
    {
      GenEmptyObj(&(*ho_AnomalyRegion));
    }
    if (0 != (int((hv_ResultKeys.TupleFind("anomaly_segmentation_threshold"))!=-1)))
    {
      GetDictTuple(hv_DLResult, "anomaly_segmentation_threshold", &(*hv_AnomalyRegionThresholdDisplay));
    }
  }
  //
  (*hv_AnomalyClassThresholdDisplay) = -1;
  (*hv_AnomalyClassID) = -1;
  if (0 != (int(hv_AnomalyClassThreshold!=-1)))
  {
    //Apply threshold for classification result.
    if (0 != (int((hv_AnomalyClassThreshold.TupleLength())!=1)))
    {
      throw HException("Selected 'anomaly_classification_threshold' must be specified by exactly one value.");
    }
    if (0 != (int((*hv_AnomalyScore)<hv_AnomalyClassThreshold)))
    {
      (*hv_AnomalyClassID) = 0;
    }
    else
    {
      (*hv_AnomalyClassID) = 1;
    }
    (*hv_AnomalyClassThresholdDisplay) = hv_AnomalyClassThreshold;
  }
  else
  {
    //If no threshold is given, use the threshold and resulting class id out of DLResult.
    if (0 != (int((hv_ResultKeys.TupleFindFirst(hv_AnomalyClassIdKey))!=-1)))
    {
      GetDictTuple(hv_DLResult, hv_AnomalyClassIdKey, &(*hv_AnomalyClassID));
    }
    else
    {
      (*hv_AnomalyClassID) = -1;
    }
    if (0 != (int((hv_ResultKeys.TupleFind("anomaly_classification_threshold"))!=-1)))
    {
      GetDictTuple(hv_DLResult, "anomaly_classification_threshold", &(*hv_AnomalyClassThresholdDisplay));
    }
  }
  //
  return;
}

// Chapter: Graphics / Window
// Short Description: Get the next child window that can be used for visualization. 
void get_child_window (HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize, 
    HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowImageRatio, HTuple *hv_PrevWindowCoordinatesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OpenNewWindow, hv_WindowHandles, hv_ParentWindowHandle;
  HTuple  hv_ChildWindowHandle, hv_Exception, hv_MetaInfo;
  HTuple  hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight;

  //
  //This procedure returns the next child window that
  //is used for visualization. If ReuseWindows is true
  //and WindowHandleList is suitable, the window handles
  //that are passed over are used. Else, this procedure
  //opens a new window, either next to the last ones, or
  //in a new row.
  //
  //First, check if the requested window is already available.
  hv_OpenNewWindow = 0;
  try
  {
    GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, &hv_WindowHandles);
    hv_ParentWindowHandle = ((const HTuple&)hv_WindowHandles)[0];
    hv_ChildWindowHandle = ((const HTuple&)hv_WindowHandles)[1];
    //Check if window handle is valid.
    try
    {
      FlushBuffer(hv_ChildWindowHandle);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //Since there is something wrong with the current window, create a new one.
      hv_OpenNewWindow = 1;
    }
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_OpenNewWindow = 1;
  }
  //
  //Get next child window.
  if (0 != (hv_OpenNewWindow.TupleNot()))
  {
    //
    //If possible, reuse existing window handles.
    HDevWindowStack::SetActive(hv_ChildWindowHandle);
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
    //
    GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
    //
    //Get previous window coordinates.
    GetWindowExtents(hv_ParentWindowHandle, &hv_WindowRow, &hv_WindowColumn, &hv_WindowWidth, 
        &hv_WindowHeight);
    (*hv_WindowImageRatio) = hv_WindowHeight/(hv_HeightImage*1.0);
    //
    try
    {
      //
      //Get WindowImageRatio from parent window.
      GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
          &(*hv_WindowImageRatio));
      //
      //Get previous window coordinates.
      GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", &(*hv_PrevWindowCoordinatesOut));
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //
      //Set WindowImageRatio from parent window.
      GetWindowExtents(hv_ParentWindowHandle, &hv_WindowRow, &hv_WindowColumn, &hv_WindowWidth, 
          &hv_WindowHeight);
      (*hv_WindowImageRatio) = hv_WindowHeight/(hv_HeightImage*1.0);
      //
      //Set previous window coordinates.
      (*hv_PrevWindowCoordinatesOut)[0] = hv_WindowRow;
      (*hv_PrevWindowCoordinatesOut)[1] = hv_WindowColumn;
      (*hv_PrevWindowCoordinatesOut)[2] = hv_WindowWidth;
      (*hv_PrevWindowCoordinatesOut)[3] = hv_WindowHeight;
    }
  }
  else
  {
    //
    //Open a new child window.
    open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
        hv_WindowHandleDict, hv_WindowHandleKey, &hv_ChildWindowHandle, &(*hv_PrevWindowCoordinatesOut));
    SetWindowParam(hv_ChildWindowHandle, "flush", "false");
    SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(hv_ChildWindowHandle));
  }
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Get the ground truth classification label id. 
void get_classification_ground_truth (HTuple hv_SampleKeys, HTuple hv_DLSample, HTuple *hv_ClassificationLabelIDGroundTruth)
{

  //
  //This procedure returns the classification ground truth label ID.
  //
  if (0 != (int((hv_SampleKeys.TupleFind("image_label_id"))!=-1)))
  {
    GetDictTuple(hv_DLSample, "image_label_id", &(*hv_ClassificationLabelIDGroundTruth));
  }
  else
  {
    throw HException("Ground truth class label cannot be found in DLSample.");
  }
  //
  return;
}

// Chapter: Deep Learning / Classification
// Short Description: Get the predicted classification class ID. 
void get_classification_result (HTuple hv_ResultKeys, HTuple hv_DLResult, HTuple *hv_ClassificationClassID)
{

  // Local iconic variables

  //
  //This procedure returns the predicted classification class ID.
  //
  if (0 != (int((hv_ResultKeys.TupleFind("classification_class_ids"))!=-1)))
  {
    GetDictTuple(hv_DLResult, "classification_class_ids", &(*hv_ClassificationClassID));
    if (0 != (int(((*hv_ClassificationClassID).TupleLength())>0)))
    {
      (*hv_ClassificationClassID) = ((const HTuple&)(*hv_ClassificationClassID))[0];
    }
  }
  else
  {
    throw HException("Key entry 'classification_class_ids' could not be found in DLResult.");
  }
  //
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the confidences of the segmentation result. 
void get_confidence_image (HObject *ho_ImageConfidence, HTuple hv_ResultKeys, HTuple hv_DLResult)
{

  //
  //This procedure returns confidences of the segmentation result.
  //
  if (0 != (int((hv_ResultKeys.TupleFind("segmentation_confidence"))!=-1)))
  {
    GetDictObject(&(*ho_ImageConfidence), hv_DLResult, "segmentation_confidence");
  }
  else if (0 != (int((hv_ResultKeys.TupleFind("segmentation_confidences"))!=-1)))
  {
    GetDictObject(&(*ho_ImageConfidence), hv_DLResult, "segmentation_confidences");
  }
  else
  {
    throw HException("Confidence image could not be found in DLSample.");
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
    HTuple hv_EndColor, HTuple *hv_Colors)
{

  // Local iconic variables
  HObject  ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
  HObject  ho_ImageR, ho_ImageG, ho_ImageB;

  // Local control variables
  HTuple  hv_IsString, hv_Hue, hv_Lightness, hv_Saturation;
  HTuple  hv_Rows, hv_Columns, hv_Red, hv_Green, hv_Blue;

  //
  //We get distinct color-values first in HLS color-space.
  //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
  //
  //Parameter checks.
  //NumColors.
  if (0 != (int(hv_NumColors<1)))
  {
    throw HException("NumColors should be at least 1");
  }
  if (0 != ((hv_NumColors.TupleIsInt()).TupleNot()))
  {
    throw HException("NumColors should be of type int");
  }
  if (0 != (int((hv_NumColors.TupleLength())!=1)))
  {
    throw HException("NumColors should have length 1");
  }
  //Random.
  if (0 != (HTuple(int(hv_Random!=0)).TupleAnd(int(hv_Random!=1))))
  {
    TupleIsString(hv_Random, &hv_IsString);
    if (0 != hv_IsString)
    {
      hv_Random = HTuple(int(hv_Random==HTuple("true"))).TupleOr("false");
    }
    else
    {
      throw HException("Random should be either true or false");
    }
  }
  //StartColor.
  if (0 != (int((hv_StartColor.TupleLength())!=1)))
  {
    throw HException("StartColor should have length 1");
  }
  if (0 != (HTuple(int(hv_StartColor<0)).TupleOr(int(hv_StartColor>255))))
  {
    throw HException(HTuple("StartColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_StartColor.TupleIsInt()).TupleNot()))
  {
    throw HException("StartColor should be of type int");
  }
  //EndColor.
  if (0 != (int((hv_EndColor.TupleLength())!=1)))
  {
    throw HException("EndColor should have length 1");
  }
  if (0 != (HTuple(int(hv_EndColor<0)).TupleOr(int(hv_EndColor>255))))
  {
    throw HException(HTuple("EndColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_EndColor.TupleIsInt()).TupleNot()))
  {
    throw HException("EndColor should be of type int");
  }
  //
  //Color generation.
  if (0 != (int(hv_StartColor>hv_EndColor)))
  {
    hv_EndColor += 255;
  }
  if (0 != (int(hv_NumColors!=1)))
  {
    hv_Hue = (hv_StartColor+((((hv_EndColor-hv_StartColor)*(HTuple::TupleGenSequence(0,hv_NumColors-1,1).TupleReal()))/((hv_NumColors-1).TupleReal())).TupleInt()))%255;
  }
  else
  {
    hv_Hue = (hv_StartColor.TupleConcat(hv_EndColor)).TupleMean();
  }
  if (0 != hv_Random)
  {
    hv_Hue = ((const HTuple&)hv_Hue)[HTuple::TupleRand(hv_NumColors).TupleSortIndex()];
    hv_Lightness = (((5.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
    hv_Saturation = (((9.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
  }
  else
  {
    hv_Lightness = (HTuple(hv_NumColors,0.55)*255.0).TupleInt();
    hv_Saturation = (HTuple(hv_NumColors,0.95)*255.0).TupleInt();
  }
  //
  //Write colors to a 3-channel image in order to transform easier.
  GenImageConst(&ho_HLSImageH, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageL, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageS, "byte", 1, hv_NumColors);
  GetRegionPoints(ho_HLSImageH, &hv_Rows, &hv_Columns);
  SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
  SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
  SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
  //
  //Convert from HLS to RGB.
  TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, &ho_ImageR, &ho_ImageG, &ho_ImageB, 
      "hls");
  //
  //Get RGB-values and transform to Hex.
  GetGrayval(ho_ImageR, hv_Rows, hv_Columns, &hv_Red);
  GetGrayval(ho_ImageG, hv_Rows, hv_Columns, &hv_Green);
  GetGrayval(ho_ImageB, hv_Rows, hv_Columns, &hv_Blue);
  (*hv_Colors) = (("#"+(hv_Red.TupleString("02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
  return;
  //
}

// Chapter: Deep Learning / Model
// Short Description: Generate certain colors for different ClassNames 
void get_dl_class_colors (HTuple hv_ClassNames, HTuple hv_AdditionalGreenClassNames, 
    HTuple *hv_Colors)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumColors, hv_ColorsRainbow, hv_ClassNamesGood;
  HTuple  hv_IndexFind, hv_GoodIdx, hv_CurrentColor, hv_GreenIdx;

  //
  //This procedure returns for each class a certain color.
  //
  //Define distinct colors for the classes.
  hv_NumColors = hv_ClassNames.TupleLength();
  //Get distinct colors without randomness makes neighboring colors look very similar.
  //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
  get_distinct_colors(hv_NumColors, 0, 0, 200, &hv_ColorsRainbow);
  TupleInverse(hv_ColorsRainbow, &hv_ColorsRainbow);
  make_neighboring_colors_distinguishable(hv_ColorsRainbow, &(*hv_Colors));
  //If a class 'OK','ok', 'good' or 'GOOD' or a class specified in AdditionalGreenClassNames is present set this class to green.
  //Only the first occurrence found is set to a green shade.
  TupleUnion((((HTuple("good").Append("GOOD")).Append("ok")).Append("OK")), hv_AdditionalGreenClassNames, 
      &hv_ClassNamesGood);
  {
  HTuple end_val13 = (hv_ClassNamesGood.TupleLength())-1;
  HTuple step_val13 = 1;
  for (hv_IndexFind=0; hv_IndexFind.Continue(end_val13, step_val13); hv_IndexFind += step_val13)
  {
    hv_GoodIdx = hv_ClassNames.TupleFindFirst(HTuple(hv_ClassNamesGood[hv_IndexFind]));
    if (0 != (HTuple(int(hv_GoodIdx!=-1)).TupleAnd(int((hv_ClassNames.TupleLength())<=8))))
    {
      //If number of classes is <= 8, swap color with a green color.
      hv_CurrentColor = HTuple((*hv_Colors)[hv_GoodIdx]);
      hv_GreenIdx = HTuple((hv_ClassNames.TupleLength())/2.0).TupleFloor();
      //Set to pure green.
      (*hv_Colors)[hv_GoodIdx] = "#00ff00";
      //Write original color to a green entry.
      (*hv_Colors)[hv_GreenIdx] = hv_CurrentColor;
      break;
    }
    else if (0 != (HTuple(int(hv_GoodIdx!=-1)).TupleAnd(int((hv_ClassNames.TupleLength())>8))))
    {
      //If number of classes is larger than 8, set the respective color to green.
      (*hv_Colors)[hv_GoodIdx] = "#00ff00";
      break;
    }
  }
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Get an image of a sample with a certain key. 
void get_dl_sample_image (HObject *ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample, 
    HTuple hv_Key)
{

  //This procedure returns an image with key Key of a sample.
  //
  if (0 != (int((hv_SampleKeys.TupleFind(hv_Key))!=-1)))
  {
    GetDictObject(&(*ho_Image), hv_DLSample, hv_Key);
  }
  else
  {
    throw HException(("Image with key '"+hv_Key)+"' could not be found in DLSample.");
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points from a dictionary. 
void get_gripping_points_from_dict (HTuple hv_DLResult, HTuple *hv_Rows, HTuple *hv_Columns)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_KeyExists, hv_GrippingPoints, hv_NumberOfResults;
  HTuple  hv_IndexGrippingPointsPoint, hv_GrippingPointCoordDict;

  if (0 != (int(hv_DLResult==HTuple())))
  {
    throw HException("DLResult dict is empty.");
  }
  GetDictParam(hv_DLResult, "key_exists", "gripping_points", &hv_KeyExists);
  if (0 != hv_KeyExists)
  {
    GetDictTuple(hv_DLResult, "gripping_points", &hv_GrippingPoints);
  }
  else
  {
    throw HException("Result data could not be found in DLResult.");
  }
  hv_NumberOfResults = hv_GrippingPoints.TupleLength();
  TupleGenConst(hv_NumberOfResults, 0, &(*hv_Rows));
  TupleGenConst(hv_NumberOfResults, 0, &(*hv_Columns));
  {
  HTuple end_val12 = (hv_GrippingPoints.TupleLength())-1;
  HTuple step_val12 = 1;
  for (hv_IndexGrippingPointsPoint=0; hv_IndexGrippingPointsPoint.Continue(end_val12, step_val12); hv_IndexGrippingPointsPoint += step_val12)
  {
    hv_GrippingPointCoordDict = HTuple(hv_GrippingPoints[hv_IndexGrippingPointsPoint]);
    (*hv_Rows)[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple("row");
    (*hv_Columns)[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple("column");
  }
  }
  return;
}

// Chapter: Graphics / Window
// Short Description: Get the next window that can be used for visualization. 
void get_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
    HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
    HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_CurrentWindowHandle, HTuple *hv_WindowImageRatioHeight, 
    HTuple *hv_PrevWindowCoordinatesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OpenNewWindow, hv_WindowHandles, hv_Value;
  HTuple  hv_Exception, hv_Ascent, hv_Descent, hv__, hv_NumLines;
  HTuple  hv_MarginBottom, hv_WindowImageRatioWidth, hv_SetPartRow2;
  HTuple  hv_SetPartColumn2, hv_MetaInfo;

  //
  //This procedure returns the next window that
  //is used for visualization. If ReuseWindows is true
  //and WindowHandleList is suitable, the window handles
  //that are passed over are used. Else, this procedure
  //opens a new window, either next to the last ones, or
  //in a new row.
  //
  //First, check if the requested window is already available.
  hv_OpenNewWindow = 0;
  try
  {
    GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, &hv_WindowHandles);
    (*hv_CurrentWindowHandle) = ((const HTuple&)hv_WindowHandles)[0];
    //Check if window handle is valid.
    try
    {
      GetWindowParam((*hv_CurrentWindowHandle), "flush", &hv_Value);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //If there is something wrong with the current window, create a new one.
      hv_OpenNewWindow = 1;
      RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
    }
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_OpenNewWindow = 1;
  }
  //
  //Get next window.
  if (0 != (hv_OpenNewWindow.TupleNot()))
  {
    //
    //If possible, reuse existing window handles.
    HDevWindowStack::SetActive((*hv_CurrentWindowHandle));
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    set_display_font((*hv_CurrentWindowHandle), hv_FontSize, hv_Font, "true", "false");
    //
    //Calculate MarginBottom.
    if (0 != hv_ShowBottomDesc)
    {
      GetStringExtents((*hv_CurrentWindowHandle), "test_string", &hv_Ascent, &hv_Descent, 
          &hv__, &hv__);
      hv_NumLines = hv_ShowBottomDesc;
      hv_MarginBottom = (hv_NumLines*(hv_Ascent+hv_Descent))+(2*12);
    }
    else
    {
      hv_MarginBottom = 0;
    }
    //
    //Get and set meta information for current window.
    update_window_meta_information((*hv_CurrentWindowHandle), hv_WidthImage, hv_HeightImage, 
        0, 0, hv_MapColorBarWidth, hv_MarginBottom, &(*hv_WindowImageRatioHeight), 
        &hv_WindowImageRatioWidth, &hv_SetPartRow2, &hv_SetPartColumn2, &(*hv_PrevWindowCoordinatesOut));
    //
    //Update meta information.
    GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", (*hv_WindowImageRatioHeight));
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", hv_WindowImageRatioWidth);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", hv_SetPartRow2);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", hv_SetPartColumn2);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", hv_MarginBottom);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", hv_MapColorBarWidth);
    SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", (*hv_PrevWindowCoordinatesOut));
  }
  else
  {
    //
    //Open a new window.
    open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
        hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
        hv_WindowHandleDict, hv_WindowHandleKey, &(*hv_CurrentWindowHandle), &(*hv_WindowImageRatioHeight), 
        &(*hv_PrevWindowCoordinatesOut));
    SetWindowParam((*hv_CurrentWindowHandle), "flush", "false");
  }
  //
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the ground truth segmentation image. 
void get_segmentation_image_ground_truth (HObject *ho_SegmentationImagGroundTruth, 
    HTuple hv_SampleKeys, HTuple hv_DLSample)
{

  //
  //This procedure returns the ground truth segmentation image.
  //
  if (0 != (int((hv_SampleKeys.TupleFind("segmentation_image"))!=-1)))
  {
    GetDictObject(&(*ho_SegmentationImagGroundTruth), hv_DLSample, "segmentation_image");
  }
  else
  {
    throw HException("Ground truth segmentation image could not be found in DLSample.");
  }
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the predicted segmentation result image. 
void get_segmentation_image_result (HObject *ho_SegmentationImageResult, HTuple hv_ResultKeys, 
    HTuple hv_DLResult)
{

  //
  //This procedure returns the predicted segmentation result image.
  //
  if (0 != (int((hv_ResultKeys.TupleFind("segmentation_image"))!=-1)))
  {
    GetDictObject(&(*ho_SegmentationImageResult), hv_DLResult, "segmentation_image");
  }
  else
  {
    throw HException("Result segmentation data could not be found in DLSample.");
  }
  return;
}

// Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
// Short Description: Get the weight image of a sample. 
void get_weight_image (HObject *ho_ImageWeight, HTuple hv_SampleKeys, HTuple hv_DLSample)
{

  //
  //This procedure returns the segmentation weight image of a sample.
  //
  if (0 != (int((hv_SampleKeys.TupleFind("weight_image"))!=-1)))
  {
    GetDictObject(&(*ho_ImageWeight), hv_DLSample, "weight_image");
  }
  else
  {
    throw HException("Weight image could not be found in DLSample.");
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Shuffle the input colors in a deterministic way 
void make_neighboring_colors_distinguishable (HTuple hv_ColorsRainbow, HTuple *hv_Colors)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumColors, hv_NumChunks, hv_NumLeftOver;
  HTuple  hv_ColorsPerChunk, hv_StartIdx, hv_S, hv_EndIdx;
  HTuple  hv_IdxsLeft, hv_IdxsRight;

  //
  //Shuffle the input colors in a deterministic way
  //to make adjacent colors more distinguishable.
  //Neighboring colors from the input are distributed to every NumChunks
  //position in the output.
  //Depending on the number of colors, increase NumChunks.
  hv_NumColors = hv_ColorsRainbow.TupleLength();
  if (0 != (int(hv_NumColors>=8)))
  {
    hv_NumChunks = 3;
    if (0 != (int(hv_NumColors>=40)))
    {
      hv_NumChunks = 6;
    }
    else if (0 != (int(hv_NumColors>=20)))
    {
      hv_NumChunks = 4;
    }
    (*hv_Colors) = HTuple(hv_NumColors,-1);
    //Check if the Number of Colors is dividable by NumChunks.
    hv_NumLeftOver = hv_NumColors%hv_NumChunks;
    hv_ColorsPerChunk = (hv_NumColors/hv_NumChunks).TupleInt();
    hv_StartIdx = 0;
    {
    HTuple end_val19 = hv_NumChunks-1;
    HTuple step_val19 = 1;
    for (hv_S=0; hv_S.Continue(end_val19, step_val19); hv_S += step_val19)
    {
      hv_EndIdx = (hv_StartIdx+hv_ColorsPerChunk)-1;
      if (0 != (int(hv_S<hv_NumLeftOver)))
      {
        hv_EndIdx += 1;
      }
      hv_IdxsLeft = HTuple::TupleGenSequence(hv_S,hv_NumColors-1,hv_NumChunks);
      hv_IdxsRight = HTuple::TupleGenSequence(hv_StartIdx,hv_EndIdx,1);
      (*hv_Colors)[HTuple::TupleGenSequence(hv_S,hv_NumColors-1,hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(hv_StartIdx,hv_EndIdx);
      hv_StartIdx = hv_EndIdx+1;
    }
    }
  }
  else
  {
    (*hv_Colors) = hv_ColorsRainbow;
  }
  return;
}

// Chapter: Graphics / Window
// Short Description: Open a window next to the given WindowHandleFather.  
void open_child_window (HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize, 
    HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowHandleChild, HTuple *hv_PrevWindowCoordinatesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_StringWidth, hv_IndexText, hv__, hv_TextWidth;
  HTuple  hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight;
  HTuple  hv_MetaInfo;

  //
  //This procedure opens a window next to the given WindowHandleFather.
  //
  //Get the maximum width of the text to be displayed.
  //The width should be at least 200.
  hv_StringWidth = 150;
  {
  HTuple end_val6 = (hv_Text.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_IndexText=0; hv_IndexText.Continue(end_val6, step_val6); hv_IndexText += step_val6)
  {
    GetStringExtents(hv_WindowHandleFather, HTuple(hv_Text[hv_IndexText]), &hv__, 
        &hv__, &hv_TextWidth, &hv__);
    hv_StringWidth = hv_StringWidth.TupleMax2(hv_TextWidth);
  }
  }
  //
  //Define window coordinates.
  hv_WindowRow = ((const HTuple&)hv_PrevWindowCoordinates)[0];
  hv_WindowColumn = (HTuple(hv_PrevWindowCoordinates[1])+HTuple(hv_PrevWindowCoordinates[2]))+5;
  hv_WindowWidth = hv_StringWidth+(2*12.0);
  hv_WindowHeight = ((const HTuple&)hv_PrevWindowCoordinates)[3];
  //
  SetWindowAttr("background_color","black");
  OpenWindow(hv_WindowRow,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandleChild));
  HDevWindowStack::Push((*hv_WindowHandleChild));
  set_display_font((*hv_WindowHandleChild), hv_FontSize, hv_Font, "true", "false");
  //
  //Return the coordinates of the new window.
  (*hv_PrevWindowCoordinatesOut).Clear();
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowRow);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowColumn);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowWidth);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowHeight);
  //
  //Set some meta information about the new child window handle.
  GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", (*hv_PrevWindowCoordinatesOut));
  SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
  //
  return;
}

// Chapter: Graphics / Window
// Short Description: Open a new window, either next to the last ones, or in a new row. 
void open_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
    HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
    HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
    HTuple hv_WindowHandleKey, HTuple *hv_WindowHandleNew, HTuple *hv_WindowImageRatioHeight, 
    HTuple *hv_PrevWindowCoordinatesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_PrevWindowRow, hv_PrevWindowColumn;
  HTuple  hv_PrevWindowWidth, hv_PrevWindowHeight, hv_WindowRow;
  HTuple  hv_WindowColumn, hv_Ascent, hv_Descent, hv__, hv_NumLines;
  HTuple  hv_MarginBottom, hv_WindowWidth, hv_WindowHeight;
  HTuple  hv_WindowImageRatioWidth, hv_SetPartRow2, hv_SetPartColumn2;
  HTuple  hv_MetaInfo;

  //
  //This procedure opens a new window, either next to
  //the last ones, or in a new row.
  //
  //Get coordinates of previous window.
  hv_PrevWindowRow = ((const HTuple&)hv_PrevWindowCoordinates)[0];
  hv_PrevWindowColumn = ((const HTuple&)hv_PrevWindowCoordinates)[1];
  hv_PrevWindowWidth = ((const HTuple&)hv_PrevWindowCoordinates)[2];
  hv_PrevWindowHeight = ((const HTuple&)hv_PrevWindowCoordinates)[3];
  //
  if (0 != (int((hv_PrevWindowColumn+hv_PrevWindowWidth)>hv_ThresholdWidth)))
  {
    //Open window in new row.
    hv_WindowRow = (hv_PrevWindowRow+hv_PrevWindowHeight)+55;
    hv_WindowColumn = 0;
  }
  else
  {
    //Open window in same row.
    hv_WindowRow = hv_PrevWindowRow;
    hv_WindowColumn = hv_PrevWindowColumn+hv_PrevWindowWidth;
    if (0 != (int(hv_WindowColumn!=0)))
    {
      hv_WindowColumn += 5;
    }
  }
  //
  dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage, 
      (HTuple(500).Append(800))*hv_ScaleWindows, (HTuple(400).Append(600))*hv_ScaleWindows, 
      &(*hv_WindowHandleNew));
  set_display_font((*hv_WindowHandleNew), hv_FontSize, hv_Font, "true", "false");
  //
  //Add MarginBottom and MapColorBarWidth to window.
  if (0 != hv_ShowBottomDesc)
  {
    GetStringExtents((*hv_WindowHandleNew), "Test_string", &hv_Ascent, &hv_Descent, 
        &hv__, &hv__);
    hv_NumLines = hv_ShowBottomDesc;
    hv_MarginBottom = (hv_NumLines*(hv_Ascent+hv_Descent))+(2*12);
  }
  else
  {
    hv_MarginBottom = 0;
  }
  GetWindowExtents((*hv_WindowHandleNew), &hv__, &hv__, &hv_WindowWidth, &hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),hv_WindowRow, hv_WindowColumn, 
        hv_WindowWidth+hv_MapColorBarWidth, hv_WindowHeight+hv_MarginBottom);
  //
  //Get and set meta information of new window handle.
  update_window_meta_information((*hv_WindowHandleNew), hv_WidthImage, hv_HeightImage, 
      hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, &(*hv_WindowImageRatioHeight), 
      &hv_WindowImageRatioWidth, &hv_SetPartRow2, &hv_SetPartColumn2, &(*hv_PrevWindowCoordinatesOut));
  //
  //Set window handle and some meta information about the new window handle.
  SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, (*hv_WindowHandleNew));
  GetDictTuple(hv_WindowHandleDict, "meta_information", &hv_MetaInfo);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", (*hv_WindowImageRatioHeight));
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", hv_WindowImageRatioWidth);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", hv_SetPartRow2);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", hv_SetPartColumn2);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", hv_MarginBottom);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", hv_MapColorBarWidth);
  SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", (*hv_PrevWindowCoordinatesOut));
  SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
  //
  return;
}

// Chapter: Graphics / Window
// Short Description: Set and return meta information to display images correctly. 
void update_window_meta_information (HTuple hv_WindowHandle, HTuple hv_WidthImage, 
    HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth, 
    HTuple hv_MarginBottom, HTuple *hv_WindowImageRatioHeight, HTuple *hv_WindowImageRatioWidth, 
    HTuple *hv_SetPartRow2, HTuple *hv_SetPartColumn2, HTuple *hv_PrevWindowCoordinatesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv__, hv_WindowWidth, hv_WindowHeight;
  HTuple  hv_WindowRow2, hv_WindowColumn2, hv_WindowRatio;
  HTuple  hv_ImageRow2, hv_ImageColumn2, hv_ImageRatio, hv_ImageWindowRatioHeight;
  HTuple  hv_ImageRow2InWindow, hv_ImageCol2InWindow;

  //
  //This procedure sets and returns meta information to display images correctly.
  //
  //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
  GetWindowExtents(hv_WindowHandle, &hv__, &hv__, &hv_WindowWidth, &hv_WindowHeight);
  (*hv_WindowImageRatioHeight) = hv_WindowHeight/(hv_HeightImage*1.0);
  (*hv_WindowImageRatioWidth) = hv_WindowWidth/(hv_WidthImage*1.0);
  //
  //Set window part such that image is displayed undistorted.
  hv_WindowRow2 = hv_WindowHeight;
  hv_WindowColumn2 = hv_WindowWidth;
  hv_WindowRatio = hv_WindowColumn2/(hv_WindowRow2*1.0);
  //
  hv_ImageRow2 = hv_HeightImage+(hv_MarginBottom/(*hv_WindowImageRatioHeight));
  hv_ImageColumn2 = hv_WidthImage+(hv_MapColorBarWidth/(*hv_WindowImageRatioWidth));
  hv_ImageRatio = hv_ImageColumn2/(hv_ImageRow2*1.0);
  if (0 != (int(hv_ImageRatio>hv_WindowRatio)))
  {
    //
    //Extend image until right window border.
    (*hv_SetPartColumn2) = hv_ImageColumn2;
    hv_ImageWindowRatioHeight = hv_ImageColumn2/(hv_WindowColumn2*1.0);
    hv_ImageRow2InWindow = hv_ImageRow2/hv_ImageWindowRatioHeight;
    (*hv_SetPartRow2) = hv_ImageRow2+((hv_WindowRow2-hv_ImageRow2InWindow)/(*hv_WindowImageRatioWidth));
  }
  else
  {
    //
    //Extend image until bottom of window.
    (*hv_SetPartRow2) = hv_ImageRow2;
    hv_ImageWindowRatioHeight = hv_ImageRow2/(hv_WindowRow2*1.0);
    hv_ImageCol2InWindow = hv_ImageColumn2/hv_ImageWindowRatioHeight;
    (*hv_SetPartColumn2) = hv_ImageColumn2+((hv_WindowColumn2-hv_ImageCol2InWindow)/(*hv_WindowImageRatioHeight));
  }
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, (*hv_SetPartRow2)-1, (*hv_SetPartColumn2)-1);
  //
  //Return the coordinates of the new window.
  (*hv_PrevWindowCoordinatesOut).Clear();
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowRow1);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowColumn1);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowWidth);
  (*hv_PrevWindowCoordinatesOut).Append(hv_WindowHeight);
  //
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Visualize a point cloud and 3D gripping poses. 
void visualize_point_cloud_and_gripping_pose (HTuple hv_DLSample, HTuple hv_DLResult, 
    HTuple hv_GenParams, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_Image, ho_Normals, ho_PointCloudData;

  // Local control variables
  HTuple  hv_PointCloudParams, hv_GenParamNames;
  HTuple  hv_Index, hv_GenParamNamesOM3D, hv_GenParamValuesOM3D;
  HTuple  hv_ObjectModel3D, hv_NumberOfResults, hv_KeyExists;
  HTuple  hv_GrippingPoints, hv_IndexGrippingPose, hv_GrippingPointCoordDict;
  HTuple  hv_OM3DToolOrigin, hv_OM3DBase, hv_OM3DGrippingPoints;
  HTuple  hv_GenParamNameTools, hv_GenParamValueTools, hv_IndexGenParam;
  HTuple  hv_OM3DTool, hv_Instructions, hv_Message, hv_PoseOut;
  HTuple  hv___Tmp_Ctrl_Dict_Init_0, hv___Tmp_Ctrl_Dict_Init_1;
  HTuple  hv___Tmp_Ctrl_Dict_Init_2, hv___Tmp_Ctrl_Dict_Init_3;
  HTupleVector  hvec_Poses(1);

  //Checking if the data is present has been done while
  //opening the window.
  //
  //Check mandatory point cloud specific parameters
  //for their presence.
  if (0 != (int(hv_GenParams==HTuple())))
  {
    throw HException("Missing mandatory parameters.");
  }
  hv_PointCloudParams.Clear();
  hv_PointCloudParams[0] = "arrow_length";
  hv_PointCloudParams[1] = "arrow_thickness";
  hv_PointCloudParams[2] = "sample_point_cloud";
  hv_PointCloudParams[3] = "point_cloud_sample_distance";
  hv_PointCloudParams[4] = "show_normals";
  GetDictParam(hv_GenParams, "keys", HTuple(), &hv_GenParamNames);
  {
  HTuple end_val10 = (hv_PointCloudParams.TupleLength())-1;
  HTuple step_val10 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val10, step_val10); hv_Index += step_val10)
  {
    if (0 != (int((hv_GenParamNames.TupleFind(HTuple(hv_PointCloudParams[hv_Index])))==-1)))
    {
      throw HException(("Missing mandatory parameter '"+HTuple(hv_PointCloudParams[hv_Index]))+"' in GenParams.");
    }
  }
  }
  //
  //Get data to generate the point cloud.
  GetDictObject(&ho_Image, hv_DLSample, "image");
  //
  //Set the parameters to enable the texturing in
  //visualize_object_model_3d.
  //
  CreateDict(&hv___Tmp_Ctrl_Dict_Init_0);
  SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", HTuple());
  if (0 != (((hv_GenParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0)).TupleTestEqualDictItem("point_cloud_color","comp")).TupleNot()))
  {
    hv_GenParamNamesOM3D = "color_0";
    hv_GenParamValuesOM3D = hv_GenParams.TupleGetDictTuple("point_cloud_color");
  }
  else
  {
    hv_GenParamNamesOM3D = "color_attrib_0";
    hv_GenParamValuesOM3D = "&gray";
  }
  hv___Tmp_Ctrl_Dict_Init_0 = HTuple::TupleConstant("HNULL");

  CreateDict(&hv___Tmp_Ctrl_Dict_Init_1);
  SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
  if (0 != ((hv_GenParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1)).TupleTestEqualDictItem("show_normals","comp")))
  {
    //If normals should be displayed, get the data
    //and attach the normals to the point cloud.
    GetDictObject(&ho_Normals, hv_DLSample, "normals");
    AppendChannel(ho_Image, ho_Normals, &ho_PointCloudData);
    xyz_attrib_to_object_model_3d(hv_DLSample.TupleGetDictObject("x"), hv_DLSample.TupleGetDictObject("y"), 
        hv_DLSample.TupleGetDictObject("z"), ho_PointCloudData, (((HTuple("&gray").Append("point_normal_x")).Append("point_normal_y")).Append("point_normal_z")), 
        &hv_ObjectModel3D);
    hv_GenParamNamesOM3D = hv_GenParamNamesOM3D.TupleConcat("disp_normals_0");
    hv_GenParamValuesOM3D = hv_GenParamValuesOM3D.TupleConcat("true");
    CreateDict(&hv___Tmp_Ctrl_Dict_Init_2);
    SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", HTuple());
    if (0 != (((hv_GenParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2)).TupleTestEqualDictItem("normal_color","comp")).TupleNot()))
    {
      hv_GenParamNamesOM3D = hv_GenParamNamesOM3D.TupleConcat("normal_color_0");
      hv_GenParamValuesOM3D = hv_GenParamValuesOM3D.TupleConcat(hv_GenParams.TupleGetDictTuple("normal_color"));
    }
    hv___Tmp_Ctrl_Dict_Init_2 = HTuple::TupleConstant("HNULL");
  }
  else
  {
    //If normals are not desired only texturize
    //the point cloud.
    xyz_attrib_to_object_model_3d(hv_DLSample.TupleGetDictObject("x"), hv_DLSample.TupleGetDictObject("y"), 
        hv_DLSample.TupleGetDictObject("z"), ho_Image, "&gray", &hv_ObjectModel3D);
  }
  hv___Tmp_Ctrl_Dict_Init_1 = HTuple::TupleConstant("HNULL");
  //
  //Get the poses of the gripping points.
  hv_NumberOfResults = 0;
  if (0 != (int(hv_DLResult!=HTuple())))
  {
    GetDictParam(hv_DLResult, "key_exists", "gripping_points", &hv_KeyExists);
    if (0 != hv_KeyExists)
    {
      GetDictTuple(hv_DLResult, "gripping_points", &hv_GrippingPoints);
      hv_NumberOfResults = hv_GrippingPoints.TupleLength();
      hvec_Poses = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
      {
      HTuple end_val65 = (hv_GrippingPoints.TupleLength())-1;
      HTuple step_val65 = 1;
      for (hv_IndexGrippingPose=0; hv_IndexGrippingPose.Continue(end_val65, step_val65); hv_IndexGrippingPose += step_val65)
      {
        hv_GrippingPointCoordDict = HTuple(hv_GrippingPoints[hv_IndexGrippingPose]);
        hvec_Poses[hv_IndexGrippingPose] = HTupleVector(hv_GrippingPointCoordDict.TupleGetDictTuple("pose"));
      }
      }
    }
  }
  //
  //Check if the point cloud should be sampled.
  CreateDict(&hv___Tmp_Ctrl_Dict_Init_3);
  SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", "true");
  if (0 != ((hv_GenParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3)).TupleTestEqualDictItem("sample_point_cloud","comp")))
  {
    SampleObjectModel3d(hv_ObjectModel3D, "xyz_mapping", hv_GenParams.TupleGetDictTuple("point_cloud_sample_distance"), 
        HTuple(), HTuple(), &hv_ObjectModel3D);
  }
  hv___Tmp_Ctrl_Dict_Init_3 = HTuple::TupleConstant("HNULL");
  //
  //Generate the object model for the gripping pose.
  gen_robot_tool_and_base_object_model_3d(hv_GenParams.TupleGetDictTuple("arrow_thickness"), 
      hv_GenParams.TupleGetDictTuple("arrow_length"), &hv_OM3DToolOrigin, &hv_OM3DBase);
  //
  //Transform the gripping pose object model to
  //the location in the point cloud and
  //generate the parameter names and values for
  //the gripping pose object model(s).
  hv_OM3DGrippingPoints = HTuple();
  hv_GenParamNameTools = HTuple();
  hv_GenParamValueTools = HTuple();
  hv_IndexGenParam = 1;
  {
  HTuple end_val91 = hv_NumberOfResults-1;
  HTuple step_val91 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val91, step_val91); hv_Index += step_val91)
  {
    RigidTransObjectModel3d(hv_OM3DToolOrigin, hvec_Poses[hv_Index].T(), &hv_OM3DTool);
    hv_OM3DGrippingPoints = hv_OM3DGrippingPoints.TupleConcat(hv_OM3DTool);
    hv_GenParamNameTools = ((hv_GenParamNameTools.TupleConcat("color_"+hv_IndexGenParam)).TupleConcat("color_"+(hv_IndexGenParam+1))).TupleConcat("color_"+(hv_IndexGenParam+2));
    hv_GenParamValueTools = hv_GenParamValueTools.TupleConcat(((HTuple("red").Append("green")).Append("blue")));
    hv_IndexGenParam += 3;
  }
  }
  //
  //Generate visualization.
  hv_Instructions[0] = "Rotate: Left button";
  hv_Instructions[1] = "Zoom:   Shift + left button";
  hv_Instructions[2] = "Move:   Ctrl  + left button";
  hv_Message = "Inspect 3D scene and gripping poses";
  visualize_object_model_3d(hv_WindowHandle, hv_ObjectModel3D.TupleConcat(hv_OM3DGrippingPoints), 
      HTuple(), HTuple(), hv_GenParamNamesOM3D.TupleConcat(hv_GenParamNameTools), 
      hv_GenParamValuesOM3D.TupleConcat(hv_GenParamValueTools), hv_Message, HTuple(), 
      hv_Instructions, &hv_PoseOut);
  return;
}


