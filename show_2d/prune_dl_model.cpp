///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

extern void augment_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_GenParam);

extern void estimate_progress (HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent, 
    HTuple hv_ProgressMax, HTuple *hv_SecondsElapsed, HTuple *hv_SecondsRemaining, 
    HTuple *hv_ProgressPercent, HTuple *hv_ProgressPerSecond);

extern void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
    HTuple hv_Mode, HTuple *hv_SampleIndices);

extern void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple *hv_DLSampleBatch);

extern void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, HTuple *hv_TimeString);

extern void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, HTuple *hv_TimeString);

extern void tuple_shuffle (HTuple hv_Tuple, HTuple *hv_Shuffled);


// Chapter: Deep Learning / Classification
// Short Description: Prune a deep-learning-based classification model. 
void prune_dl_model (HTuple hv_DLModelHandleToPrune, HTuple hv_DLDataset, HTuple hv_PrunePercentage, 
    HTuple hv_GenParam, HTuple *hv_DLModelHandlePruned, HTuple *hv_DLPruningHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_EnableAugmentation, hv_AugmentationParam;
  HTuple  hv_ShowProgress, hv_ModelType, hv_GenParamName;
  HTuple  hv_GenParamIndex, hv_SeedRand, hv_NumPrunableKernels;
  HTuple  hv_NumKernelsToPrune, hv_DLSamples, hv_SampleIndices;
  HTuple  hv_NumTrainSamples, hv_SampleIndicesShuffled, hv_BatchSize;
  HTuple  hv_NumIterations, hv_Progress, hv_SecondsStart;
  HTuple  hv_Iteration, hv_BatchStart, hv_BatchEnd, hv_BatchIndices;
  HTuple  hv_SecondsElapsed, hv_SecondsRemaining, hv_ProgressPercent;
  HTuple  hv_ProgressPerSecond, hv_TimeElapsedString, hv_TimeRemainingString;

  //This procedure prunes a classification model
  //by removing the specified percentage
  //of prunable convolution kernels.
  //
  //The given Dataset is used to determine the scores
  //of the kernels and therewith which kernels are removed.
  //
  //Set default generic parameter values.
  hv_EnableAugmentation = 0;
  hv_AugmentationParam = HTuple();
  hv_ShowProgress = 1;
  //
  //Pruning is only supported for models of type 'classification'.
  GetDlModelParam(hv_DLModelHandleToPrune, "type", &hv_ModelType);
  if (0 != (int(hv_ModelType!=HTuple("classification"))))
  {
    throw HException("Current model type is not supported for pruning.");
  }
  //
  //For PrunePercentage only values within [0,100] are supported.
  if (0 != (HTuple(int(hv_PrunePercentage<0)).TupleOr(int(hv_PrunePercentage>100))))
  {
    throw HException(("A pruning percentage of "+hv_PrunePercentage)+"% is not supported.");
  }
  //
  //Retrieve optional parameters given in GenParam.
  if (0 != (int(hv_GenParam!=HTuple())))
  {
    GetDictParam(hv_GenParam, "keys", HTuple(), &hv_GenParamName);
    {
    HTuple end_val26 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val26 = 1;
    for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val26, step_val26); hv_GenParamIndex += step_val26)
    {
      if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("seed_rand"))))
      {
        GetDictTuple(hv_GenParam, "seed_rand", &hv_SeedRand);
        SetSystem("seed_rand", hv_SeedRand);
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("augmentation_param"))))
      {
        hv_EnableAugmentation = 1;
        GetDictTuple(hv_GenParam, "augmentation_param", &hv_AugmentationParam);
      }
      else if (0 != (int(HTuple(hv_GenParamName[hv_GenParamIndex])==HTuple("show_progress"))))
      {
        GetDictTuple(hv_GenParam, "show_progress", &hv_ShowProgress);
        hv_ShowProgress = HTuple(int(hv_ShowProgress==HTuple("true"))).TupleOr(int(hv_ShowProgress==1));
      }
      else
      {
        throw HException(("Unknown generic parameter: '"+HTuple(hv_GenParamName[hv_GenParamIndex]))+"'");
      }
    }
    }
  }
  //
  //Create a pruning handle with pruning mode 'oracle'.
  CreateDlPruning(hv_DLModelHandleToPrune, "oracle", hv_DLDataset, &(*hv_DLPruningHandle));
  //
  //Calculate the number of convolution kernels that will be pruned.
  GetDlPruningParam((*hv_DLPruningHandle), "prunable_kernel_num", &hv_NumPrunableKernels);
  hv_NumKernelsToPrune = (hv_NumPrunableKernels*(hv_PrunePercentage/100.0)).TupleInt();
  //
  //Calculate the scores if the number of kernel to prune is greater than 0.
  if (0 != (int(hv_NumKernelsToPrune>0)))
  {
    //
    //For pruning the images of the train split are used as well.
    GetDictTuple(hv_DLDataset, "samples", &hv_DLSamples);
    find_dl_samples(hv_DLSamples, "split", "train", "match", &hv_SampleIndices);
    hv_NumTrainSamples = hv_SampleIndices.TupleLength();
    //
    //Iterate over the batches.
    tuple_shuffle(hv_SampleIndices, &hv_SampleIndicesShuffled);
    GetDlModelParam(hv_DLModelHandleToPrune, "batch_size", &hv_BatchSize);
    hv_NumIterations = hv_NumTrainSamples/hv_BatchSize;
    if (0 != (int(hv_NumIterations<1)))
    {
      throw HException(((("For batch size "+hv_BatchSize)+" more than ")+hv_NumTrainSamples)+" samples are needed\n");
    }
    //
    //Initialize progress variables.
    if (0 != hv_ShowProgress)
    {
      hv_Progress.Clear();
      hv_Progress[0] = "Procedure: prune_dl_model";
      hv_Progress[1] = "";
      hv_Progress[2] = "";
      hv_Progress[3] = "";
      CountSeconds(&hv_SecondsStart);
      // dev_inspect_ctrl(...); only in hdevelop
    }
    //
    {
    HTuple end_val72 = hv_NumIterations-1;
    HTuple step_val72 = 1;
    for (hv_Iteration=0; hv_Iteration.Continue(end_val72, step_val72); hv_Iteration += step_val72)
    {
      hv_BatchStart = hv_Iteration*hv_BatchSize;
      hv_BatchEnd = (hv_BatchStart+hv_BatchSize)-1;
      hv_BatchIndices = hv_SampleIndicesShuffled.TupleSelectRange(hv_BatchStart,hv_BatchEnd);
      read_dl_samples(hv_DLDataset, hv_BatchIndices, &hv_DLSamples);
      if (0 != hv_EnableAugmentation)
      {
        //Pruning uses the same augmentation as used for training.
        augment_dl_samples(hv_DLSamples, hv_AugmentationParam);
      }
      AddDlPruningBatch(hv_DLModelHandleToPrune, (*hv_DLPruningHandle), hv_DLSamples);
      //
      //Provide progress information.
      if (0 != hv_ShowProgress)
      {
        if (0 != (HTuple(int((hv_Iteration%10)==1)).TupleOr(int(hv_Iteration==(hv_NumIterations-1)))))
        {
          estimate_progress(hv_SecondsStart, 0, hv_Iteration, hv_NumIterations-1, 
              &hv_SecondsElapsed, &hv_SecondsRemaining, &hv_ProgressPercent, &hv_ProgressPerSecond);
          timespan_string(hv_SecondsElapsed, "auto", &hv_TimeElapsedString);
          timespan_string(hv_SecondsRemaining, "top2", &hv_TimeRemainingString);
          hv_Progress[1] = ("Progress: "+(hv_ProgressPercent.TupleRound()))+" %";
          hv_Progress[2] = "Time elapsed: "+hv_TimeElapsedString;
          hv_Progress[3] = "Time left: "+hv_TimeRemainingString;
        }
      }
    }
    }
  }
  //
  //Prune the model.
  //In case that the number of convolution kernels to prune is 0, a copy of the model will be retrieved.
  SetDlPruningParam((*hv_DLPruningHandle), "percentage", hv_PrunePercentage);
  GenDlPrunedModel(hv_DLModelHandleToPrune, (*hv_DLPruningHandle), &(*hv_DLModelHandlePruned));
  //
  //* Close progress inspect.
  if (0 != hv_ShowProgress)
  {
    hv_Progress = "Done.";
    // dev_close_inspect_ctrl(...); only in hdevelop
  }
  //
  return;
}
