///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;


// Chapter: Identification / Data Code
// Short Description: Grade data code according to a quality standard. 
void grade_data_code_2d (HTuple hv_DataCodeHandle, HTuple hv_ResultHandle, HTuple hv_Standard, 
    HTuple hv_Format, HTuple hv_Mode, HTuple *hv_GradingResults)
{

  // Local iconic variables
  HObject  ho_Modules, ho_ModuleCenters, ho_EmptyObject;
  HObject  ho_GradeModules;

  // Local control variables
  HTuple  hv_QualityStandards, hv_Message, hv_GradeFormats;
  HTuple  hv_GradingResultModes, hv_ParamQualityStd, hv_ParamLabels;
  HTuple  hv_ResultParams, hv_QualityResultParams, hv_SymbolType;
  HTuple  hv_CodeTypes, hv_ParamsAvailable, hv_IndexParamLabels;
  HTuple  hv_GradeNumbers, hv_GradeLetters, hv_ParamGrades;
  HTuple  hv_Labels, hv_Grades, hv_Index, hv_Grade, hv_ParamFloatGrades;
  HTuple  hv_FloatGrades, hv_ParamValues, hv_Values, hv_GradesData;
  HTuple  hv_Data, hv_ParamAdditionalReflectanceCheck, hv_AdditionalReflectanceCheck;
  HTuple  hv_ParamIntermLabels, hv_ParamIntermGrades, hv_ParamIntermValues;
  HTuple  hv_IntermediateResults, hv_IntermediateLabels, hv_IntermediateGrades;
  HTuple  hv_IntermediateValues, hv_IntermediateGrade, hv_ModuleData;
  HTuple  hv_ParamRows, hv_ParamCols, hv_Rows, hv_Cols, hv_Aperture;
  HTuple  hv_ModuleWidth, hv_ModuleHeight, hv_Radius, hv_RadiusTup;
  HTuple  hv_ParamReflectanceMargin, hv_ReflectanceData, hv_ReflectanceMarginModuleGrades;
  HTuple  hv_GradeIndices, hv_NameModuleGrade, hv_GradeRows;
  HTuple  hv_GradeCols, hv_GradeRadius, hv_Keys;

  //This procedure performs print quality inspection on
  //data codes and returns all results in a dictionary.
  //
  //The corresponding quality standard can be selected
  //with Standard. Quality grades can be returned as
  //numbers 0-4 or letters F-A (Format).
  //Mode defines if only the grades or all (intermediate)
  //quality grading results are returned.
  //
  //
  //First, check the input parameters.
  //
  //Parameter Standard.
  if (0 != (int((hv_Standard.TupleLength())!=1)))
  {
    throw HException("Wrong number of values for the parameter Standard. Please specify exactly one quality standard.");
  }
  hv_QualityStandards.Clear();
  hv_QualityStandards[0] = "isoiec15415";
  hv_QualityStandards[1] = "isoiec29158";
  hv_QualityStandards[2] = "aimdpm_1_2006";
  hv_QualityStandards[3] = "semi_t10";
  hv_QualityStandards[4] = "isoiec_tr_29158";
  if (0 != (int((hv_QualityStandards.TupleFind(hv_Standard))==-1)))
  {
    //The parameter 'isoiec_tr_29158' was replaced by 'isoiec29158' and
    //is only available for backward compatibility.
    hv_Message = "Invalid quality standard. Possible values for Standard are: ";
    hv_Message = (hv_Message+((hv_QualityStandards.TupleSelectRange(0,3)).TupleJoin(HTuple(", "))))+".";
    throw HException(hv_Message);
  }
  //Parameter Format.
  if (0 != (int((hv_Format.TupleLength())!=1)))
  {
    throw HException("Wrong number of values for the parameter Format. Please specify exactly one grade format.");
  }
  hv_GradeFormats.Clear();
  hv_GradeFormats[0] = "numeric";
  hv_GradeFormats[1] = "alphabetic";
  if (0 != (int((hv_GradeFormats.TupleFind(hv_Format))==-1)))
  {
    hv_Message = "Invalid grade format. Possible values for Format are: ";
    hv_Message = (hv_Message+(hv_GradeFormats.TupleJoin(HTuple(", "))))+".";
    throw HException(hv_Message);
  }
  if (0 != (HTuple(int(hv_Standard==HTuple("semi_t10"))).TupleAnd(int(hv_Format==HTuple("alphabetic")))))
  {
    throw HException("Alphabetic grades are not supported for the selected quality standard. Please use the numeric format.");
  }
  //Parameter Mode.
  if (0 != (int((hv_Mode.TupleLength())!=1)))
  {
    throw HException("Wrong number of values for the parameter Mode. Please specify exactly one grading result mode.");
  }
  hv_GradingResultModes.Clear();
  hv_GradingResultModes[0] = "grades";
  hv_GradingResultModes[1] = "all";
  if (0 != (int((hv_GradingResultModes.TupleFind(hv_Mode))==-1)))
  {
    hv_Message = "Invalid grading result mode. Possible values for Mode are: ";
    hv_Message = (hv_Message+(hv_GradingResultModes.TupleJoin(HTuple(", "))))+".";
    throw HException(hv_Message);
  }
  //Query the possible quality results for the given data code type.
  hv_ParamQualityStd = "quality_"+hv_Standard;
  hv_ParamLabels = hv_ParamQualityStd+"_labels";
  QueryDataCode2dParams(hv_DataCodeHandle, "get_result_params", &hv_ResultParams);
  hv_QualityResultParams = hv_ResultParams.TupleRegexpSelect("quality_");
  if (0 != (int(hv_Standard==HTuple("isoiec_tr_29158"))))
  {
    //The parameters 'quality_isoiec_tr_29158_...' were replaced by the parameters
    //'quality_isoiec29158_...' and are only available for backward compatibility.
    GetDataCode2dParam(hv_DataCodeHandle, "symbol_type", &hv_SymbolType);
    hv_CodeTypes.Clear();
    hv_CodeTypes[0] = "Data Matrix ECC 200";
    hv_CodeTypes[1] = "GS1 DataMatrix";
    hv_CodeTypes[2] = "QR Code";
    hv_CodeTypes[3] = "Micro QR Code";
    hv_CodeTypes[4] = "GS1 QR Code";
    hv_CodeTypes[5] = "Aztec Code";
    hv_CodeTypes[6] = "GS1 Aztec Code";
    hv_ParamsAvailable = int((hv_CodeTypes.TupleFind(hv_SymbolType))>=0);
    if (0 != hv_ParamsAvailable)
    {
      hv_QualityResultParams = hv_QualityResultParams.TupleConcat(((HTuple("quality_isoiec_tr_29158").Append("quality_isoiec_tr_29158_labels")).Append("quality_isoiec_tr_29158_values")));
      if (0 != (HTuple(int(hv_SymbolType==HTuple("Data Matrix ECC 200"))).TupleOr(int(hv_SymbolType==HTuple("GS1 DataMatrix")))))
      {
        hv_QualityResultParams = hv_QualityResultParams.TupleConcat((((((HTuple("quality_isoiec_tr_29158_intermediate").Append("quality_isoiec_tr_29158_intermediate_labels")).Append("quality_isoiec_tr_29158_intermediate_values")).Append("quality_isoiec_tr_29158_rows")).Append("quality_isoiec_tr_29158_cols")).Append("quality_isoiec_tr_29158_reflectance_margin_module_grades")));
      }
    }
  }
  //
  hv_IndexParamLabels = hv_QualityResultParams.TupleFind(hv_ParamLabels);
  if (0 != (HTuple(int(hv_IndexParamLabels==-1)).TupleOr(int(hv_IndexParamLabels==HTuple()))))
  {
    hv_Message = ("The quality standard "+hv_Standard)+" is not supported for this code type.";
    throw HException(hv_Message);
  }
  //
  //Now, perform quality grading and add results to output dictionary.
  //
  CreateDict(&(*hv_GradingResults));
  hv_GradeNumbers.Clear();
  hv_GradeNumbers[0] = 0;
  hv_GradeNumbers[1] = 1;
  hv_GradeNumbers[2] = 2;
  hv_GradeNumbers[3] = 3;
  hv_GradeNumbers[4] = 4;
  hv_GradeLetters.Clear();
  hv_GradeLetters[0] = "F";
  hv_GradeLetters[1] = "D";
  hv_GradeLetters[2] = "C";
  hv_GradeLetters[3] = "B";
  hv_GradeLetters[4] = "A";
  if (0 != (int(hv_Standard==HTuple("semi_t10"))))
  {
    //For the SEMI T10 standard no grades but values are returned.
    hv_ParamGrades = hv_ParamQualityStd+"_values";
  }
  else
  {
    hv_ParamGrades = hv_ParamQualityStd;
  }
  //
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamLabels, &hv_Labels);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamGrades, &hv_Grades);
  if (0 != (HTuple(HTuple(int(hv_Mode==HTuple("grades"))).TupleAnd(int(hv_Format==HTuple("numeric")))).TupleOr(int(hv_Standard==HTuple("semi_t10")))))
  {
    //Return labels and corresponding grades in numbers (0 to 4).
    {
    HTuple end_val88 = (hv_Labels.TupleLength())-1;
    HTuple step_val88 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val88, step_val88); hv_Index += step_val88)
    {
      SetDictTuple((*hv_GradingResults), HTuple(hv_Labels[hv_Index]), HTuple(hv_Grades[hv_Index]));
    }
    }
  }
  else if (0 != (HTuple(int(hv_Mode==HTuple("grades"))).TupleAnd(int(hv_Format==HTuple("alphabetic")))))
  {
    //Return labels and corresponding grades in letters (F to A).
    {
    HTuple end_val93 = (hv_Labels.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      if (0 != ((HTuple(hv_Grades[hv_Index]).TupleIsInt()).TupleAnd(int((hv_GradeNumbers.TupleFind(HTuple(hv_Grades[hv_Index])))>=0))))
      {
        hv_Grade = HTuple(hv_GradeLetters[HTuple(hv_Grades[hv_Index])]);
      }
      else
      {
        hv_Grade = HTuple(hv_Grades[hv_Index]);
      }
      SetDictTuple((*hv_GradingResults), HTuple(hv_Labels[hv_Index]), hv_Grade);
    }
    }
  }
  else if (0 != (int(hv_Mode==HTuple("all"))))
  {
    //Return labels and corresponding grades in numbers or letters
    //as well as the raw values for all directly measurable grades.
    hv_ParamFloatGrades = hv_ParamQualityStd+"_float_grades";
    if (0 != (int((hv_QualityResultParams.TupleFind(hv_ParamFloatGrades))>=0)))
    {
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamFloatGrades, 
          &hv_FloatGrades);
    }
    else
    {
      hv_FloatGrades = HTuple();
    }
    hv_ParamValues = hv_ParamQualityStd+"_values";
    GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamValues, &hv_Values);
    CreateDict(&hv_GradesData);
    {
    HTuple end_val113 = (hv_Labels.TupleLength())-1;
    HTuple step_val113 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val113, step_val113); hv_Index += step_val113)
    {
      CreateDict(&hv_Data);
      if (0 != (HTuple(HTuple(int(hv_Format==HTuple("alphabetic"))).TupleAnd(HTuple(hv_Grades[hv_Index]).TupleIsInt())).TupleAnd(int((hv_GradeNumbers.TupleFind(HTuple(hv_Grades[hv_Index])))>=0))))
      {
        hv_Grade = HTuple(hv_GradeLetters[HTuple(hv_Grades[hv_Index])]);
      }
      else
      {
        hv_Grade = HTuple(hv_Grades[hv_Index]);
      }
      SetDictTuple(hv_Data, "Grade", hv_Grade);
      if (0 != (int(hv_FloatGrades!=HTuple())))
      {
        SetDictTuple(hv_Data, "Grade (float)", HTuple(hv_FloatGrades[hv_Index]));
      }
      SetDictTuple(hv_Data, "Value", HTuple(hv_Values[hv_Index]));
      SetDictTuple(hv_GradesData, HTuple(hv_Labels[hv_Index]), hv_Data);
    }
    }
    SetDictTuple((*hv_GradingResults), "Grades", hv_GradesData);
  }
  //
  if (0 != (int(hv_Mode==HTuple("all"))))
  {
    //Additional reflectance check (if available).
    hv_ParamAdditionalReflectanceCheck = "quality_isoiec15415_additional_reflectance_check";
    if (0 != (int(hv_Standard==HTuple("isoiec15415"))))
    {
      if (0 != (int((hv_QualityResultParams.TupleFind(hv_ParamAdditionalReflectanceCheck))>=0)))
      {
        GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamAdditionalReflectanceCheck, 
            &hv_AdditionalReflectanceCheck);
        SetDictTuple((*hv_GradingResults), "Additional Reflectance Check", hv_AdditionalReflectanceCheck);
      }
    }
    //
    //Intermediate grading results (if available).
    hv_ParamIntermLabels = hv_ParamQualityStd+"_intermediate_labels";
    hv_ParamIntermGrades = hv_ParamQualityStd+"_intermediate";
    hv_ParamIntermValues = hv_ParamQualityStd+"_intermediate_values";
    if (0 != (int((hv_QualityResultParams.TupleFind(hv_ParamIntermLabels))>=0)))
    {
      CreateDict(&hv_IntermediateResults);
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamIntermLabels, 
          &hv_IntermediateLabels);
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamIntermGrades, 
          &hv_IntermediateGrades);
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamIntermValues, 
          &hv_IntermediateValues);
      {
      HTuple end_val149 = (hv_IntermediateLabels.TupleLength())-1;
      HTuple step_val149 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val149, step_val149); hv_Index += step_val149)
      {
        CreateDict(&hv_Data);
        if (0 != (HTuple(HTuple(int(hv_Format==HTuple("alphabetic"))).TupleAnd(HTuple(hv_IntermediateGrades[hv_Index]).TupleIsInt())).TupleAnd(int((hv_GradeNumbers.TupleFind(HTuple(hv_IntermediateGrades[hv_Index])))>=0))))
        {
          hv_IntermediateGrade = HTuple(hv_GradeLetters[HTuple(hv_IntermediateGrades[hv_Index])]);
        }
        else
        {
          hv_IntermediateGrade = HTuple(hv_IntermediateGrades[hv_Index]);
        }
        SetDictTuple(hv_Data, "Grade", hv_IntermediateGrade);
        SetDictTuple(hv_Data, "Value", HTuple(hv_IntermediateValues[hv_Index]));
        SetDictTuple(hv_IntermediateResults, HTuple(hv_IntermediateLabels[hv_Index]), 
            hv_Data);
      }
      }
      SetDictTuple((*hv_GradingResults), "Intermediate Results", hv_IntermediateResults);
    }
    //
    //Module Data (if available).
    CreateDict(&hv_ModuleData);
    hv_ParamRows = hv_ParamQualityStd+"_rows";
    hv_ParamCols = hv_ParamQualityStd+"_cols";
    if (0 != (int((hv_QualityResultParams.TupleFind(hv_ParamRows))>=0)))
    {
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamRows, &hv_Rows);
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamCols, &hv_Cols);
      SetDictTuple(hv_ModuleData, "Rows", hv_Rows);
      SetDictTuple(hv_ModuleData, "Cols", hv_Cols);
      if (0 != (int((hv_Rows.TupleLength())>0)))
      {
        //Create module rois and centers using aperture and module size.
        hv_Aperture = HTuple(hv_Grades[hv_Labels.TupleFind("Aperture")]);
        GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_width", 
            &hv_ModuleWidth);
        GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_height", 
            &hv_ModuleHeight);
        hv_Radius = (0.5*hv_Aperture)*(hv_ModuleWidth.TupleMin2(hv_ModuleHeight));
        hv_RadiusTup = HTuple(hv_Rows.TupleLength(),hv_Radius);
        GenCircleContourXld(&ho_Modules, hv_Rows, hv_Cols, hv_RadiusTup, HTuple(0).TupleRad(), 
            HTuple(360).TupleRad(), "positive", 1);
        GenCrossContourXld(&ho_ModuleCenters, hv_Rows, hv_Cols, 2*hv_Radius, HTuple(0).TupleRad());
      }
      else
      {
        GenEmptyObj(&ho_Modules);
        GenEmptyObj(&ho_ModuleCenters);
      }
      SetDictObject(ho_Modules, hv_ModuleData, "Rois");
      SetDictObject(ho_ModuleCenters, hv_ModuleData, "Centers");
    }
    //Get reflectance margin module grades.
    hv_ParamReflectanceMargin = hv_ParamQualityStd+"_reflectance_margin_module_grades";
    if (0 != (int((hv_QualityResultParams.TupleFind(hv_ParamReflectanceMargin))!=-1)))
    {
      CreateDict(&hv_ReflectanceData);
      GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_ParamReflectanceMargin, 
          &hv_ReflectanceMarginModuleGrades);
      SetDictTuple(hv_ReflectanceData, "Module Grades", hv_ReflectanceMarginModuleGrades);
      for (hv_Grade=0; hv_Grade<=4; hv_Grade+=1)
      {
        hv_GradeIndices = hv_ReflectanceMarginModuleGrades.TupleFind(hv_Grade);
        hv_NameModuleGrade = "Modules Grade "+hv_Grade;
        if (0 != (HTuple(int(hv_GradeIndices==-1)).TupleOr(int(hv_Rows==HTuple()))))
        {
          GenEmptyObj(&ho_EmptyObject);
          SetDictObject(ho_EmptyObject, hv_ReflectanceData, hv_NameModuleGrade);
          continue;
        }
        hv_GradeRows = HTuple(hv_Rows[hv_GradeIndices]);
        hv_GradeCols = HTuple(hv_Cols[hv_GradeIndices]);
        hv_GradeRadius = HTuple(hv_GradeRows.TupleLength(),hv_Radius);
        GenCircleContourXld(&ho_GradeModules, hv_GradeRows, hv_GradeCols, hv_GradeRadius, 
            HTuple(0).TupleRad(), HTuple(360).TupleRad(), "positive", 1);
        SetDictObject(ho_GradeModules, hv_ReflectanceData, hv_NameModuleGrade);
      }
      SetDictTuple(hv_ModuleData, "Reflectance Margin", hv_ReflectanceData);
    }
    GetDictParam(hv_ModuleData, "keys", HTuple(), &hv_Keys);
    if (0 != (int(hv_Keys!=HTuple())))
    {
      SetDictTuple((*hv_GradingResults), "Modules", hv_ModuleData);
    }
  }
  //
  return;
}
