///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Tuple / Arithmetic
// Short Description: Calculate the cross product of two vectors of length 3. 
extern void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
void check_dl_3d_gripping_points_and_poses_params (HTuple hv_DLGrippingPointParams);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Compute a pose from a 3D point and orientation. 
void convert_dl_3d_gripping_point_to_pose (HTuple hv_X, HTuple hv_Y, HTuple hv_Z, 
    HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, HTuple *hv_Pose);
// Chapter: OCR / Deep OCR
// Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, HTuple *hv_DetectionResults);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Propose a direction roughly orthogonal to the surface. 
void estimate_dl_3d_sorting_direction (HObject ho_X, HObject ho_Y, HObject ho_Z, 
    HTuple *hv_Direction);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Generate gripping points for connected regions of high gripping confidence. 
void gen_dl_3d_gripping_point_image_coord (HObject ho_GrippingMap, HObject *ho_Regions, 
    HTuple hv_MinAreaSize, HTuple *hv_Rows, HTuple *hv_Columns);
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points based on a 3D gripping point detection model output. 
void gen_dl_3d_gripping_points_and_poses (HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams, 
    HTuple hv_DLResultBatch);

// Procedures 
// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
void check_dl_3d_gripping_points_and_poses_params (HTuple hv_DLGrippingPointParams)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HasMinAreaSize, hv_HasSortingDir, hv_SortingDirectionRaw;
  HTuple  hv_LenSortingDirectionRaw;

  GetDictParam(hv_DLGrippingPointParams, "key_exists", "min_area_size", &hv_HasMinAreaSize);
  if (0 != hv_HasMinAreaSize)
  {
    if (0 != (int((hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size"))<=0)))
    {
      throw HException("DLGrippingPointParams.min_area_size has to be at least 1.");
    }
  }
  else
  {
    SetDictTuple(hv_DLGrippingPointParams, "min_area_size", 1);
  }
  //
  GetDictParam(hv_DLGrippingPointParams, "key_exists", "sorting_direction", &hv_HasSortingDir);
  if (0 != hv_HasSortingDir)
  {
    if (0 != (int(((hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction")).TupleLength())!=3)))
    {
      throw HException("DLGrippingPointParams.sorting_direction has to be a 3D-vector.");
    }
    hv_SortingDirectionRaw = hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction");
    hv_LenSortingDirectionRaw = ((hv_SortingDirectionRaw*hv_SortingDirectionRaw).TupleSum()).TupleSqrt();
    if (0 != (int(hv_LenSortingDirectionRaw<1.0e-06)))
    {
      throw HException("DLGrippingPointParams.sorting_direction must not be the zero-vector.");
    }
    SetDictTuple(hv_DLGrippingPointParams, "sorting_direction", hv_SortingDirectionRaw/hv_LenSortingDirectionRaw);
  }
  else
  {
    SetDictTuple(hv_DLGrippingPointParams, "sorting_direction", ((HTuple(0.0).Append(0.0)).Append(0.1)));
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Compute a pose from a 3D point and orientation. 
void convert_dl_3d_gripping_point_to_pose (HTuple hv_X, HTuple hv_Y, HTuple hv_Z, 
    HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, HTuple *hv_Pose)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Normal, hv_Abs, hv_Indices, hv_ToolInCamY;
  HTuple  hv_ToolInCamX, hv_ToolInCamHRot, hv_ToolInCamPoseRot;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_Qz;

  //Check for invalid points.
  if (0 != (HTuple(HTuple(HTuple(int(hv_X==0.0)).TupleAnd(int(hv_Y==0.0))).TupleAnd(int(hv_Z==0.0))).TupleOr(HTuple(HTuple(int(hv_NX==0.0)).TupleAnd(int(hv_NY==0.0))).TupleAnd(int(hv_NZ==0.0)))))
  {
    (*hv_Pose) = HTuple();
    return;
  }
  //
  //Get rotation.
  hv_Normal.Clear();
  hv_Normal.Append(hv_NX);
  hv_Normal.Append(hv_NY);
  hv_Normal.Append(hv_NZ);
  TupleFabs(hv_Normal, &hv_Abs);
  TupleSortIndex(hv_Abs, &hv_Indices);
  hv_ToolInCamY[HTuple(hv_Indices[0])] = 0.0;
  hv_ToolInCamY[HTuple(hv_Indices[1])] = -HTuple(hv_Normal[HTuple(hv_Indices[2])]);
  hv_ToolInCamY[HTuple(hv_Indices[2])] = HTuple(hv_Normal[HTuple(hv_Indices[1])]);
  hv_ToolInCamY = hv_ToolInCamY/(((hv_ToolInCamY*hv_ToolInCamY).TupleSum()).TupleSqrt());
  tuple_vector_cross_product(hv_ToolInCamY, hv_Normal, &hv_ToolInCamX);
  hv_ToolInCamHRot.Clear();
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[0]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[0]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[0]));
  hv_ToolInCamHRot.Append(0.0);
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[1]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[1]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[1]));
  hv_ToolInCamHRot.Append(0.0);
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamX[2]));
  hv_ToolInCamHRot.Append(HTuple(hv_ToolInCamY[2]));
  hv_ToolInCamHRot.Append(HTuple(hv_Normal[2]));
  hv_ToolInCamHRot.Append(0.0);
  HomMat3dToPose(hv_ToolInCamHRot, &hv_ToolInCamPoseRot);
  hv_ToolInCamPoseRot[5] = 0.0;
  PoseToHomMat3d(hv_ToolInCamPoseRot, &hv_HomMat3D);
  //
  //Get translation.
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, &hv_Qx, &hv_Qy, &hv_Qz);
  (*hv_Pose) = hv_ToolInCamPoseRot;
  (*hv_Pose)[0] = hv_X-hv_Qx;
  (*hv_Pose)[1] = hv_Y-hv_Qy;
  (*hv_Pose)[2] = hv_Z-hv_Qz;
  return;
}

// Chapter: OCR / Deep OCR
// Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, HTuple *hv_DetectionResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index, hv_OcrResult, hv_RequiredKeysExist;
  HTuple  hv_DetectionResult, hv___Tmp_Ctrl_Type;

  //
  //Convert Deep OCR Detection results
  //to Object Detection results.
  //
  //Create DetectionResults Dict
  TupleGenConst(hv_OcrResults.TupleLength(), HTuple::TupleConstant("HNULL"), &(*hv_DetectionResults));
  {
  HTuple end_val6 = (hv_OcrResults.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    hv_OcrResult = HTuple(hv_OcrResults[hv_Index]);
    //Check if input is valid
    GetDictParam(hv_OcrResult, "key_exists", "words", &hv_RequiredKeysExist);
    if (0 != (int((hv_RequiredKeysExist.TupleSum())!=(hv_RequiredKeysExist.TupleLength()))))
    {
      throw HException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_exists", ((((HTuple("row").Append("col")).Append("phi")).Append("length1")).Append("length2")), 
        &hv_RequiredKeysExist);
    if (0 != (int((hv_RequiredKeysExist.TupleSum())!=(hv_RequiredKeysExist.TupleLength()))))
    {
      throw HException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
    }
    //Convert ocr detection result to object detection
    CreateDict(&hv_DetectionResult);
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "row", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("row"), 
          hv_DetectionResult, "bbox_row");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_row", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("row"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "col", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("col"), 
          hv_DetectionResult, "bbox_col");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_col", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("col"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "phi", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("phi"), 
          hv_DetectionResult, "bbox_phi");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_phi", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("phi"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "length1", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("length1"), 
          hv_DetectionResult, "bbox_length1");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_length1", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("length1"));
    }
    GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", "length2", 
        &hv___Tmp_Ctrl_Type);
    if (0 != (int(hv___Tmp_Ctrl_Type==HTuple("object"))))
    {
      SetDictObject((hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictObject("length2"), 
          hv_DetectionResult, "bbox_length2");
    }
    else
    {
      SetDictTuple(hv_DetectionResult, "bbox_length2", (hv_OcrResult.TupleGetDictTuple("words")).TupleGetDictTuple("length2"));
    }
    SetDictTuple(hv_DetectionResult, "bbox_confidence", HTuple((hv_DetectionResult.TupleGetDictTuple("bbox_row")).TupleLength(),1.0));
    SetDictTuple(hv_DetectionResult, "bbox_class_id", HTuple((hv_DetectionResult.TupleGetDictTuple("bbox_row")).TupleLength(),0));
    (*hv_DetectionResults)[hv_Index] = hv_DetectionResult;
  }
  }


  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Propose a direction roughly orthogonal to the surface. 
void estimate_dl_3d_sorting_direction (HObject ho_X, HObject ho_Y, HObject ho_Z, 
    HTuple *hv_Direction)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ObjectModel3D, hv_ObjectModel3DEdges;
  HTuple  hv_Pose, hv_HomMat3D;

  //Proposes a direction roughly orthogonal to the surface
  //described by X, Y, Z. Results are best for planar
  //surfaces like an empty table or bin bottom.
  //
  XyzToObjectModel3d(ho_X, ho_Y, ho_Z, &hv_ObjectModel3D);
  EdgesObjectModel3d(hv_ObjectModel3D, 0.1, "_debug", "true", &hv_ObjectModel3DEdges);
  GetObjectModel3dParams(hv_ObjectModel3DEdges, "&viewpose", &hv_Pose);
  PoseToHomMat3d((((HTuple(0).Append(0)).Append(0)).TupleConcat(HTuple(hv_Pose[((HTuple(3).Append(4)).Append(5))]))).TupleConcat(0), 
      &hv_HomMat3D);
  (*hv_Direction).Clear();
  (*hv_Direction).Append(HTuple(hv_HomMat3D[2]));
  (*hv_Direction).Append(HTuple(hv_HomMat3D[6]));
  (*hv_Direction).Append(HTuple(hv_HomMat3D[10]));
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Generate gripping points for connected regions of high gripping confidence. 
void gen_dl_3d_gripping_point_image_coord (HObject ho_GrippingMap, HObject *ho_Regions, 
    HTuple hv_MinAreaSize, HTuple *hv_Rows, HTuple *hv_Columns)
{

  // Local iconic variables
  HObject  ho_TmpRegions, ho_FilteredRegions, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_Skeletons, ho_OrigRegion;
  HObject  ho_Skeleton, ho_SkeletonIntersection, ho_Contours;
  HObject  ho_ContourRegions, ho_ContourSelected, ho_RegionSelected;
  HObject  ho_CenterRegion;

  // Local control variables
  HTuple  hv_GapClosingRadius, hv_NumDilationRuns;
  HTuple  hv_NumRegions, hv_RegionIdx, hv_Area, hv_Row1, hv_Column1;
  HTuple  hv_Radius, hv_RadiusIndex, hv_Dilation, hv_Rows1;
  HTuple  hv_Columns1, hv_RowOut, hv_Indices, hv_SelectedColumns;
  HTuple  hv_ColumnOut, hv_NumContours, hv_CandidateRows;
  HTuple  hv_CandidateCols, hv_ContourIdx, hv_Row, hv_Column;
  HTuple  hv_MinDistance, hv_RowCandidate, hv_ColumnCandidate;
  HTuple  hv_RowUnused, hv_ColumnUnused, hv_MinDist, hv_MaxDist;
  HTuple  hv_Indices1;

  //
  //This procedure extracts connected regions from the gripping
  //map and generates a single gripping point near the center
  //of each of those regions.
  //
  hv_GapClosingRadius = 3.5;
  hv_NumDilationRuns = 5;
  //
  //Compute regions (connected components).
  Threshold(ho_GrippingMap, &ho_TmpRegions, 0.5, 1);
  //
  //Close small gaps inside regions to get a nicer skeleton.
  ClosingCircle(ho_TmpRegions, &ho_FilteredRegions, hv_GapClosingRadius);
  //
  Connection(ho_FilteredRegions, &ho_ConnectedRegions);
  //
  //Filter for regions smaller than RegionThreshold.
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinAreaSize, 
      "max");
  CountObj(ho_SelectedRegions, &hv_NumRegions);
  if (0 != (int(hv_NumRegions<1)))
  {
    GenEmptyObj(&(*ho_Regions));
    (*hv_Rows) = HTuple();
    (*hv_Columns) = HTuple();
    return;
  }
  //
  //Determine gripping point based on skeleton per region.
  Skeleton(ho_SelectedRegions, &ho_Skeletons);
  TupleGenConst(hv_NumRegions, 0, &(*hv_Rows));
  TupleGenConst(hv_NumRegions, 0, &(*hv_Columns));
  GenEmptyObj(&(*ho_Regions));
  {
  HTuple end_val31 = hv_NumRegions;
  HTuple step_val31 = 1;
  for (hv_RegionIdx=1; hv_RegionIdx.Continue(end_val31, step_val31); hv_RegionIdx += step_val31)
  {
    SelectObj(ho_SelectedRegions, &ho_OrigRegion, hv_RegionIdx);
    Intersection(ho_OrigRegion, ho_TmpRegions, &ho_OrigRegion);
    SelectObj(ho_Skeletons, &ho_Skeleton, hv_RegionIdx);
    //
    //Reduce skeleton and region produced by contours by original
    //region (if skeleton used pixels added by closing circle).
    Intersection(ho_Skeleton, ho_OrigRegion, &ho_SkeletonIntersection);
    //
    //Check if skeleton lies outside valid region
    AreaCenter(ho_SkeletonIntersection, &hv_Area, &hv_Row1, &hv_Column1);
    if (0 != (int(hv_Area==0)))
    {
      //Skeleton outside valid region -> use simple median row pixel and
      //fixing this row, the median column pixel. This case should be
      //extremely rare.
      RegionFeatures(ho_OrigRegion, "outer_radius", &hv_Radius);
      {
      HTuple end_val47 = hv_NumDilationRuns-1;
      HTuple step_val47 = 1;
      for (hv_RadiusIndex=0; hv_RadiusIndex.Continue(end_val47, step_val47); hv_RadiusIndex += step_val47)
      {
        hv_Dilation = (hv_Radius/hv_NumDilationRuns).TupleMax2(1.5);
        DilationCircle(ho_Skeleton, &ho_Skeleton, hv_Dilation);
        Intersection(ho_Skeleton, ho_OrigRegion, &ho_SkeletonIntersection);
        AreaCenter(ho_SkeletonIntersection, &hv_Area, &hv_Row1, &hv_Column1);
        if (0 != (int(hv_Area>0)))
        {
          break;
        }
      }
      }
      GetRegionPoints(ho_SkeletonIntersection, &hv_Rows1, &hv_Columns1);
      TupleMedian(hv_Rows1, &hv_RowOut);
      TupleFind(hv_Rows1, hv_RowOut, &hv_Indices);
      TupleSelect(hv_Columns1, hv_Indices, &hv_SelectedColumns);
      TupleMedian(hv_SelectedColumns, &hv_ColumnOut);
    }
    else
    {
      //Skeleton inside valid region -> use skeleton
      GenContoursSkeletonXld(ho_SkeletonIntersection, &ho_Contours, 1, "filter");
      GenRegionContourXld(ho_Contours, &ho_ContourRegions, "margin");
      Intersection(ho_ContourRegions, ho_SkeletonIntersection, &ho_ContourRegions
          );
      //
      //From every contour select middle point as candidate.
      CountObj(ho_Contours, &hv_NumContours);
      TupleGenConst(hv_NumContours, 0, &hv_CandidateRows);
      TupleGenConst(hv_NumContours, 0, &hv_CandidateCols);
      {
      HTuple end_val71 = hv_NumContours;
      HTuple step_val71 = 1;
      for (hv_ContourIdx=1; hv_ContourIdx.Continue(end_val71, step_val71); hv_ContourIdx += step_val71)
      {
        SelectObj(ho_Contours, &ho_ContourSelected, hv_ContourIdx);
        SelectObj(ho_ContourRegions, &ho_RegionSelected, hv_ContourIdx);
        //
        //Select point in RegionSelected closest to middle
        //of the contour.
        GetContourXld(ho_ContourSelected, &hv_Row, &hv_Column);
        GenRegionRuns(&ho_CenterRegion, HTuple(hv_Row[(hv_Row.TupleLength())/2]), 
            HTuple(hv_Column[(hv_Column.TupleLength())/2]), HTuple(hv_Column[(hv_Column.TupleLength())/2]));
        //
        //Make sure the selected point is always inside
        //the region.
        DistanceRrMin(ho_RegionSelected, ho_CenterRegion, &hv_MinDistance, &hv_RowCandidate, 
            &hv_ColumnCandidate, &hv_RowUnused, &hv_ColumnUnused);
        //
        hv_CandidateRows[hv_ContourIdx-1] = hv_RowCandidate;
        hv_CandidateCols[hv_ContourIdx-1] = hv_ColumnCandidate;
      }
      }
      //
      //Find candidate with minimum maximum distance to any
      //point in SkeletonIntersection.
      DistancePr(ho_SkeletonIntersection, hv_CandidateRows, hv_CandidateCols, &hv_MinDist, 
          &hv_MaxDist);
      TupleSortIndex(hv_MaxDist, &hv_Indices1);
      hv_RowOut = HTuple(hv_CandidateRows[HTuple(hv_Indices1[0])]);
      hv_ColumnOut = HTuple(hv_CandidateCols[HTuple(hv_Indices1[0])]);
    }
    //
    //Collect output.
    (*hv_Rows)[hv_RegionIdx-1] = hv_RowOut;
    (*hv_Columns)[hv_RegionIdx-1] = hv_ColumnOut;
    ConcatObj((*ho_Regions), ho_OrigRegion, &(*ho_Regions));
  }
  }
  return;
}

// Chapter: 3D Matching / 3D Gripping Point Detection
// Short Description: Extract gripping points based on a 3D gripping point detection model output. 
void gen_dl_3d_gripping_points_and_poses (HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams, 
    HTuple hv_DLResultBatch)
{

  // Local iconic variables
  HObject  ho_Regions, ho___Tmp_Obj_0;

  // Local control variables
  HTuple  hv_MinAreaSize, hv_SortingDirection, hv_SampleIndex;
  HTuple  hv_DLSample, hv_DLResult, hv_Rows, hv_Columns, hv_HasXYZ;
  HTuple  hv_X, hv_Y, hv_Z, hv_NormalsXYZ, hv_NX, hv_NY, hv_NZ;
  HTuple  hv_DLResultUnsorted, hv_Index, hv_GrippingPoint;
  HTuple  hv_Depths, hv_AscendingIndices, hv___Tmp_Ctrl_0;

  //Extracts gripping points from connected regions in the
  //'gripping_map' image of the items in DLResultBatch.
  //Stores gripping points in a dict containing
  //row, column, region and pose.
  //
  if (0 != (int((hv_DLGrippingPointParams.TupleLength())==0)))
  {
    CreateDict(&hv_DLGrippingPointParams);
  }
  //
  check_dl_3d_gripping_points_and_poses_params(hv_DLGrippingPointParams);
  //
  hv_MinAreaSize = hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size");
  hv_SortingDirection = hv_DLGrippingPointParams.TupleGetDictTuple("sorting_direction");
  //
  //Preprocess the sample entries.
  {
  HTuple end_val15 = (hv_DLSampleBatch.TupleLength())-1;
  HTuple step_val15 = 1;
  for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val15, step_val15); hv_SampleIndex += step_val15)
  {
    hv_DLSample = HTuple(hv_DLSampleBatch[hv_SampleIndex]);
    hv_DLResult = HTuple(hv_DLResultBatch[hv_SampleIndex]);
    //
    gen_dl_3d_gripping_point_image_coord(hv_DLResult.TupleGetDictObject("gripping_map"), 
        &ho_Regions, hv_MinAreaSize, &hv_Rows, &hv_Columns);
    if (0 != (int((hv_Rows.TupleLength())<1)))
    {
      SetDictTuple(hv_DLResult, "gripping_points", HTuple());
      continue;
    }
    //
    //Convert to output.
    GetDictParam(hv_DLSample, "key_exists", ((HTuple("x").Append("y")).Append("z")), 
        &hv_HasXYZ);
    TupleMin(hv_HasXYZ, &hv_HasXYZ);
    if (0 != hv_HasXYZ)
    {
      GetGrayval(hv_DLSample.TupleGetDictObject("x"), hv_Rows, hv_Columns, &hv_X);
      GetGrayval(hv_DLSample.TupleGetDictObject("y"), hv_Rows, hv_Columns, &hv_Y);
      GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns, &hv_Z);
      GetGrayval(hv_DLSample.TupleGetDictObject("normals"), hv_Rows, hv_Columns, 
          &hv_NormalsXYZ);
      hv_NX = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(0,(hv_NormalsXYZ.TupleLength())-1,3)];
      hv_NY = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(1,(hv_NormalsXYZ.TupleLength())-1,3)];
      hv_NZ = ((const HTuple&)hv_NormalsXYZ)[HTuple::TupleGenSequence(2,(hv_NormalsXYZ.TupleLength())-1,3)];
    }
    //
    TupleGenConst(hv_Rows.TupleLength(), HTuple::TupleConstant("HNULL"), &hv_DLResultUnsorted);
    {
    HTuple end_val39 = (hv_Rows.TupleLength())-1;
    HTuple step_val39 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val39, step_val39); hv_Index += step_val39)
    {
      CreateDict(&hv_GrippingPoint);
      hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
      SetDictTuple(hv_GrippingPoint, "row", HTuple(hv_Rows[hv_Index]));
      SetDictTuple(hv_GrippingPoint, "column", HTuple(hv_Columns[hv_Index]));
      SelectObj(ho_Regions, &ho___Tmp_Obj_0, hv_Index+1);
      SetDictObject(ho___Tmp_Obj_0, hv_GrippingPoint, "region");
      if (0 != hv_HasXYZ)
      {
        convert_dl_3d_gripping_point_to_pose(HTuple(hv_X[hv_Index]), HTuple(hv_Y[hv_Index]), 
            HTuple(hv_Z[hv_Index]), HTuple(hv_NX[hv_Index]), HTuple(hv_NY[hv_Index]), 
            HTuple(hv_NZ[hv_Index]), &hv___Tmp_Ctrl_0);
        SetDictTuple(hv_GrippingPoint, "pose", hv___Tmp_Ctrl_0);
      }
      hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
    }
    }
    //
    //Sort by ascending depth (closer objects first).
    if (0 != hv_HasXYZ)
    {
      hv_Depths = ((hv_X*HTuple(hv_SortingDirection[0]))+(hv_Y*HTuple(hv_SortingDirection[1])))+(hv_Z*HTuple(hv_SortingDirection[2]));
    }
    else
    {
      GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns, &hv_Depths);
    }
    TupleSortIndex(hv_Depths, &hv_AscendingIndices);
    TupleGenConst(hv_Rows.TupleLength(), HTuple::TupleConstant("HNULL"), &hv___Tmp_Ctrl_0);
    SetDictTuple(hv_DLResult, "gripping_points", hv___Tmp_Ctrl_0);
    SetDictTuple(hv_DLResult, "gripping_points", HTuple(hv_DLResultUnsorted[hv_AscendingIndices]));
  }
  }
  return;
}


