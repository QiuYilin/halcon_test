///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;


// Chapter: Inspection / Structured Light
// Short Description: Visualize the Gray code images of a structured light model. 
void structured_light_inspect_segmentation (HObject ho_CameraImages, HObject ho_BinarizedImages, 
    HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_CamImage, ho_BinImage, ho_BrightRegion;

  // Local control variables
  HTuple  hv_NumCamera, hv_NumBinarized, hv_Index;

  //This procedure helps to validate the decoded bright/dark areas
  //in the Gray code images of a structured light model, in comparison
  //to the bright/dark areas in the camera images.
  //
  //The procedure can be thus used to find a suitable value for the
  //parameter min_gray_difference. Please note that being unable to
  //find a suitable value indicates that the actual decoding was wrong
  //since the decision whether a pixel is bright or dark was often
  //incorrect. In that sense, the procedure can also be used to decide
  //whether the surface is partially specular and the pattern_type
  //'single_stripe' should be used.
  //
  HDevWindowStack::SetActive(hv_WindowHandle);
  //Check that CameraImages and BinarizedImages have equal lengths.
  CountObj(ho_CameraImages, &hv_NumCamera);
  CountObj(ho_BinarizedImages, &hv_NumBinarized);
  if (0 != (int(hv_NumCamera!=hv_NumBinarized)))
  {
    throw HException("CameraImages and BinarizedImages do not have equal lengths.");
  }
  //
  //Visualize the decoded bright region(s) on each camera image.
  {
  HTuple end_val21 = hv_NumCamera;
  HTuple step_val21 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index += step_val21)
  {
    SelectObj(ho_CameraImages, &ho_CamImage, hv_Index);
    SelectObj(ho_BinarizedImages, &ho_BinImage, hv_Index);
    //The bright region in the binarized image is that with gray
    //value = 255.
    Threshold(ho_BinImage, &ho_BrightRegion, 254, 255);
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      DispObj(ho_CamImage, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"fill");
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"#ff000010");
    if (HDevWindowStack::IsOpen())
      DispObj(ho_BrightRegion, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),1);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"#ff0000");
    if (HDevWindowStack::IsOpen())
      DispObj(ho_BrightRegion, HDevWindowStack::GetActive());
    //If the decoded bright region does not match the visible bright
    //areas on the camera image, try calling the procedure after
    //decoding with a different min_gray_difference value.
    //If no appropriate min_gray_difference value can be found, the
    //actual decode might be incorrect and not the segmentation.
    //In that case, the surface might be partially specular and
    //decoding with the pattern_type 'single_stripe' might correct
    //this effect.
    // stop(...); only in hdevelop
  }
  }
  return;
}
