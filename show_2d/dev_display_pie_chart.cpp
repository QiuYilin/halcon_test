///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam);
// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors_dev_display_pie_chart (HTuple hv_NumColors, HTuple hv_Random, 
    HTuple hv_StartColor, HTuple hv_EndColor, HTuple *hv_Colors);

// Procedures 
// Chapter: Graphics / Output
// Short Description: Display a pie chart inside a window. 
void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
{

  // Local iconic variables
  HObject  ho_Sectors, ho_Arc, ho_Sector;

  // Local control variables
  HTuple  hv_Tolerance, hv_InitialWindowHandle;
  HTuple  hv_NoInitialWindow, hv_Red, hv_Green, hv_Blue, hv_Alpha;
  HTuple  hv_InitialColor, hv_IndexColor, hv_Color_RGBA, hv_Title;
  HTuple  hv_TitleColor, hv_Footnote, hv_FootnoteColor, hv_TitleKeyExists;
  HTuple  hv_TitleColorKeyExists, hv_FootnoteKeyExists, hv_FootnoteColorKeyExists;
  HTuple  hv_GivenTitle, hv_GivenTitleColor, hv_Exception;
  HTuple  hv_GivenFootnote, hv_GivenFootnoteColor, hv_FullCircleAngle;
  HTuple  hv_StartAngle, hv_DrawColors, hv_K, hv_EndAngle;
  HTuple  hv_Rows, hv_Columns, hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_ContourStyle, hv_Ascent, hv_Descent, hv_Width;
  HTuple  hv_Height;

  //
  //Draw a pie-chart into the active window.
  //
  //Check input Ratios.
  if (0 != (int(((hv_Ratios.TupleLessElem(0.0)).TupleSum())>0)))
  {
    throw HException("Values of parameter Ratios must be positive.");
  }
  hv_Tolerance = 0.1;
  if (0 != (int(((1-(hv_Ratios.TupleSum())).TupleAbs())>=hv_Tolerance)))
  {
    throw HException("Sum of Ratios differs too much from 1.");
  }
  //
  //Get current window handle.
  if (HDevWindowStack::IsOpen())
    hv_InitialWindowHandle = HDevWindowStack::GetActive();
  //In case there is no open window, no initial values are to be reset.
  hv_NoInitialWindow = 0;
  if (0 != (int(hv_InitialWindowHandle==-1)))
  {
    hv_NoInitialWindow = 1;
  }
  else
  {
    //Get current set color.
    GetRgba(hv_InitialWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);
    hv_InitialColor = HTuple();
    {
    HTuple end_val22 = (hv_Red.TupleLength())-1;
    HTuple step_val22 = 1;
    for (hv_IndexColor=0; hv_IndexColor.Continue(end_val22, step_val22); hv_IndexColor += step_val22)
    {
      hv_Color_RGBA = ((("#"+(HTuple(hv_Red[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Green[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Blue[hv_IndexColor]).TupleString("2x")))+(HTuple(hv_Alpha[hv_IndexColor]).TupleString("2x"));
      TupleRegexpReplace(hv_Color_RGBA, (HTuple(" ").Append("replace_all")), "0", 
          &hv_Color_RGBA);
      hv_InitialColor = hv_InitialColor.TupleConcat(hv_Color_RGBA);
    }
    }
  }
  HDevWindowStack::SetActive(hv_WindowHandle);
  //
  //In case no segment colors are specified, generate random colors.
  if (0 != (int((hv_Colors.TupleLength())==0)))
  {
    //Generate random colors.
    get_distinct_colors_dev_display_pie_chart(hv_Ratios.TupleLength(), 1, 0, 220, 
        &hv_Colors);
  }
  //
  //Set default parameters.
  hv_Title = HTuple();
  hv_TitleColor = "white";
  hv_Footnote = HTuple();
  hv_FootnoteColor = "white";
  //Get generic parameters.
  if (0 != (int((hv_GenParam.TupleLength())>0)))
  {
    GetDictParam(hv_GenParam, "key_exists", "title", &hv_TitleKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "title_color", &hv_TitleColorKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "footnote", &hv_FootnoteKeyExists);
    GetDictParam(hv_GenParam, "key_exists", "footnote_color", &hv_FootnoteColorKeyExists);
    //
    //Title text.
    if (0 != hv_TitleKeyExists)
    {
      GetDictTuple(hv_GenParam, "title", &hv_GivenTitle);
      if (0 != (HTuple((hv_GivenTitle.TupleIsString()).TupleNot()).TupleOr(int((hv_GivenTitle.TupleStrlen())<1))))
      {
        throw HException("Invalid value for key 'title'");
      }
      hv_Title = hv_GivenTitle;
    }
    //Title color.
    if (0 != hv_TitleColorKeyExists)
    {
      GetDictTuple(hv_GenParam, "title_color", &hv_GivenTitleColor);
      if (0 != ((hv_GivenTitleColor.TupleIsString()).TupleNot()))
      {
        throw HException("Invalid value for key 'title_color'");
      }
      try
      {
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_GivenTitleColor);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid value for key 'title_color'");
      }
      hv_TitleColor = hv_GivenTitleColor;
    }
    //
    //Footnote text.
    if (0 != hv_FootnoteKeyExists)
    {
      GetDictTuple(hv_GenParam, "footnote", &hv_GivenFootnote);
      if (0 != (HTuple((hv_GivenFootnote.TupleIsString()).TupleNot()).TupleOr(int((hv_GivenFootnote.TupleStrlen())<1))))
      {
        throw HException("Invalid value for key 'footnote'");
      }
      hv_Footnote = hv_GivenFootnote;
    }
    //Footnote color.
    if (0 != hv_FootnoteColorKeyExists)
    {
      GetDictTuple(hv_GenParam, "footnote_color", &hv_GivenFootnoteColor);
      if (0 != ((hv_GivenFootnoteColor.TupleIsString()).TupleNot()))
      {
        throw HException("Invalid value for key 'footnote_color'");
      }
      try
      {
        if (HDevWindowStack::IsOpen())
          SetColor(HDevWindowStack::GetActive(),hv_GivenFootnoteColor);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        throw HException("Invalid value for key 'footnote_color'");
      }
      hv_FootnoteColor = hv_GivenFootnoteColor;
    }
  }
  hv_FullCircleAngle = 2*3.14159;
  hv_StartAngle = 0;
  //
  //Generate circle-sectors.
  hv_Ratios = hv_Ratios/(hv_Ratios.TupleSum());
  hv_DrawColors = HTuple();
  GenEmptyObj(&ho_Sectors);
  {
  HTuple end_val99 = (hv_Ratios.TupleLength())-1;
  HTuple step_val99 = 1;
  for (hv_K=0; hv_K.Continue(end_val99, step_val99); hv_K += step_val99)
  {
    if (0 != (int(HTuple(hv_Ratios[hv_K])>0)))
    {
      hv_EndAngle = hv_StartAngle+(HTuple(hv_Ratios[hv_K])*hv_FullCircleAngle);
      GenCircleContourXld(&ho_Arc, hv_Row, hv_Column, hv_Radius, hv_StartAngle, hv_EndAngle, 
          "positive", 1);
      GetContourXld(ho_Arc, &hv_Rows, &hv_Columns);
      GenContourPolygonXld(&ho_Sector, (hv_Row.TupleConcat(hv_Rows)).TupleConcat(hv_Row), 
          (hv_Column.TupleConcat(hv_Columns)).TupleConcat(hv_Column));
      hv_StartAngle = hv_EndAngle;
      hv_DrawColors = hv_DrawColors.TupleConcat(HTuple(hv_Colors[hv_K]));
      ConcatObj(ho_Sectors, ho_Sector, &ho_Sectors);
    }
  }
  }
  //Rotate 90 degrees such that the first sector starts at the top.
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_Row, hv_Column, 
      &hv_HomMat2DRotate);
  AffineTransContourXld(ho_Sectors, &ho_Sectors, hv_HomMat2DRotate);
  //
  //Display sectors.
  HDevWindowStack::SetActive(hv_WindowHandle);
  GetContourStyle(hv_WindowHandle, &hv_ContourStyle);
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),"stroke_and_fill");
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_DrawColors);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Sectors, HDevWindowStack::GetActive());
  //(Optional) title.
  if (0 != (int(hv_Title!=HTuple())))
  {
    GetStringExtents(hv_WindowHandle, hv_Title, &hv_Ascent, &hv_Descent, &hv_Width, 
        &hv_Height);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Title, "image", (((hv_Row-hv_Radius)-hv_Height)-hv_Ascent)-hv_Descent, 
          hv_Column-(hv_Width/2), hv_TitleColor, "box", "false");
  }
  //(Optional) footnote.
  if (0 != (int(hv_Footnote!=HTuple())))
  {
    GetStringExtents(hv_WindowHandle, hv_Footnote, &hv_Ascent, &hv_Descent, &hv_Width, 
        &hv_Height);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_Footnote, "image", (((hv_Row+hv_Radius)-hv_Height)+hv_Ascent)+hv_Descent, 
          hv_Column-(hv_Width/2), hv_FootnoteColor, "box", "false");
  }
  if (HDevWindowStack::IsOpen())
    SetContourStyle(HDevWindowStack::GetActive(),hv_ContourStyle);
  //
  //Reset original window and colors (and close the window in case there was none open).
  if (0 != hv_NoInitialWindow)
  {
    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());
  }
  else
  {
    HDevWindowStack::SetActive(hv_InitialWindowHandle);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_InitialColor);
  }
  return;
}

// Chapter: Deep Learning / Model
// Short Description: Generate NumColors distinct colors 
void get_distinct_colors_dev_display_pie_chart (HTuple hv_NumColors, HTuple hv_Random, 
    HTuple hv_StartColor, HTuple hv_EndColor, HTuple *hv_Colors)
{

  // Local iconic variables
  HObject  ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
  HObject  ho_ImageR, ho_ImageG, ho_ImageB;

  // Local control variables
  HTuple  hv_IsString, hv_Hue, hv_Lightness, hv_Saturation;
  HTuple  hv_Rows, hv_Columns, hv_Red, hv_Green, hv_Blue;

  //
  //We get distinct color-values first in HLS color-space.
  //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
  //
  //Parameter checks.
  //NumColors.
  if (0 != (int(hv_NumColors<1)))
  {
    throw HException("NumColors should be at least 1");
  }
  if (0 != ((hv_NumColors.TupleIsInt()).TupleNot()))
  {
    throw HException("NumColors should be of type int");
  }
  if (0 != (int((hv_NumColors.TupleLength())!=1)))
  {
    throw HException("NumColors should have length 1");
  }
  //Random.
  if (0 != (HTuple(int(hv_Random!=0)).TupleAnd(int(hv_Random!=1))))
  {
    TupleIsString(hv_Random, &hv_IsString);
    if (0 != hv_IsString)
    {
      hv_Random = HTuple(int(hv_Random==HTuple("true"))).TupleOr("false");
    }
    else
    {
      throw HException("Random should be either true or false");
    }
  }
  //StartColor.
  if (0 != (int((hv_StartColor.TupleLength())!=1)))
  {
    throw HException("StartColor should have length 1");
  }
  if (0 != (HTuple(int(hv_StartColor<0)).TupleOr(int(hv_StartColor>255))))
  {
    throw HException(HTuple("StartColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_StartColor.TupleIsInt()).TupleNot()))
  {
    throw HException("StartColor should be of type int");
  }
  //EndColor.
  if (0 != (int((hv_EndColor.TupleLength())!=1)))
  {
    throw HException("EndColor should have length 1");
  }
  if (0 != (HTuple(int(hv_EndColor<0)).TupleOr(int(hv_EndColor>255))))
  {
    throw HException(HTuple("EndColor should be in the range [0, 255]"));
  }
  if (0 != ((hv_EndColor.TupleIsInt()).TupleNot()))
  {
    throw HException("EndColor should be of type int");
  }
  //
  //Color generation.
  if (0 != (int(hv_StartColor>hv_EndColor)))
  {
    hv_EndColor += 255;
  }
  if (0 != (int(hv_NumColors!=1)))
  {
    hv_Hue = (hv_StartColor+((((hv_EndColor-hv_StartColor)*(HTuple::TupleGenSequence(0,hv_NumColors-1,1).TupleReal()))/((hv_NumColors-1).TupleReal())).TupleInt()))%255;
  }
  else
  {
    hv_Hue = (hv_StartColor.TupleConcat(hv_EndColor)).TupleMean();
  }
  if (0 != hv_Random)
  {
    hv_Hue = ((const HTuple&)hv_Hue)[HTuple::TupleRand(hv_NumColors).TupleSortIndex()];
    hv_Lightness = (((5.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
    hv_Saturation = (((9.0+HTuple::TupleRand(hv_NumColors))*255.0)/10.0).TupleInt();
  }
  else
  {
    hv_Lightness = (HTuple(hv_NumColors,0.55)*255.0).TupleInt();
    hv_Saturation = (HTuple(hv_NumColors,0.95)*255.0).TupleInt();
  }
  //
  //Write colors to a 3-channel image in order to transform easier.
  GenImageConst(&ho_HLSImageH, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageL, "byte", 1, hv_NumColors);
  GenImageConst(&ho_HLSImageS, "byte", 1, hv_NumColors);
  GetRegionPoints(ho_HLSImageH, &hv_Rows, &hv_Columns);
  SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
  SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
  SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
  //
  //Convert from HLS to RGB.
  TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, &ho_ImageR, &ho_ImageG, &ho_ImageB, 
      "hls");
  //
  //Get RGB-values and transform to Hex.
  GetGrayval(ho_ImageR, hv_Rows, hv_Columns, &hv_Red);
  GetGrayval(ho_ImageG, hv_Rows, hv_Columns, &hv_Green);
  GetGrayval(ho_ImageB, hv_Rows, hv_Columns, &hv_Blue);
  (*hv_Colors) = (("#"+(hv_Red.TupleString("02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
  return;
  //
}


