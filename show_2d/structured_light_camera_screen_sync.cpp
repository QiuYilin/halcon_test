///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;


// Chapter: Inspection / Structured Light
// Short Description: Acquire images for the synchronization between the screen and the camera in a structured light setup. 
void structured_light_camera_screen_sync (HObject *ho_CameraImages, HTuple hv_AcqHandle, 
    HTuple hv_WindowHandle, HTuple hv_WindowWidth, HTuple hv_WindowHeight, HTuple hv_WaitSeconds, 
    HTuple *hv_ImagesPerSecond)
{

  // Local iconic variables
  HObject  ho_VerticalStripes, ho_ScreenDomain;
  HObject  ho_HorizontalStripes, ho_Image;

  // Local control variables
  HTuple  hv_NumLoops, hv_ScrRows, hv_ScrColumns;
  HTuple  hv_Begin, hv_Index, hv_End, hv_Time;

  //This procedure helps to establish a synchronization between
  //the screen and the camera in a particular structured light setup.
  //An in-sync setup ensures accurate camera images that are captured
  //at exactly the right time.
  //These camera images show exactly one pattern image
  //each, rather than overlapping pattern images. If on the other
  //hand the camera and screen are not in sync, the captured camera
  //images will show overlap between two pattern images.
  //
  //Define the number of loops for the acquisition.
  hv_NumLoops = 10;
  //Generate test images:
  //Vertical stripe image.
  GenImageConst(&ho_VerticalStripes, "byte", hv_WindowWidth, hv_WindowHeight);
  GetDomain(ho_VerticalStripes, &ho_ScreenDomain);
  GetRegionPoints(ho_ScreenDomain, &hv_ScrRows, &hv_ScrColumns);
  SetGrayval(ho_VerticalStripes, hv_ScrRows, hv_ScrColumns, ((hv_ScrColumns/80)%2)*255);
  //Horizontal stripe image.
  GenImageConst(&ho_HorizontalStripes, "byte", hv_WindowWidth, hv_WindowHeight);
  SetGrayval(ho_HorizontalStripes, hv_ScrRows, hv_ScrColumns, ((hv_ScrRows/80)%2)*255);
  //
  GenEmptyObj(&(*ho_CameraImages));
  CountSeconds(&hv_Begin);
  {
  HTuple end_val23 = hv_NumLoops;
  HTuple step_val23 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val23, step_val23); hv_Index += step_val23)
  {
    //Display the vertical stripes image.
    DispImage(ho_VerticalStripes, hv_WindowHandle);
    //Wait the specified time before acquiring the camera image.
    WaitSeconds(hv_WaitSeconds);
    GrabImage(&ho_Image, hv_AcqHandle);
    //Add the acquired vertical image to the output.
    ConcatObj((*ho_CameraImages), ho_Image, &(*ho_CameraImages));
    //
    //Display the horizontal stripe image.
    DispImage(ho_HorizontalStripes, hv_WindowHandle);
    //Wait the specified time before acquiring the camera image.
    WaitSeconds(hv_WaitSeconds);
    GrabImage(&ho_Image, hv_AcqHandle);
    //Add the acquired horizontal image to the output.
    ConcatObj((*ho_CameraImages), ho_Image, &(*ho_CameraImages));
  }
  }
  CountSeconds(&hv_End);
  //
  //Acquisition time and acquired images per second.
  hv_Time = hv_End-hv_Begin;
  (*hv_ImagesPerSecond) = (2*hv_NumLoops)/hv_Time;
  //
  return;
}
